(function () {
  function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

  function _get3(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get3 = Reflect.get; } else { _get3 = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get3(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

  function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

  (self["webpackChunkgsense"] = self["webpackChunkgsense"] || []).push([["node_modules_firebase_compat_auth_dist_index_esm_js"], {
    /***/
    28181:
    /*!******************************************************************!*\
      !*** ./node_modules/@firebase/auth-compat/dist/index.esm2017.js ***!
      \******************************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var _firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @firebase/app-compat */
      70159);
      /* harmony import */


      var _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @firebase/auth/internal */
      97904);
      /* harmony import */


      var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @firebase/component */
      29171);
      /* harmony import */


      var _firebase_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @firebase/util */
      29870);

      var name = "@firebase/auth-compat";
      var version = "0.2.1";
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      var CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1000;

      function _getCurrentScheme() {
        var _a;

        return ((_a = self === null || self === void 0 ? void 0 : self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;
      }
      /**
       * @return {boolean} Whether the current environment is http or https.
       */


      function _isHttpOrHttps() {
        return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';
      }
      /**
       * @param {?string=} ua The user agent.
       * @return {boolean} Whether the app is rendered in a mobile iOS or Android
       *     Cordova environment.
       */


      function _isAndroidOrIosCordovaScheme() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.getUA)();
        return !!((_getCurrentScheme() === 'file:' || _getCurrentScheme() === 'ionic:') && ua.toLowerCase().match(/iphone|ipad|ipod|android/));
      }
      /**
       * @return {boolean} Whether the environment is a native environment, where
       *     CORS checks do not apply.
       */


      function _isNativeEnvironment() {
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.isReactNative)() || (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.isNode)();
      }
      /**
       * Checks whether the user agent is IE11.
       * @return {boolean} True if it is IE11.
       */


      function _isIe11() {
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.isIE)() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;
      }
      /**
       * Checks whether the user agent is Edge.
       * @param {string} userAgent The browser user agent string.
       * @return {boolean} True if it is Edge.
       */


      function _isEdge() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.getUA)();
        return /Edge\/\d+/.test(ua);
      }
      /**
       * @param {?string=} opt_userAgent The navigator user agent.
       * @return {boolean} Whether local storage is not synchronized between an iframe
       *     and a popup of the same domain.
       */


      function _isLocalStorageNotSynchronized() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.getUA)();
        return _isIe11() || _isEdge(ua);
      }
      /** @return {boolean} Whether web storage is supported. */


      function _isWebStorageSupported() {
        try {
          var storage = self.localStorage;

          var key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._generateEventId();

          if (storage) {
            // setItem will throw an exception if we cannot access WebStorage (e.g.,
            // Safari in private mode).
            storage['setItem'](key, '1');
            storage['removeItem'](key); // For browsers where iframe web storage does not synchronize with a popup
            // of the same domain, indexedDB is used for persistent storage. These
            // browsers include IE11 and Edge.
            // Make sure it is supported (IE11 and Edge private mode does not support
            // that).

            if (_isLocalStorageNotSynchronized()) {
              // In such browsers, if indexedDB is not supported, an iframe cannot be
              // notified of the popup sign in result.
              return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.isIndexedDBAvailable)();
            }

            return true;
          }
        } catch (e) {
          // localStorage is not available from a worker. Test availability of
          // indexedDB.
          return _isWorker() && (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.isIndexedDBAvailable)();
        }

        return false;
      }
      /**
       * @param {?Object=} global The optional global scope.
       * @return {boolean} Whether current environment is a worker.
       */


      function _isWorker() {
        // WorkerGlobalScope only defined in worker environment.
        return typeof global !== 'undefined' && 'WorkerGlobalScope' in global && 'importScripts' in global;
      }

      function _isPopupRedirectSupported() {
        return (_isHttpOrHttps() || (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.isBrowserExtension)() || _isAndroidOrIosCordovaScheme()) && // React Native with remote debugging reports its location.protocol as
        // http.
        !_isNativeEnvironment() && // Local storage has to be supported for browser popup and redirect
        // operations to work.
        _isWebStorageSupported() && // DOM, popups and redirects are not supported within a worker.
        !_isWorker();
      }
      /** Quick check that indicates the platform *may* be Cordova */


      function _isLikelyCordova() {
        return _isAndroidOrIosCordovaScheme() && typeof document !== 'undefined';
      }

      function _isCordova() {
        return _isCordova2.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _isCordova2() {
        _isCordova2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
          return regeneratorRuntime.wrap(function _callee17$(_context17) {
            while (1) {
              switch (_context17.prev = _context17.next) {
                case 0:
                  if (_isLikelyCordova()) {
                    _context17.next = 2;
                    break;
                  }

                  return _context17.abrupt("return", false);

                case 2:
                  return _context17.abrupt("return", new Promise(function (resolve) {
                    var timeoutId = setTimeout(function () {
                      // We've waited long enough; the telltale Cordova event didn't happen
                      resolve(false);
                    }, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);
                    document.addEventListener('deviceready', function () {
                      clearTimeout(timeoutId);
                      resolve(true);
                    });
                  }));

                case 3:
                case "end":
                  return _context17.stop();
              }
            }
          }, _callee17);
        }));
        return _isCordova2.apply(this, arguments);
      }

      var Persistence = {
        LOCAL: 'local',
        NONE: 'none',
        SESSION: 'session'
      };
      var _assert$3 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._assert;
      var PERSISTENCE_KEY = 'persistence';
      /**
       * Validates that an argument is a valid persistence value. If an invalid type
       * is specified, an error is thrown synchronously.
       */

      function _validatePersistenceArgument(auth, persistence) {
        _assert$3(Object.values(Persistence).includes(persistence), auth, "invalid-persistence-type"
        /* INVALID_PERSISTENCE */
        ); // Validate if the specified type is supported in the current environment.


        if ((0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.isReactNative)()) {
          // This is only supported in a browser.
          _assert$3(persistence !== Persistence.SESSION, auth, "unsupported-persistence-type"
          /* UNSUPPORTED_PERSISTENCE */
          );

          return;
        }

        if ((0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.isNode)()) {
          // Only none is supported in Node.js.
          _assert$3(persistence === Persistence.NONE, auth, "unsupported-persistence-type"
          /* UNSUPPORTED_PERSISTENCE */
          );

          return;
        }

        if (_isWorker()) {
          // In a worker environment, either LOCAL or NONE are supported.
          // If indexedDB not supported and LOCAL provided, throw an error
          _assert$3(persistence === Persistence.NONE || persistence === Persistence.LOCAL && (0, _firebase_util__WEBPACK_IMPORTED_MODULE_3__.isIndexedDBAvailable)(), auth, "unsupported-persistence-type"
          /* UNSUPPORTED_PERSISTENCE */
          );

          return;
        } // This is restricted by what the browser supports.


        _assert$3(persistence === Persistence.NONE || _isWebStorageSupported(), auth, "unsupported-persistence-type"
        /* UNSUPPORTED_PERSISTENCE */
        );
      }

      function _savePersistenceForRedirect(_x) {
        return _savePersistenceForRedirect2.apply(this, arguments);
      }

      function _savePersistenceForRedirect2() {
        _savePersistenceForRedirect2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(auth) {
          var win, key;
          return regeneratorRuntime.wrap(function _callee18$(_context18) {
            while (1) {
              switch (_context18.prev = _context18.next) {
                case 0:
                  _context18.next = 2;
                  return auth._initializationPromise;

                case 2:
                  win = getSelfWindow();
                  key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._persistenceKeyName(PERSISTENCE_KEY, auth.config.apiKey, auth.name);

                  if (win === null || win === void 0 ? void 0 : win.sessionStorage) {
                    win.sessionStorage.setItem(key, auth._getPersistence());
                  }

                case 5:
                case "end":
                  return _context18.stop();
              }
            }
          }, _callee18);
        }));
        return _savePersistenceForRedirect2.apply(this, arguments);
      }

      function _getPersistencesFromRedirect(apiKey, appName) {
        var win = getSelfWindow();

        if (!(win === null || win === void 0 ? void 0 : win.sessionStorage)) {
          return [];
        }

        var key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._persistenceKeyName(PERSISTENCE_KEY, apiKey, appName);

        var persistence = win.sessionStorage.getItem(key);

        switch (persistence) {
          case Persistence.NONE:
            return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.inMemoryPersistence];

          case Persistence.LOCAL:
            return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.indexedDBLocalPersistence, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence];

          case Persistence.SESSION:
            return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence];

          default:
            return [];
        }
      }

      function getSelfWindow() {
        return typeof window !== 'undefined' ? window : null;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var _assert$2 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._assert;
      /** Platform-agnostic popup-redirect resolver */

      var CompatPopupRedirectResolver = /*#__PURE__*/function () {
        function CompatPopupRedirectResolver() {
          _classCallCheck(this, CompatPopupRedirectResolver);

          // Create both resolvers for dynamic resolution later
          this.browserResolver = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._getInstance(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserPopupRedirectResolver);
          this.cordovaResolver = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._getInstance(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.cordovaPopupRedirectResolver); // The actual resolver in use: either browserResolver or cordovaResolver.

          this.underlyingResolver = null;
          this._redirectPersistence = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence;
          this._completeRedirectFn = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._getRedirectResult;
        }

        _createClass(CompatPopupRedirectResolver, [{
          key: "_initialize",
          value: function () {
            var _initialize2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(auth) {
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return this.selectUnderlyingResolver();

                    case 2:
                      return _context.abrupt("return", this.assertedUnderlyingResolver._initialize(auth));

                    case 3:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function _initialize(_x2) {
              return _initialize2.apply(this, arguments);
            }

            return _initialize;
          }()
        }, {
          key: "_openPopup",
          value: function () {
            var _openPopup2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(auth, provider, authType, eventId) {
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return this.selectUnderlyingResolver();

                    case 2:
                      return _context2.abrupt("return", this.assertedUnderlyingResolver._openPopup(auth, provider, authType, eventId));

                    case 3:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function _openPopup(_x3, _x4, _x5, _x6) {
              return _openPopup2.apply(this, arguments);
            }

            return _openPopup;
          }()
        }, {
          key: "_openRedirect",
          value: function () {
            var _openRedirect2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(auth, provider, authType, eventId) {
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return this.selectUnderlyingResolver();

                    case 2:
                      return _context3.abrupt("return", this.assertedUnderlyingResolver._openRedirect(auth, provider, authType, eventId));

                    case 3:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function _openRedirect(_x7, _x8, _x9, _x10) {
              return _openRedirect2.apply(this, arguments);
            }

            return _openRedirect;
          }()
        }, {
          key: "_isIframeWebStorageSupported",
          value: function _isIframeWebStorageSupported(auth, cb) {
            this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth, cb);
          }
        }, {
          key: "_originValidation",
          value: function _originValidation(auth) {
            return this.assertedUnderlyingResolver._originValidation(auth);
          }
        }, {
          key: "_shouldInitProactively",
          get: function get() {
            return _isLikelyCordova() || this.browserResolver._shouldInitProactively;
          }
        }, {
          key: "assertedUnderlyingResolver",
          get: function get() {
            _assert$2(this.underlyingResolver, "internal-error"
            /* INTERNAL_ERROR */
            );

            return this.underlyingResolver;
          }
        }, {
          key: "selectUnderlyingResolver",
          value: function () {
            var _selectUnderlyingResolver = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var isCordova;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (!this.underlyingResolver) {
                        _context4.next = 2;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 2:
                      _context4.next = 4;
                      return _isCordova();

                    case 4:
                      isCordova = _context4.sent;
                      this.underlyingResolver = isCordova ? this.cordovaResolver : this.browserResolver;

                    case 6:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function selectUnderlyingResolver() {
              return _selectUnderlyingResolver.apply(this, arguments);
            }

            return selectUnderlyingResolver;
          }()
        }]);

        return CompatPopupRedirectResolver;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function unwrap(object) {
        return object.unwrap();
      }

      function wrapped(object) {
        return object.wrapped();
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function credentialFromResponse(userCredential) {
        return credentialFromObject(userCredential);
      }

      function attachExtraErrorFields(auth, e) {
        var _a; // The response contains all fields from the server which may or may not
        // actually match the underlying type


        var response = (_a = e.customData) === null || _a === void 0 ? void 0 : _a._tokenResponse;

        if (e.code === 'auth/multi-factor-auth-required') {
          var mfaErr = e;
          mfaErr.resolver = new MultiFactorResolver(auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.getMultiFactorResolver(auth, e));
        } else if (response) {
          var credential = credentialFromObject(e);
          var credErr = e;

          if (credential) {
            credErr.credential = credential;
            credErr.tenantId = response.tenantId || undefined;
            credErr.email = response.email || undefined;
            credErr.phoneNumber = response.phoneNumber || undefined;
          }
        }
      }

      function credentialFromObject(object) {
        var _ref = object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError ? object.customData : object,
            _tokenResponse = _ref._tokenResponse;

        if (!_tokenResponse) {
          return null;
        } // Handle phone Auth credential responses, as they have a different format
        // from other backend responses (i.e. no providerId). This is also only the
        // case for user credentials (does not work for errors).


        if (!(object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError)) {
          if ('temporaryProof' in _tokenResponse && 'phoneNumber' in _tokenResponse) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider.credentialFromResult(object);
          }
        }

        var providerId = _tokenResponse.providerId; // Email and password is not supported as there is no situation where the
        // server would return the password to the client.

        if (!providerId || providerId === _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.PASSWORD) {
          return null;
        }

        var provider;

        switch (providerId) {
          case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.GOOGLE:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.GoogleAuthProvider;
            break;

          case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.FACEBOOK:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.FacebookAuthProvider;
            break;

          case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.GITHUB:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.GithubAuthProvider;
            break;

          case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.TWITTER:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.TwitterAuthProvider;
            break;

          default:
            var oauthIdToken = _tokenResponse.oauthIdToken,
                oauthAccessToken = _tokenResponse.oauthAccessToken,
                oauthTokenSecret = _tokenResponse.oauthTokenSecret,
                pendingToken = _tokenResponse.pendingToken,
                nonce = _tokenResponse.nonce;

            if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {
              return null;
            } // TODO(avolkovi): uncomment this and get it working with SAML & OIDC


            if (pendingToken) {
              if (providerId.startsWith('saml.')) {
                return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.SAMLAuthCredential._create(providerId, pendingToken);
              } else {
                // OIDC and non-default providers excluding Twitter.
                return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.OAuthCredential._fromParams({
                  providerId: providerId,
                  signInMethod: providerId,
                  pendingToken: pendingToken,
                  idToken: oauthIdToken,
                  accessToken: oauthAccessToken
                });
              }
            }

            return new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.OAuthProvider(providerId).credential({
              idToken: oauthIdToken,
              accessToken: oauthAccessToken,
              rawNonce: nonce
            });
        }

        return object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError ? provider.credentialFromError(object) : provider.credentialFromResult(object);
      }

      function convertCredential(auth, credentialPromise) {
        return credentialPromise["catch"](function (e) {
          if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError) {
            attachExtraErrorFields(auth, e);
          }

          throw e;
        }).then(function (credential) {
          var operationType = credential.operationType;
          var user = credential.user;
          return {
            operationType: operationType,
            credential: credentialFromResponse(credential),
            additionalUserInfo: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.getAdditionalUserInfo(credential),
            user: User.getOrCreate(user)
          };
        });
      }

      function convertConfirmationResult(_x11, _x12) {
        return _convertConfirmationResult.apply(this, arguments);
      }

      function _convertConfirmationResult() {
        _convertConfirmationResult = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(auth, confirmationResultPromise) {
          var confirmationResultExp;
          return regeneratorRuntime.wrap(function _callee19$(_context19) {
            while (1) {
              switch (_context19.prev = _context19.next) {
                case 0:
                  _context19.next = 2;
                  return confirmationResultPromise;

                case 2:
                  confirmationResultExp = _context19.sent;
                  return _context19.abrupt("return", {
                    verificationId: confirmationResultExp.verificationId,
                    confirm: function confirm(verificationCode) {
                      return convertCredential(auth, confirmationResultExp.confirm(verificationCode));
                    }
                  });

                case 4:
                case "end":
                  return _context19.stop();
              }
            }
          }, _callee19);
        }));
        return _convertConfirmationResult.apply(this, arguments);
      }

      var MultiFactorResolver = /*#__PURE__*/function () {
        function MultiFactorResolver(auth, resolver) {
          _classCallCheck(this, MultiFactorResolver);

          this.resolver = resolver;
          this.auth = wrapped(auth);
        }

        _createClass(MultiFactorResolver, [{
          key: "session",
          get: function get() {
            return this.resolver.session;
          }
        }, {
          key: "hints",
          get: function get() {
            return this.resolver.hints;
          }
        }, {
          key: "resolveSignIn",
          value: function resolveSignIn(assertion) {
            return convertCredential(unwrap(this.auth), this.resolver.resolveSignIn(assertion));
          }
        }]);

        return MultiFactorResolver;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var User = /*#__PURE__*/function () {
        function User(_delegate) {
          _classCallCheck(this, User);

          this._delegate = _delegate;
          this.multiFactor = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.multiFactor(_delegate);
        }

        _createClass(User, [{
          key: "delete",
          value: function _delete() {
            return this._delegate["delete"]();
          }
        }, {
          key: "reload",
          value: function reload() {
            return this._delegate.reload();
          }
        }, {
          key: "toJSON",
          value: function toJSON() {
            return this._delegate.toJSON();
          }
        }, {
          key: "getIdTokenResult",
          value: function getIdTokenResult(forceRefresh) {
            return this._delegate.getIdTokenResult(forceRefresh);
          }
        }, {
          key: "getIdToken",
          value: function getIdToken(forceRefresh) {
            return this._delegate.getIdToken(forceRefresh);
          }
        }, {
          key: "linkAndRetrieveDataWithCredential",
          value: function linkAndRetrieveDataWithCredential(credential) {
            return this.linkWithCredential(credential);
          }
        }, {
          key: "linkWithCredential",
          value: function () {
            var _linkWithCredential = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(credential) {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      return _context5.abrupt("return", convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.linkWithCredential(this._delegate, credential)));

                    case 1:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function linkWithCredential(_x13) {
              return _linkWithCredential.apply(this, arguments);
            }

            return linkWithCredential;
          }()
        }, {
          key: "linkWithPhoneNumber",
          value: function () {
            var _linkWithPhoneNumber = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(phoneNumber, applicationVerifier) {
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      return _context6.abrupt("return", convertConfirmationResult(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.linkWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier)));

                    case 1:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function linkWithPhoneNumber(_x14, _x15) {
              return _linkWithPhoneNumber.apply(this, arguments);
            }

            return linkWithPhoneNumber;
          }()
        }, {
          key: "linkWithPopup",
          value: function () {
            var _linkWithPopup = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(provider) {
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      return _context7.abrupt("return", convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.linkWithPopup(this._delegate, provider, CompatPopupRedirectResolver)));

                    case 1:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this);
            }));

            function linkWithPopup(_x16) {
              return _linkWithPopup.apply(this, arguments);
            }

            return linkWithPopup;
          }()
        }, {
          key: "linkWithRedirect",
          value: function () {
            var _linkWithRedirect2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(provider) {
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      _context8.next = 2;
                      return _savePersistenceForRedirect(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._castAuth(this.auth));

                    case 2:
                      return _context8.abrupt("return", _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.linkWithRedirect(this._delegate, provider, CompatPopupRedirectResolver));

                    case 3:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function linkWithRedirect(_x17) {
              return _linkWithRedirect2.apply(this, arguments);
            }

            return linkWithRedirect;
          }()
        }, {
          key: "reauthenticateAndRetrieveDataWithCredential",
          value: function reauthenticateAndRetrieveDataWithCredential(credential) {
            return this.reauthenticateWithCredential(credential);
          }
        }, {
          key: "reauthenticateWithCredential",
          value: function () {
            var _reauthenticateWithCredential = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(credential) {
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      return _context9.abrupt("return", convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.reauthenticateWithCredential(this._delegate, credential)));

                    case 1:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function reauthenticateWithCredential(_x18) {
              return _reauthenticateWithCredential.apply(this, arguments);
            }

            return reauthenticateWithCredential;
          }()
        }, {
          key: "reauthenticateWithPhoneNumber",
          value: function reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) {
            return convertConfirmationResult(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.reauthenticateWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
          }
        }, {
          key: "reauthenticateWithPopup",
          value: function reauthenticateWithPopup(provider) {
            return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.reauthenticateWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
          }
        }, {
          key: "reauthenticateWithRedirect",
          value: function () {
            var _reauthenticateWithRedirect2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(provider) {
              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      _context10.next = 2;
                      return _savePersistenceForRedirect(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._castAuth(this.auth));

                    case 2:
                      return _context10.abrupt("return", _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.reauthenticateWithRedirect(this._delegate, provider, CompatPopupRedirectResolver));

                    case 3:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this);
            }));

            function reauthenticateWithRedirect(_x19) {
              return _reauthenticateWithRedirect2.apply(this, arguments);
            }

            return reauthenticateWithRedirect;
          }()
        }, {
          key: "sendEmailVerification",
          value: function sendEmailVerification(actionCodeSettings) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.sendEmailVerification(this._delegate, actionCodeSettings);
          }
        }, {
          key: "unlink",
          value: function () {
            var _unlink = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(providerId) {
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      _context11.next = 2;
                      return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.unlink(this._delegate, providerId);

                    case 2:
                      return _context11.abrupt("return", this);

                    case 3:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function unlink(_x20) {
              return _unlink.apply(this, arguments);
            }

            return unlink;
          }()
        }, {
          key: "updateEmail",
          value: function updateEmail(newEmail) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.updateEmail(this._delegate, newEmail);
          }
        }, {
          key: "updatePassword",
          value: function updatePassword(newPassword) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.updatePassword(this._delegate, newPassword);
          }
        }, {
          key: "updatePhoneNumber",
          value: function updatePhoneNumber(phoneCredential) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.updatePhoneNumber(this._delegate, phoneCredential);
          }
        }, {
          key: "updateProfile",
          value: function updateProfile(profile) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.updateProfile(this._delegate, profile);
          }
        }, {
          key: "verifyBeforeUpdateEmail",
          value: function verifyBeforeUpdateEmail(newEmail, actionCodeSettings) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.verifyBeforeUpdateEmail(this._delegate, newEmail, actionCodeSettings);
          }
        }, {
          key: "emailVerified",
          get: function get() {
            return this._delegate.emailVerified;
          }
        }, {
          key: "isAnonymous",
          get: function get() {
            return this._delegate.isAnonymous;
          }
        }, {
          key: "metadata",
          get: function get() {
            return this._delegate.metadata;
          }
        }, {
          key: "phoneNumber",
          get: function get() {
            return this._delegate.phoneNumber;
          }
        }, {
          key: "providerData",
          get: function get() {
            return this._delegate.providerData;
          }
        }, {
          key: "refreshToken",
          get: function get() {
            return this._delegate.refreshToken;
          }
        }, {
          key: "tenantId",
          get: function get() {
            return this._delegate.tenantId;
          }
        }, {
          key: "displayName",
          get: function get() {
            return this._delegate.displayName;
          }
        }, {
          key: "email",
          get: function get() {
            return this._delegate.email;
          }
        }, {
          key: "photoURL",
          get: function get() {
            return this._delegate.photoURL;
          }
        }, {
          key: "providerId",
          get: function get() {
            return this._delegate.providerId;
          }
        }, {
          key: "uid",
          get: function get() {
            return this._delegate.uid;
          }
        }, {
          key: "auth",
          get: function get() {
            return this._delegate.auth;
          }
        }], [{
          key: "getOrCreate",
          value: function getOrCreate(user) {
            if (!User.USER_MAP.has(user)) {
              User.USER_MAP.set(user, new User(user));
            }

            return User.USER_MAP.get(user);
          }
        }]);

        return User;
      }(); // Maintain a map so that there's always a 1:1 mapping between new User and
      // legacy compat users


      User.USER_MAP = new WeakMap();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      var _assert$1 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._assert;

      var Auth = /*#__PURE__*/function () {
        function Auth(app, provider) {
          _classCallCheck(this, Auth);

          this.app = app;

          if (provider.isInitialized()) {
            this._delegate = provider.getImmediate();
            this.linkUnderlyingAuth();
            return;
          }

          var apiKey = app.options.apiKey; // TODO: platform needs to be determined using heuristics

          _assert$1(apiKey, "invalid-api-key"
          /* INVALID_API_KEY */
          , {
            appName: app.name
          });

          var persistences = [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.inMemoryPersistence]; // Only deal with persistences in web environments

          if (typeof window !== 'undefined') {
            // Note this is slightly different behavior: in this case, the stored
            // persistence is checked *first* rather than last. This is because we want
            // to prefer stored persistence type in the hierarchy.
            persistences = _getPersistencesFromRedirect(apiKey, app.name);

            for (var _i = 0, _arr = [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.indexedDBLocalPersistence, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserLocalPersistence, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence]; _i < _arr.length; _i++) {
              var persistence = _arr[_i];

              if (!persistences.includes(persistence)) {
                persistences.push(persistence);
              }
            }
          } // TODO: platform needs to be determined using heuristics


          _assert$1(apiKey, "invalid-api-key"
          /* INVALID_API_KEY */
          , {
            appName: app.name
          }); // Only use a popup/redirect resolver in browser environments


          var resolver = typeof window !== 'undefined' ? CompatPopupRedirectResolver : undefined;
          this._delegate = provider.initialize({
            options: {
              persistence: persistences,
              popupRedirectResolver: resolver
            }
          });

          this._delegate._updateErrorMap(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.debugErrorMap);

          this.linkUnderlyingAuth();
        }

        _createClass(Auth, [{
          key: "emulatorConfig",
          get: function get() {
            return this._delegate.emulatorConfig;
          }
        }, {
          key: "currentUser",
          get: function get() {
            if (!this._delegate.currentUser) {
              return null;
            }

            return User.getOrCreate(this._delegate.currentUser);
          }
        }, {
          key: "languageCode",
          get: function get() {
            return this._delegate.languageCode;
          },
          set: function set(languageCode) {
            this._delegate.languageCode = languageCode;
          }
        }, {
          key: "settings",
          get: function get() {
            return this._delegate.settings;
          }
        }, {
          key: "tenantId",
          get: function get() {
            return this._delegate.tenantId;
          },
          set: function set(tid) {
            this._delegate.tenantId = tid;
          }
        }, {
          key: "useDeviceLanguage",
          value: function useDeviceLanguage() {
            this._delegate.useDeviceLanguage();
          }
        }, {
          key: "signOut",
          value: function signOut() {
            return this._delegate.signOut();
          }
        }, {
          key: "useEmulator",
          value: function useEmulator(url, options) {
            _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.connectAuthEmulator(this._delegate, url, options);
          }
        }, {
          key: "applyActionCode",
          value: function applyActionCode(code) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.applyActionCode(this._delegate, code);
          }
        }, {
          key: "checkActionCode",
          value: function checkActionCode(code) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.checkActionCode(this._delegate, code);
          }
        }, {
          key: "confirmPasswordReset",
          value: function confirmPasswordReset(code, newPassword) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.confirmPasswordReset(this._delegate, code, newPassword);
          }
        }, {
          key: "createUserWithEmailAndPassword",
          value: function () {
            var _createUserWithEmailAndPassword = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(email, password) {
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      return _context12.abrupt("return", convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.createUserWithEmailAndPassword(this._delegate, email, password)));

                    case 1:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this);
            }));

            function createUserWithEmailAndPassword(_x21, _x22) {
              return _createUserWithEmailAndPassword.apply(this, arguments);
            }

            return createUserWithEmailAndPassword;
          }()
        }, {
          key: "fetchProvidersForEmail",
          value: function fetchProvidersForEmail(email) {
            return this.fetchSignInMethodsForEmail(email);
          }
        }, {
          key: "fetchSignInMethodsForEmail",
          value: function fetchSignInMethodsForEmail(email) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.fetchSignInMethodsForEmail(this._delegate, email);
          }
        }, {
          key: "isSignInWithEmailLink",
          value: function isSignInWithEmailLink(emailLink) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.isSignInWithEmailLink(this._delegate, emailLink);
          }
        }, {
          key: "getRedirectResult",
          value: function () {
            var _getRedirectResult2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
              var credential;
              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment"
                      /* OPERATION_NOT_SUPPORTED */
                      );

                      _context13.next = 3;
                      return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.getRedirectResult(this._delegate, CompatPopupRedirectResolver);

                    case 3:
                      credential = _context13.sent;

                      if (credential) {
                        _context13.next = 6;
                        break;
                      }

                      return _context13.abrupt("return", {
                        credential: null,
                        user: null
                      });

                    case 6:
                      return _context13.abrupt("return", convertCredential(this._delegate, Promise.resolve(credential)));

                    case 7:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13, this);
            }));

            function getRedirectResult() {
              return _getRedirectResult2.apply(this, arguments);
            }

            return getRedirectResult;
          }() // This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
          // It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it
          // out of autogenerated documentation pages to reduce accidental misuse.

        }, {
          key: "addFrameworkForLogging",
          value: function addFrameworkForLogging(framework) {
            _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.addFrameworkForLogging(this._delegate, framework);
          }
        }, {
          key: "onAuthStateChanged",
          value: function onAuthStateChanged(nextOrObserver, errorFn, completed) {
            var _wrapObservers = wrapObservers(nextOrObserver, errorFn, completed),
                next = _wrapObservers.next,
                error = _wrapObservers.error,
                complete = _wrapObservers.complete;

            return this._delegate.onAuthStateChanged(next, error, complete);
          }
        }, {
          key: "onIdTokenChanged",
          value: function onIdTokenChanged(nextOrObserver, errorFn, completed) {
            var _wrapObservers2 = wrapObservers(nextOrObserver, errorFn, completed),
                next = _wrapObservers2.next,
                error = _wrapObservers2.error,
                complete = _wrapObservers2.complete;

            return this._delegate.onIdTokenChanged(next, error, complete);
          }
        }, {
          key: "sendSignInLinkToEmail",
          value: function sendSignInLinkToEmail(email, actionCodeSettings) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.sendSignInLinkToEmail(this._delegate, email, actionCodeSettings);
          }
        }, {
          key: "sendPasswordResetEmail",
          value: function sendPasswordResetEmail(email, actionCodeSettings) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.sendPasswordResetEmail(this._delegate, email, actionCodeSettings || undefined);
          }
        }, {
          key: "setPersistence",
          value: function () {
            var _setPersistence = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(persistence) {
              var converted, isIndexedDBFullySupported;
              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      _validatePersistenceArgument(this._delegate, persistence);

                      _context14.t0 = persistence;
                      _context14.next = _context14.t0 === Persistence.SESSION ? 4 : _context14.t0 === Persistence.LOCAL ? 6 : _context14.t0 === Persistence.NONE ? 11 : 13;
                      break;

                    case 4:
                      converted = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence;
                      return _context14.abrupt("break", 14);

                    case 6:
                      _context14.next = 8;
                      return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._getInstance(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.indexedDBLocalPersistence)._isAvailable();

                    case 8:
                      isIndexedDBFullySupported = _context14.sent;
                      converted = isIndexedDBFullySupported ? _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.indexedDBLocalPersistence : _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserLocalPersistence;
                      return _context14.abrupt("break", 14);

                    case 11:
                      converted = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.inMemoryPersistence;
                      return _context14.abrupt("break", 14);

                    case 13:
                      return _context14.abrupt("return", _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._fail("argument-error"
                      /* ARGUMENT_ERROR */
                      , {
                        appName: this._delegate.name
                      }));

                    case 14:
                      return _context14.abrupt("return", this._delegate.setPersistence(converted));

                    case 15:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14, this);
            }));

            function setPersistence(_x23) {
              return _setPersistence.apply(this, arguments);
            }

            return setPersistence;
          }()
        }, {
          key: "signInAndRetrieveDataWithCredential",
          value: function signInAndRetrieveDataWithCredential(credential) {
            return this.signInWithCredential(credential);
          }
        }, {
          key: "signInAnonymously",
          value: function signInAnonymously() {
            return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInAnonymously(this._delegate));
          }
        }, {
          key: "signInWithCredential",
          value: function signInWithCredential(credential) {
            return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithCredential(this._delegate, credential));
          }
        }, {
          key: "signInWithCustomToken",
          value: function signInWithCustomToken(token) {
            return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithCustomToken(this._delegate, token));
          }
        }, {
          key: "signInWithEmailAndPassword",
          value: function signInWithEmailAndPassword(email, password) {
            return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithEmailAndPassword(this._delegate, email, password));
          }
        }, {
          key: "signInWithEmailLink",
          value: function signInWithEmailLink(email, emailLink) {
            return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithEmailLink(this._delegate, email, emailLink));
          }
        }, {
          key: "signInWithPhoneNumber",
          value: function signInWithPhoneNumber(phoneNumber, applicationVerifier) {
            return convertConfirmationResult(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
          }
        }, {
          key: "signInWithPopup",
          value: function () {
            var _signInWithPopup = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(provider) {
              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment"
                      /* OPERATION_NOT_SUPPORTED */
                      );

                      return _context15.abrupt("return", convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithPopup(this._delegate, provider, CompatPopupRedirectResolver)));

                    case 2:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, this);
            }));

            function signInWithPopup(_x24) {
              return _signInWithPopup.apply(this, arguments);
            }

            return signInWithPopup;
          }()
        }, {
          key: "signInWithRedirect",
          value: function () {
            var _signInWithRedirect2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(provider) {
              return regeneratorRuntime.wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment"
                      /* OPERATION_NOT_SUPPORTED */
                      );

                      _context16.next = 3;
                      return _savePersistenceForRedirect(this._delegate);

                    case 3:
                      return _context16.abrupt("return", _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithRedirect(this._delegate, provider, CompatPopupRedirectResolver));

                    case 4:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16, this);
            }));

            function signInWithRedirect(_x25) {
              return _signInWithRedirect2.apply(this, arguments);
            }

            return signInWithRedirect;
          }()
        }, {
          key: "updateCurrentUser",
          value: function updateCurrentUser(user) {
            // remove ts-ignore once overloads are defined for exp functions to accept compat objects
            // @ts-ignore
            return this._delegate.updateCurrentUser(user);
          }
        }, {
          key: "verifyPasswordResetCode",
          value: function verifyPasswordResetCode(code) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.verifyPasswordResetCode(this._delegate, code);
          }
        }, {
          key: "unwrap",
          value: function unwrap() {
            return this._delegate;
          }
        }, {
          key: "_delete",
          value: function _delete() {
            return this._delegate._delete();
          }
        }, {
          key: "linkUnderlyingAuth",
          value: function linkUnderlyingAuth() {
            var _this = this;

            this._delegate.wrapped = function () {
              return _this;
            };
          }
        }]);

        return Auth;
      }();

      Auth.Persistence = Persistence;

      function wrapObservers(nextOrObserver, error, complete) {
        var next = nextOrObserver;

        if (typeof nextOrObserver !== 'function') {
          next = nextOrObserver.next;
          error = nextOrObserver.error;
          complete = nextOrObserver.complete;
        } // We know 'next' is now a function


        var oldNext = next;

        var newNext = function newNext(user) {
          return oldNext(user && User.getOrCreate(user));
        };

        return {
          next: newNext,
          error: error,
          complete: complete
        };
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var PhoneAuthProvider = /*#__PURE__*/function () {
        function PhoneAuthProvider() {
          _classCallCheck(this, PhoneAuthProvider);

          this.providerId = 'phone'; // TODO: remove ts-ignore when moving types from auth-types to auth-compat
          // @ts-ignore

          this._delegate = new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider(unwrap(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__["default"].auth()));
        }

        _createClass(PhoneAuthProvider, [{
          key: "verifyPhoneNumber",
          value: function verifyPhoneNumber(phoneInfoOptions, applicationVerifier) {
            return this._delegate.verifyPhoneNumber( // The implementation matches but the types are subtly incompatible
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            phoneInfoOptions, applicationVerifier);
          }
        }, {
          key: "unwrap",
          value: function unwrap() {
            return this._delegate;
          }
        }], [{
          key: "credential",
          value: function credential(verificationId, verificationCode) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider.credential(verificationId, verificationCode);
          }
        }]);

        return PhoneAuthProvider;
      }();

      PhoneAuthProvider.PHONE_SIGN_IN_METHOD = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider.PHONE_SIGN_IN_METHOD;
      PhoneAuthProvider.PROVIDER_ID = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider.PROVIDER_ID;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      var _assert = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._assert;

      var RecaptchaVerifier = /*#__PURE__*/function () {
        function RecaptchaVerifier(container, parameters) {
          var app = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__["default"].app();

          _classCallCheck(this, RecaptchaVerifier);

          var _a; // API key is required for web client RPC calls.


          _assert((_a = app.options) === null || _a === void 0 ? void 0 : _a.apiKey, "invalid-api-key"
          /* INVALID_API_KEY */
          , {
            appName: app.name
          });

          this._delegate = new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.RecaptchaVerifier(container, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          parameters, // TODO: remove ts-ignore when moving types from auth-types to auth-compat
          // @ts-ignore
          app.auth());
          this.type = this._delegate.type;
        }

        _createClass(RecaptchaVerifier, [{
          key: "clear",
          value: function clear() {
            this._delegate.clear();
          }
        }, {
          key: "render",
          value: function render() {
            return this._delegate.render();
          }
        }, {
          key: "verify",
          value: function verify() {
            return this._delegate.verify();
          }
        }]);

        return RecaptchaVerifier;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var AUTH_TYPE = 'auth-compat'; // Create auth components to register with firebase.
      // Provides Auth public APIs.

      function registerAuthCompat(instance) {
        instance.INTERNAL.registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(AUTH_TYPE, function (container) {
          // getImmediate for FirebaseApp will always succeed
          var app = container.getProvider('app-compat').getImmediate();
          var authProvider = container.getProvider('auth');
          return new Auth(app, authProvider);
        }, "PUBLIC"
        /* PUBLIC */
        ).setServiceProps({
          ActionCodeInfo: {
            Operation: {
              EMAIL_SIGNIN: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.EMAIL_SIGNIN,
              PASSWORD_RESET: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.PASSWORD_RESET,
              RECOVER_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.RECOVER_EMAIL,
              REVERT_SECOND_FACTOR_ADDITION: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,
              VERIFY_AND_CHANGE_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,
              VERIFY_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.VERIFY_EMAIL
            }
          },
          EmailAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.EmailAuthProvider,
          FacebookAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.FacebookAuthProvider,
          GithubAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.GithubAuthProvider,
          GoogleAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.GoogleAuthProvider,
          OAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.OAuthProvider,
          SAMLAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.SAMLAuthProvider,
          PhoneAuthProvider: PhoneAuthProvider,
          PhoneMultiFactorGenerator: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneMultiFactorGenerator,
          RecaptchaVerifier: RecaptchaVerifier,
          TwitterAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.TwitterAuthProvider,
          Auth: Auth,
          AuthCredential: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.AuthCredential,
          Error: _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError
        }).setInstantiationMode("LAZY"
        /* LAZY */
        ).setMultipleInstances(false));
        instance.registerVersion(name, version);
      }

      registerAuthCompat(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__["default"]); //# sourceMappingURL=index.esm2017.js.map

      /***/
    },

    /***/
    26269:
    /*!********************************************************************!*\
      !*** ./node_modules/@firebase/auth/dist/esm2017/index-91e5512e.js ***!
      \********************************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      var _SERVER_ERROR_MAP;

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "$": function $() {
          return (
            /* binding */
            sendPasswordResetEmail
          );
        },

        /* harmony export */
        "A": function A() {
          return (
            /* binding */
            ActionCodeOperation
          );
        },

        /* harmony export */
        "B": function B() {
          return (
            /* binding */
            prodErrorMap
          );
        },

        /* harmony export */
        "C": function C() {
          return (
            /* binding */
            AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY
          );
        },

        /* harmony export */
        "D": function D() {
          return (
            /* binding */
            initializeAuth
          );
        },

        /* harmony export */
        "E": function E() {
          return (
            /* binding */
            connectAuthEmulator
          );
        },

        /* harmony export */
        "F": function F() {
          return (
            /* binding */
            FactorId
          );
        },

        /* harmony export */
        "G": function G() {
          return (
            /* binding */
            AuthCredential
          );
        },

        /* harmony export */
        "H": function H() {
          return (
            /* binding */
            EmailAuthCredential
          );
        },

        /* harmony export */
        "I": function I() {
          return (
            /* binding */
            OAuthCredential
          );
        },

        /* harmony export */
        "J": function J() {
          return (
            /* binding */
            PhoneAuthCredential
          );
        },

        /* harmony export */
        "K": function K() {
          return (
            /* binding */
            inMemoryPersistence
          );
        },

        /* harmony export */
        "L": function L() {
          return (
            /* binding */
            EmailAuthProvider
          );
        },

        /* harmony export */
        "M": function M() {
          return (
            /* binding */
            FacebookAuthProvider
          );
        },

        /* harmony export */
        "N": function N() {
          return (
            /* binding */
            GoogleAuthProvider
          );
        },

        /* harmony export */
        "O": function O() {
          return (
            /* binding */
            OperationType
          );
        },

        /* harmony export */
        "P": function P() {
          return (
            /* binding */
            PhoneAuthProvider
          );
        },

        /* harmony export */
        "Q": function Q() {
          return (
            /* binding */
            GithubAuthProvider
          );
        },

        /* harmony export */
        "R": function R() {
          return (
            /* binding */
            RecaptchaVerifier
          );
        },

        /* harmony export */
        "S": function S() {
          return (
            /* binding */
            SignInMethod
          );
        },

        /* harmony export */
        "T": function T() {
          return (
            /* binding */
            OAuthProvider
          );
        },

        /* harmony export */
        "U": function U() {
          return (
            /* binding */
            SAMLAuthProvider
          );
        },

        /* harmony export */
        "V": function V() {
          return (
            /* binding */
            TwitterAuthProvider
          );
        },

        /* harmony export */
        "W": function W() {
          return (
            /* binding */
            signInAnonymously
          );
        },

        /* harmony export */
        "X": function X() {
          return (
            /* binding */
            signInWithCredential
          );
        },

        /* harmony export */
        "Y": function Y() {
          return (
            /* binding */
            linkWithCredential
          );
        },

        /* harmony export */
        "Z": function Z() {
          return (
            /* binding */
            reauthenticateWithCredential
          );
        },

        /* harmony export */
        "_": function _() {
          return (
            /* binding */
            signInWithCustomToken
          );
        },

        /* harmony export */
        "a": function a() {
          return (
            /* binding */
            browserSessionPersistence
          );
        },

        /* harmony export */
        "a0": function a0() {
          return (
            /* binding */
            confirmPasswordReset
          );
        },

        /* harmony export */
        "a1": function a1() {
          return (
            /* binding */
            applyActionCode
          );
        },

        /* harmony export */
        "a2": function a2() {
          return (
            /* binding */
            checkActionCode
          );
        },

        /* harmony export */
        "a3": function a3() {
          return (
            /* binding */
            verifyPasswordResetCode
          );
        },

        /* harmony export */
        "a4": function a4() {
          return (
            /* binding */
            createUserWithEmailAndPassword
          );
        },

        /* harmony export */
        "a5": function a5() {
          return (
            /* binding */
            signInWithEmailAndPassword
          );
        },

        /* harmony export */
        "a6": function a6() {
          return (
            /* binding */
            sendSignInLinkToEmail
          );
        },

        /* harmony export */
        "a7": function a7() {
          return (
            /* binding */
            isSignInWithEmailLink
          );
        },

        /* harmony export */
        "a8": function a8() {
          return (
            /* binding */
            signInWithEmailLink
          );
        },

        /* harmony export */
        "a9": function a9() {
          return (
            /* binding */
            fetchSignInMethodsForEmail
          );
        },

        /* harmony export */
        "aA": function aA() {
          return (
            /* binding */
            _getRedirectResult
          );
        },

        /* harmony export */
        "aB": function aB() {
          return (
            /* binding */
            _clearRedirectOutcomes
          );
        },

        /* harmony export */
        "aC": function aC() {
          return (
            /* binding */
            _castAuth
          );
        },

        /* harmony export */
        "aD": function aD() {
          return (
            /* binding */
            UserImpl
          );
        },

        /* harmony export */
        "aE": function aE() {
          return (
            /* binding */
            AuthImpl
          );
        },

        /* harmony export */
        "aF": function aF() {
          return (
            /* binding */
            _getClientVersion
          );
        },

        /* harmony export */
        "aG": function aG() {
          return (
            /* binding */
            _generateEventId
          );
        },

        /* harmony export */
        "aH": function aH() {
          return (
            /* binding */
            AuthPopup
          );
        },

        /* harmony export */
        "aI": function aI() {
          return (
            /* binding */
            FetchProvider
          );
        },

        /* harmony export */
        "aJ": function aJ() {
          return (
            /* binding */
            SAMLAuthCredential
          );
        },

        /* harmony export */
        "aa": function aa() {
          return (
            /* binding */
            sendEmailVerification
          );
        },

        /* harmony export */
        "ab": function ab() {
          return (
            /* binding */
            verifyBeforeUpdateEmail
          );
        },

        /* harmony export */
        "ac": function ac() {
          return (
            /* binding */
            ActionCodeURL
          );
        },

        /* harmony export */
        "ad": function ad() {
          return (
            /* binding */
            parseActionCodeURL
          );
        },

        /* harmony export */
        "ae": function ae() {
          return (
            /* binding */
            updateProfile
          );
        },

        /* harmony export */
        "af": function af() {
          return (
            /* binding */
            updateEmail
          );
        },

        /* harmony export */
        "ag": function ag() {
          return (
            /* binding */
            updatePassword
          );
        },

        /* harmony export */
        "ah": function ah() {
          return (
            /* binding */
            getIdToken
          );
        },

        /* harmony export */
        "ai": function ai() {
          return (
            /* binding */
            _getIdTokenResult2
          );
        },

        /* harmony export */
        "aj": function aj() {
          return (
            /* binding */
            unlink
          );
        },

        /* harmony export */
        "ak": function ak() {
          return (
            /* binding */
            getAdditionalUserInfo
          );
        },

        /* harmony export */
        "al": function al() {
          return (
            /* binding */
            _reload2
          );
        },

        /* harmony export */
        "am": function am() {
          return (
            /* binding */
            getMultiFactorResolver
          );
        },

        /* harmony export */
        "an": function an() {
          return (
            /* binding */
            multiFactor
          );
        },

        /* harmony export */
        "ao": function ao() {
          return (
            /* binding */
            _isIOS7Or8
          );
        },

        /* harmony export */
        "ap": function ap() {
          return (
            /* binding */
            debugAssert
          );
        },

        /* harmony export */
        "aq": function aq() {
          return (
            /* binding */
            _isIOS
          );
        },

        /* harmony export */
        "ar": function ar() {
          return (
            /* binding */
            _isAndroid
          );
        },

        /* harmony export */
        "as": function as() {
          return (
            /* binding */
            _fail
          );
        },

        /* harmony export */
        "at": function at() {
          return (
            /* binding */
            _getRedirectUrl
          );
        },

        /* harmony export */
        "au": function au() {
          return (
            /* binding */
            _getProjectConfig
          );
        },

        /* harmony export */
        "av": function av() {
          return (
            /* binding */
            _createError
          );
        },

        /* harmony export */
        "aw": function aw() {
          return (
            /* binding */
            _assert
          );
        },

        /* harmony export */
        "ax": function ax() {
          return (
            /* binding */
            _getInstance
          );
        },

        /* harmony export */
        "ay": function ay() {
          return (
            /* binding */
            _persistenceKeyName
          );
        },

        /* harmony export */
        "az": function az() {
          return (
            /* binding */
            AuthEventManager
          );
        },

        /* harmony export */
        "b": function b() {
          return (
            /* binding */
            browserLocalPersistence
          );
        },

        /* harmony export */
        "c": function c() {
          return (
            /* binding */
            signInWithPopup
          );
        },

        /* harmony export */
        "d": function d() {
          return (
            /* binding */
            linkWithPopup
          );
        },

        /* harmony export */
        "e": function e() {
          return (
            /* binding */
            reauthenticateWithPopup
          );
        },

        /* harmony export */
        "f": function f() {
          return (
            /* binding */
            signInWithRedirect
          );
        },

        /* harmony export */
        "g": function g() {
          return (
            /* binding */
            linkWithRedirect
          );
        },

        /* harmony export */
        "h": function h() {
          return (
            /* binding */
            reauthenticateWithRedirect
          );
        },

        /* harmony export */
        "i": function i() {
          return (
            /* binding */
            indexedDBLocalPersistence
          );
        },

        /* harmony export */
        "j": function j() {
          return (
            /* binding */
            getRedirectResult
          );
        },

        /* harmony export */
        "k": function k() {
          return (
            /* binding */
            browserPopupRedirectResolver
          );
        },

        /* harmony export */
        "l": function l() {
          return (
            /* binding */
            linkWithPhoneNumber
          );
        },

        /* harmony export */
        "m": function m() {
          return (
            /* binding */
            PhoneMultiFactorGenerator
          );
        },

        /* harmony export */
        "n": function n() {
          return (
            /* binding */
            getAuth
          );
        },

        /* harmony export */
        "o": function o() {
          return (
            /* binding */
            ProviderId
          );
        },

        /* harmony export */
        "p": function p() {
          return (
            /* binding */
            setPersistence
          );
        },

        /* harmony export */
        "q": function q() {
          return (
            /* binding */
            onIdTokenChanged
          );
        },

        /* harmony export */
        "r": function r() {
          return (
            /* binding */
            reauthenticateWithPhoneNumber
          );
        },

        /* harmony export */
        "s": function s() {
          return (
            /* binding */
            signInWithPhoneNumber
          );
        },

        /* harmony export */
        "t": function t() {
          return (
            /* binding */
            onAuthStateChanged
          );
        },

        /* harmony export */
        "u": function u() {
          return (
            /* binding */
            updatePhoneNumber
          );
        },

        /* harmony export */
        "v": function v() {
          return (
            /* binding */
            useDeviceLanguage
          );
        },

        /* harmony export */
        "w": function w() {
          return (
            /* binding */
            updateCurrentUser
          );
        },

        /* harmony export */
        "x": function x() {
          return (
            /* binding */
            signOut
          );
        },

        /* harmony export */
        "y": function y() {
          return (
            /* binding */
            deleteUser
          );
        },

        /* harmony export */
        "z": function z() {
          return (
            /* binding */
            debugErrorMap
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @firebase/util */
      29870);
      /* harmony import */


      var _firebase_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @firebase/app */
      95871);
      /* harmony import */


      var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! tslib */
      61855);
      /* harmony import */


      var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @firebase/logger */
      24560);
      /* harmony import */


      var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @firebase/component */
      29171);
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * An enum of factors that may be used for multifactor authentication.
       *
       * @public
       */


      var FactorId = {
        /** Phone as second factor */
        PHONE: 'phone'
      };
      /**
       * Enumeration of supported providers.
       *
       * @public
       */

      var ProviderId = {
        /** Facebook provider ID */
        FACEBOOK: 'facebook.com',

        /** GitHub provider ID */
        GITHUB: 'github.com',

        /** Google provider ID */
        GOOGLE: 'google.com',

        /** Password provider */
        PASSWORD: 'password',

        /** Phone provider */
        PHONE: 'phone',

        /** Twitter provider ID */
        TWITTER: 'twitter.com'
      };
      /**
       * Enumeration of supported sign-in methods.
       *
       * @public
       */

      var SignInMethod = {
        /** Email link sign in method */
        EMAIL_LINK: 'emailLink',

        /** Email/password sign in method */
        EMAIL_PASSWORD: 'password',

        /** Facebook sign in method */
        FACEBOOK: 'facebook.com',

        /** GitHub sign in method */
        GITHUB: 'github.com',

        /** Google sign in method */
        GOOGLE: 'google.com',

        /** Phone sign in method */
        PHONE: 'phone',

        /** Twitter sign in method */
        TWITTER: 'twitter.com'
      };
      /**
       * Enumeration of supported operation types.
       *
       * @public
       */

      var OperationType = {
        /** Operation involving linking an additional provider to an already signed-in user. */
        LINK: 'link',

        /** Operation involving using a provider to reauthenticate an already signed-in user. */
        REAUTHENTICATE: 'reauthenticate',

        /** Operation involving signing in a user. */
        SIGN_IN: 'signIn'
      };
      /**
       * An enumeration of the possible email action types.
       *
       * @public
       */

      var ActionCodeOperation = {
        /** The email link sign-in action. */
        EMAIL_SIGNIN: 'EMAIL_SIGNIN',

        /** The password reset action. */
        PASSWORD_RESET: 'PASSWORD_RESET',

        /** The email revocation action. */
        RECOVER_EMAIL: 'RECOVER_EMAIL',

        /** The revert second factor addition email action. */
        REVERT_SECOND_FACTOR_ADDITION: 'REVERT_SECOND_FACTOR_ADDITION',

        /** The revert second factor addition email action. */
        VERIFY_AND_CHANGE_EMAIL: 'VERIFY_AND_CHANGE_EMAIL',

        /** The email verification action. */
        VERIFY_EMAIL: 'VERIFY_EMAIL'
      };
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      function _debugErrorMap() {
        var _ref2;

        return _ref2 = {}, _defineProperty(_ref2, "admin-restricted-operation"
        /* ADMIN_ONLY_OPERATION */
        , 'This operation is restricted to administrators only.'), _defineProperty(_ref2, "argument-error"
        /* ARGUMENT_ERROR */
        , ''), _defineProperty(_ref2, "app-not-authorized"
        /* APP_NOT_AUTHORIZED */
        , "This app, identified by the domain where it's hosted, is not " + 'authorized to use Firebase Authentication with the provided API key. ' + 'Review your key configuration in the Google API console.'), _defineProperty(_ref2, "app-not-installed"
        /* APP_NOT_INSTALLED */
        , 'The requested mobile application corresponding to the identifier (' + 'Android package name or iOS bundle ID) provided is not installed on ' + 'this device.'), _defineProperty(_ref2, "captcha-check-failed"
        /* CAPTCHA_CHECK_FAILED */
        , 'The reCAPTCHA response token provided is either invalid, expired, ' + 'already used or the domain associated with it does not match the list ' + 'of whitelisted domains.'), _defineProperty(_ref2, "code-expired"
        /* CODE_EXPIRED */
        , 'The SMS code has expired. Please re-send the verification code to try ' + 'again.'), _defineProperty(_ref2, "cordova-not-ready"
        /* CORDOVA_NOT_READY */
        , 'Cordova framework is not ready.'), _defineProperty(_ref2, "cors-unsupported"
        /* CORS_UNSUPPORTED */
        , 'This browser is not supported.'), _defineProperty(_ref2, "credential-already-in-use"
        /* CREDENTIAL_ALREADY_IN_USE */
        , 'This credential is already associated with a different user account.'), _defineProperty(_ref2, "custom-token-mismatch"
        /* CREDENTIAL_MISMATCH */
        , 'The custom token corresponds to a different audience.'), _defineProperty(_ref2, "requires-recent-login"
        /* CREDENTIAL_TOO_OLD_LOGIN_AGAIN */
        , 'This operation is sensitive and requires recent authentication. Log in ' + 'again before retrying this request.'), _defineProperty(_ref2, "dependent-sdk-initialized-before-auth"
        /* DEPENDENT_SDK_INIT_BEFORE_AUTH */
        , 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' + 'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' + 'starting any other Firebase SDK.'), _defineProperty(_ref2, "dynamic-link-not-activated"
        /* DYNAMIC_LINK_NOT_ACTIVATED */
        , 'Please activate Dynamic Links in the Firebase Console and agree to the terms and ' + 'conditions.'), _defineProperty(_ref2, "email-change-needs-verification"
        /* EMAIL_CHANGE_NEEDS_VERIFICATION */
        , 'Multi-factor users must always have a verified email.'), _defineProperty(_ref2, "email-already-in-use"
        /* EMAIL_EXISTS */
        , 'The email address is already in use by another account.'), _defineProperty(_ref2, "emulator-config-failed"
        /* EMULATOR_CONFIG_FAILED */
        , 'Auth instance has already been used to make a network call. Auth can ' + 'no longer be configured to use the emulator. Try calling ' + '"connectAuthEmulator()" sooner.'), _defineProperty(_ref2, "expired-action-code"
        /* EXPIRED_OOB_CODE */
        , 'The action code has expired.'), _defineProperty(_ref2, "cancelled-popup-request"
        /* EXPIRED_POPUP_REQUEST */
        , 'This operation has been cancelled due to another conflicting popup being opened.'), _defineProperty(_ref2, "internal-error"
        /* INTERNAL_ERROR */
        , 'An internal AuthError has occurred.'), _defineProperty(_ref2, "invalid-app-credential"
        /* INVALID_APP_CREDENTIAL */
        , 'The phone verification request contains an invalid application verifier.' + ' The reCAPTCHA token response is either invalid or expired.'), _defineProperty(_ref2, "invalid-app-id"
        /* INVALID_APP_ID */
        , 'The mobile app identifier is not registed for the current project.'), _defineProperty(_ref2, "invalid-user-token"
        /* INVALID_AUTH */
        , "This user's credential isn't valid for this project. This can happen " + "if the user's token has been tampered with, or if the user isn't for " + 'the project associated with this API key.'), _defineProperty(_ref2, "invalid-auth-event"
        /* INVALID_AUTH_EVENT */
        , 'An internal AuthError has occurred.'), _defineProperty(_ref2, "invalid-verification-code"
        /* INVALID_CODE */
        , 'The SMS verification code used to create the phone auth credential is ' + 'invalid. Please resend the verification code sms and be sure to use the ' + 'verification code provided by the user.'), _defineProperty(_ref2, "invalid-continue-uri"
        /* INVALID_CONTINUE_URI */
        , 'The continue URL provided in the request is invalid.'), _defineProperty(_ref2, "invalid-cordova-configuration"
        /* INVALID_CORDOVA_CONFIGURATION */
        , 'The following Cordova plugins must be installed to enable OAuth sign-in: ' + 'cordova-plugin-buildinfo, cordova-universal-links-plugin, ' + 'cordova-plugin-browsertab, cordova-plugin-inappbrowser and ' + 'cordova-plugin-customurlscheme.'), _defineProperty(_ref2, "invalid-custom-token"
        /* INVALID_CUSTOM_TOKEN */
        , 'The custom token format is incorrect. Please check the documentation.'), _defineProperty(_ref2, "invalid-dynamic-link-domain"
        /* INVALID_DYNAMIC_LINK_DOMAIN */
        , 'The provided dynamic link domain is not configured or authorized for the current project.'), _defineProperty(_ref2, "invalid-email"
        /* INVALID_EMAIL */
        , 'The email address is badly formatted.'), _defineProperty(_ref2, "invalid-emulator-scheme"
        /* INVALID_EMULATOR_SCHEME */
        , 'Emulator URL must start with a valid scheme (http:// or https://).'), _defineProperty(_ref2, "invalid-api-key"
        /* INVALID_API_KEY */
        , 'Your API key is invalid, please check you have copied it correctly.'), _defineProperty(_ref2, "invalid-cert-hash"
        /* INVALID_CERT_HASH */
        , 'The SHA-1 certificate hash provided is invalid.'), _defineProperty(_ref2, "invalid-credential"
        /* INVALID_IDP_RESPONSE */
        , 'The supplied auth credential is malformed or has expired.'), _defineProperty(_ref2, "invalid-message-payload"
        /* INVALID_MESSAGE_PAYLOAD */
        , 'The email template corresponding to this action contains invalid characters in its message. ' + 'Please fix by going to the Auth email templates section in the Firebase Console.'), _defineProperty(_ref2, "invalid-multi-factor-session"
        /* INVALID_MFA_SESSION */
        , 'The request does not contain a valid proof of first factor successful sign-in.'), _defineProperty(_ref2, "invalid-oauth-provider"
        /* INVALID_OAUTH_PROVIDER */
        , 'EmailAuthProvider is not supported for this operation. This operation ' + 'only supports OAuth providers.'), _defineProperty(_ref2, "invalid-oauth-client-id"
        /* INVALID_OAUTH_CLIENT_ID */
        , 'The OAuth client ID provided is either invalid or does not match the ' + 'specified API key.'), _defineProperty(_ref2, "unauthorized-domain"
        /* INVALID_ORIGIN */
        , 'This domain is not authorized for OAuth operations for your Firebase ' + 'project. Edit the list of authorized domains from the Firebase console.'), _defineProperty(_ref2, "invalid-action-code"
        /* INVALID_OOB_CODE */
        , 'The action code is invalid. This can happen if the code is malformed, ' + 'expired, or has already been used.'), _defineProperty(_ref2, "wrong-password"
        /* INVALID_PASSWORD */
        , 'The password is invalid or the user does not have a password.'), _defineProperty(_ref2, "invalid-persistence-type"
        /* INVALID_PERSISTENCE */
        , 'The specified persistence type is invalid. It can only be local, session or none.'), _defineProperty(_ref2, "invalid-phone-number"
        /* INVALID_PHONE_NUMBER */
        , 'The format of the phone number provided is incorrect. Please enter the ' + 'phone number in a format that can be parsed into E.164 format. E.164 ' + 'phone numbers are written in the format [+][country code][subscriber ' + 'number including area code].'), _defineProperty(_ref2, "invalid-provider-id"
        /* INVALID_PROVIDER_ID */
        , 'The specified provider ID is invalid.'), _defineProperty(_ref2, "invalid-recipient-email"
        /* INVALID_RECIPIENT_EMAIL */
        , 'The email corresponding to this action failed to send as the provided ' + 'recipient email address is invalid.'), _defineProperty(_ref2, "invalid-sender"
        /* INVALID_SENDER */
        , 'The email template corresponding to this action contains an invalid sender email or name. ' + 'Please fix by going to the Auth email templates section in the Firebase Console.'), _defineProperty(_ref2, "invalid-verification-id"
        /* INVALID_SESSION_INFO */
        , 'The verification ID used to create the phone auth credential is invalid.'), _defineProperty(_ref2, "invalid-tenant-id"
        /* INVALID_TENANT_ID */
        , "The Auth instance's tenant ID is invalid."), _defineProperty(_ref2, "missing-android-pkg-name"
        /* MISSING_ANDROID_PACKAGE_NAME */
        , 'An Android Package Name must be provided if the Android App is required to be installed.'), _defineProperty(_ref2, "auth-domain-config-required"
        /* MISSING_AUTH_DOMAIN */
        , 'Be sure to include authDomain when calling firebase.initializeApp(), ' + 'by following the instructions in the Firebase console.'), _defineProperty(_ref2, "missing-app-credential"
        /* MISSING_APP_CREDENTIAL */
        , 'The phone verification request is missing an application verifier ' + 'assertion. A reCAPTCHA response token needs to be provided.'), _defineProperty(_ref2, "missing-verification-code"
        /* MISSING_CODE */
        , 'The phone auth credential was created with an empty SMS verification code.'), _defineProperty(_ref2, "missing-continue-uri"
        /* MISSING_CONTINUE_URI */
        , 'A continue URL must be provided in the request.'), _defineProperty(_ref2, "missing-iframe-start"
        /* MISSING_IFRAME_START */
        , 'An internal AuthError has occurred.'), _defineProperty(_ref2, "missing-ios-bundle-id"
        /* MISSING_IOS_BUNDLE_ID */
        , 'An iOS Bundle ID must be provided if an App Store ID is provided.'), _defineProperty(_ref2, "missing-or-invalid-nonce"
        /* MISSING_OR_INVALID_NONCE */
        , 'The request does not contain a valid nonce. This can occur if the ' + 'SHA-256 hash of the provided raw nonce does not match the hashed nonce ' + 'in the ID token payload.'), _defineProperty(_ref2, "missing-multi-factor-info"
        /* MISSING_MFA_INFO */
        , 'No second factor identifier is provided.'), _defineProperty(_ref2, "missing-multi-factor-session"
        /* MISSING_MFA_SESSION */
        , 'The request is missing proof of first factor successful sign-in.'), _defineProperty(_ref2, "missing-phone-number"
        /* MISSING_PHONE_NUMBER */
        , 'To send verification codes, provide a phone number for the recipient.'), _defineProperty(_ref2, "missing-verification-id"
        /* MISSING_SESSION_INFO */
        , 'The phone auth credential was created with an empty verification ID.'), _defineProperty(_ref2, "app-deleted"
        /* MODULE_DESTROYED */
        , 'This instance of FirebaseApp has been deleted.'), _defineProperty(_ref2, "multi-factor-info-not-found"
        /* MFA_INFO_NOT_FOUND */
        , 'The user does not have a second factor matching the identifier provided.'), _defineProperty(_ref2, "multi-factor-auth-required"
        /* MFA_REQUIRED */
        , 'Proof of ownership of a second factor is required to complete sign-in.'), _defineProperty(_ref2, "account-exists-with-different-credential"
        /* NEED_CONFIRMATION */
        , 'An account already exists with the same email address but different ' + 'sign-in credentials. Sign in using a provider associated with this ' + 'email address.'), _defineProperty(_ref2, "network-request-failed"
        /* NETWORK_REQUEST_FAILED */
        , 'A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.'), _defineProperty(_ref2, "no-auth-event"
        /* NO_AUTH_EVENT */
        , 'An internal AuthError has occurred.'), _defineProperty(_ref2, "no-such-provider"
        /* NO_SUCH_PROVIDER */
        , 'User was not linked to an account with the given provider.'), _defineProperty(_ref2, "null-user"
        /* NULL_USER */
        , 'A null user object was provided as the argument for an operation which ' + 'requires a non-null user object.'), _defineProperty(_ref2, "operation-not-allowed"
        /* OPERATION_NOT_ALLOWED */
        , 'The given sign-in provider is disabled for this Firebase project. ' + 'Enable it in the Firebase console, under the sign-in method tab of the ' + 'Auth section.'), _defineProperty(_ref2, "operation-not-supported-in-this-environment"
        /* OPERATION_NOT_SUPPORTED */
        , 'This operation is not supported in the environment this application is ' + 'running on. "location.protocol" must be http, https or chrome-extension' + ' and web storage must be enabled.'), _defineProperty(_ref2, "popup-blocked"
        /* POPUP_BLOCKED */
        , 'Unable to establish a connection with the popup. It may have been blocked by the browser.'), _defineProperty(_ref2, "popup-closed-by-user"
        /* POPUP_CLOSED_BY_USER */
        , 'The popup has been closed by the user before finalizing the operation.'), _defineProperty(_ref2, "provider-already-linked"
        /* PROVIDER_ALREADY_LINKED */
        , 'User can only be linked to one identity for the given provider.'), _defineProperty(_ref2, "quota-exceeded"
        /* QUOTA_EXCEEDED */
        , "The project's quota for this operation has been exceeded."), _defineProperty(_ref2, "redirect-cancelled-by-user"
        /* REDIRECT_CANCELLED_BY_USER */
        , 'The redirect operation has been cancelled by the user before finalizing.'), _defineProperty(_ref2, "redirect-operation-pending"
        /* REDIRECT_OPERATION_PENDING */
        , 'A redirect sign-in operation is already pending.'), _defineProperty(_ref2, "rejected-credential"
        /* REJECTED_CREDENTIAL */
        , 'The request contains malformed or mismatching credentials.'), _defineProperty(_ref2, "second-factor-already-in-use"
        /* SECOND_FACTOR_ALREADY_ENROLLED */
        , 'The second factor is already enrolled on this account.'), _defineProperty(_ref2, "maximum-second-factor-count-exceeded"
        /* SECOND_FACTOR_LIMIT_EXCEEDED */
        , 'The maximum allowed number of second factors on a user has been exceeded.'), _defineProperty(_ref2, "tenant-id-mismatch"
        /* TENANT_ID_MISMATCH */
        , "The provided tenant ID does not match the Auth instance's tenant ID"), _defineProperty(_ref2, "timeout"
        /* TIMEOUT */
        , 'The operation has timed out.'), _defineProperty(_ref2, "user-token-expired"
        /* TOKEN_EXPIRED */
        , "The user's credential is no longer valid. The user must sign in again."), _defineProperty(_ref2, "too-many-requests"
        /* TOO_MANY_ATTEMPTS_TRY_LATER */
        , 'We have blocked all requests from this device due to unusual activity. ' + 'Try again later.'), _defineProperty(_ref2, "unauthorized-continue-uri"
        /* UNAUTHORIZED_DOMAIN */
        , 'The domain of the continue URL is not whitelisted.  Please whitelist ' + 'the domain in the Firebase console.'), _defineProperty(_ref2, "unsupported-first-factor"
        /* UNSUPPORTED_FIRST_FACTOR */
        , 'Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.'), _defineProperty(_ref2, "unsupported-persistence-type"
        /* UNSUPPORTED_PERSISTENCE */
        , 'The current environment does not support the specified persistence type.'), _defineProperty(_ref2, "unsupported-tenant-operation"
        /* UNSUPPORTED_TENANT_OPERATION */
        , 'This operation is not supported in a multi-tenant context.'), _defineProperty(_ref2, "unverified-email"
        /* UNVERIFIED_EMAIL */
        , 'The operation requires a verified email.'), _defineProperty(_ref2, "user-cancelled"
        /* USER_CANCELLED */
        , 'The user did not grant your application the permissions it requested.'), _defineProperty(_ref2, "user-not-found"
        /* USER_DELETED */
        , 'There is no user record corresponding to this identifier. The user may ' + 'have been deleted.'), _defineProperty(_ref2, "user-disabled"
        /* USER_DISABLED */
        , 'The user account has been disabled by an administrator.'), _defineProperty(_ref2, "user-mismatch"
        /* USER_MISMATCH */
        , 'The supplied credentials do not correspond to the previously signed in user.'), _defineProperty(_ref2, "user-signed-out"
        /* USER_SIGNED_OUT */
        , ''), _defineProperty(_ref2, "weak-password"
        /* WEAK_PASSWORD */
        , 'The password must be 6 characters long or more.'), _defineProperty(_ref2, "web-storage-unsupported"
        /* WEB_STORAGE_UNSUPPORTED */
        , 'This browser is not supported or 3rd party cookies and data may be disabled.'), _defineProperty(_ref2, "already-initialized"
        /* ALREADY_INITIALIZED */
        , 'initializeAuth() has already been called with ' + 'different options. To avoid this error, call initializeAuth() with the ' + 'same options as when it was originally called, or call getAuth() to return the' + ' already initialized instance.'), _ref2;
      }

      function _prodErrorMap() {
        // We will include this one message in the prod error map since by the very
        // nature of this error, developers will never be able to see the message
        // using the debugErrorMap (which is installed during auth initialization).
        return _defineProperty({}, "dependent-sdk-initialized-before-auth"
        /* DEPENDENT_SDK_INIT_BEFORE_AUTH */
        , 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' + 'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' + 'starting any other Firebase SDK.');
      }
      /**
       * A verbose error map with detailed descriptions for most error codes.
       *
       * See discussion at {@link AuthErrorMap}
       *
       * @public
       */


      var debugErrorMap = _debugErrorMap;
      /**
       * A minimal error map with all verbose error messages stripped.
       *
       * See discussion at {@link AuthErrorMap}
       *
       * @public
       */

      var prodErrorMap = _prodErrorMap;

      var _DEFAULT_AUTH_ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.ErrorFactory('auth', 'Firebase', _prodErrorMap());
      /**
       * A map of potential `Auth` error codes, for easier comparison with errors
       * thrown by the SDK.
       *
       * @remarks
       * Note that you can't tree-shake individual keys
       * in the map, so by using the map you might substantially increase your
       * bundle size.
       *
       * @public
       */


      var AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {
        ADMIN_ONLY_OPERATION: 'auth/admin-restricted-operation',
        ARGUMENT_ERROR: 'auth/argument-error',
        APP_NOT_AUTHORIZED: 'auth/app-not-authorized',
        APP_NOT_INSTALLED: 'auth/app-not-installed',
        CAPTCHA_CHECK_FAILED: 'auth/captcha-check-failed',
        CODE_EXPIRED: 'auth/code-expired',
        CORDOVA_NOT_READY: 'auth/cordova-not-ready',
        CORS_UNSUPPORTED: 'auth/cors-unsupported',
        CREDENTIAL_ALREADY_IN_USE: 'auth/credential-already-in-use',
        CREDENTIAL_MISMATCH: 'auth/custom-token-mismatch',
        CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'auth/requires-recent-login',
        DEPENDENT_SDK_INIT_BEFORE_AUTH: 'auth/dependent-sdk-initialized-before-auth',
        DYNAMIC_LINK_NOT_ACTIVATED: 'auth/dynamic-link-not-activated',
        EMAIL_CHANGE_NEEDS_VERIFICATION: 'auth/email-change-needs-verification',
        EMAIL_EXISTS: 'auth/email-already-in-use',
        EMULATOR_CONFIG_FAILED: 'auth/emulator-config-failed',
        EXPIRED_OOB_CODE: 'auth/expired-action-code',
        EXPIRED_POPUP_REQUEST: 'auth/cancelled-popup-request',
        INTERNAL_ERROR: 'auth/internal-error',
        INVALID_API_KEY: 'auth/invalid-api-key',
        INVALID_APP_CREDENTIAL: 'auth/invalid-app-credential',
        INVALID_APP_ID: 'auth/invalid-app-id',
        INVALID_AUTH: 'auth/invalid-user-token',
        INVALID_AUTH_EVENT: 'auth/invalid-auth-event',
        INVALID_CERT_HASH: 'auth/invalid-cert-hash',
        INVALID_CODE: 'auth/invalid-verification-code',
        INVALID_CONTINUE_URI: 'auth/invalid-continue-uri',
        INVALID_CORDOVA_CONFIGURATION: 'auth/invalid-cordova-configuration',
        INVALID_CUSTOM_TOKEN: 'auth/invalid-custom-token',
        INVALID_DYNAMIC_LINK_DOMAIN: 'auth/invalid-dynamic-link-domain',
        INVALID_EMAIL: 'auth/invalid-email',
        INVALID_EMULATOR_SCHEME: 'auth/invalid-emulator-scheme',
        INVALID_IDP_RESPONSE: 'auth/invalid-credential',
        INVALID_MESSAGE_PAYLOAD: 'auth/invalid-message-payload',
        INVALID_MFA_SESSION: 'auth/invalid-multi-factor-session',
        INVALID_OAUTH_CLIENT_ID: 'auth/invalid-oauth-client-id',
        INVALID_OAUTH_PROVIDER: 'auth/invalid-oauth-provider',
        INVALID_OOB_CODE: 'auth/invalid-action-code',
        INVALID_ORIGIN: 'auth/unauthorized-domain',
        INVALID_PASSWORD: 'auth/wrong-password',
        INVALID_PERSISTENCE: 'auth/invalid-persistence-type',
        INVALID_PHONE_NUMBER: 'auth/invalid-phone-number',
        INVALID_PROVIDER_ID: 'auth/invalid-provider-id',
        INVALID_RECIPIENT_EMAIL: 'auth/invalid-recipient-email',
        INVALID_SENDER: 'auth/invalid-sender',
        INVALID_SESSION_INFO: 'auth/invalid-verification-id',
        INVALID_TENANT_ID: 'auth/invalid-tenant-id',
        MFA_INFO_NOT_FOUND: 'auth/multi-factor-info-not-found',
        MFA_REQUIRED: 'auth/multi-factor-auth-required',
        MISSING_ANDROID_PACKAGE_NAME: 'auth/missing-android-pkg-name',
        MISSING_APP_CREDENTIAL: 'auth/missing-app-credential',
        MISSING_AUTH_DOMAIN: 'auth/auth-domain-config-required',
        MISSING_CODE: 'auth/missing-verification-code',
        MISSING_CONTINUE_URI: 'auth/missing-continue-uri',
        MISSING_IFRAME_START: 'auth/missing-iframe-start',
        MISSING_IOS_BUNDLE_ID: 'auth/missing-ios-bundle-id',
        MISSING_OR_INVALID_NONCE: 'auth/missing-or-invalid-nonce',
        MISSING_MFA_INFO: 'auth/missing-multi-factor-info',
        MISSING_MFA_SESSION: 'auth/missing-multi-factor-session',
        MISSING_PHONE_NUMBER: 'auth/missing-phone-number',
        MISSING_SESSION_INFO: 'auth/missing-verification-id',
        MODULE_DESTROYED: 'auth/app-deleted',
        NEED_CONFIRMATION: 'auth/account-exists-with-different-credential',
        NETWORK_REQUEST_FAILED: 'auth/network-request-failed',
        NULL_USER: 'auth/null-user',
        NO_AUTH_EVENT: 'auth/no-auth-event',
        NO_SUCH_PROVIDER: 'auth/no-such-provider',
        OPERATION_NOT_ALLOWED: 'auth/operation-not-allowed',
        OPERATION_NOT_SUPPORTED: 'auth/operation-not-supported-in-this-environment',
        POPUP_BLOCKED: 'auth/popup-blocked',
        POPUP_CLOSED_BY_USER: 'auth/popup-closed-by-user',
        PROVIDER_ALREADY_LINKED: 'auth/provider-already-linked',
        QUOTA_EXCEEDED: 'auth/quota-exceeded',
        REDIRECT_CANCELLED_BY_USER: 'auth/redirect-cancelled-by-user',
        REDIRECT_OPERATION_PENDING: 'auth/redirect-operation-pending',
        REJECTED_CREDENTIAL: 'auth/rejected-credential',
        SECOND_FACTOR_ALREADY_ENROLLED: 'auth/second-factor-already-in-use',
        SECOND_FACTOR_LIMIT_EXCEEDED: 'auth/maximum-second-factor-count-exceeded',
        TENANT_ID_MISMATCH: 'auth/tenant-id-mismatch',
        TIMEOUT: 'auth/timeout',
        TOKEN_EXPIRED: 'auth/user-token-expired',
        TOO_MANY_ATTEMPTS_TRY_LATER: 'auth/too-many-requests',
        UNAUTHORIZED_DOMAIN: 'auth/unauthorized-continue-uri',
        UNSUPPORTED_FIRST_FACTOR: 'auth/unsupported-first-factor',
        UNSUPPORTED_PERSISTENCE: 'auth/unsupported-persistence-type',
        UNSUPPORTED_TENANT_OPERATION: 'auth/unsupported-tenant-operation',
        UNVERIFIED_EMAIL: 'auth/unverified-email',
        USER_CANCELLED: 'auth/user-cancelled',
        USER_DELETED: 'auth/user-not-found',
        USER_DISABLED: 'auth/user-disabled',
        USER_MISMATCH: 'auth/user-mismatch',
        USER_SIGNED_OUT: 'auth/user-signed-out',
        WEAK_PASSWORD: 'auth/weak-password',
        WEB_STORAGE_UNSUPPORTED: 'auth/web-storage-unsupported',
        ALREADY_INITIALIZED: 'auth/already-initialized'
      };
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      var logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger('@firebase/auth');

      function _logError(msg) {
        if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.ERROR) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          logClient.error.apply(logClient, ["Auth (".concat(_firebase_app__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION, "): ").concat(msg)].concat(args));
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _fail(authOrCode) {
        for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
          rest[_key3 - 1] = arguments[_key3];
        }

        throw createErrorInternal.apply(void 0, [authOrCode].concat(rest));
      }

      function _createError(authOrCode) {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
          rest[_key4 - 1] = arguments[_key4];
        }

        return createErrorInternal.apply(void 0, [authOrCode].concat(rest));
      }

      function _errorWithCustomMessage(auth, code, message) {
        var errorMap = Object.assign(Object.assign({}, prodErrorMap()), _defineProperty({}, code, message));
        var factory = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.ErrorFactory('auth', 'Firebase', errorMap);
        return factory.create(code, {
          appName: auth.name
        });
      }

      function _assertInstanceOf(auth, object, instance) {
        var constructorInstance = instance;

        if (!(object instanceof constructorInstance)) {
          if (constructorInstance.name !== object.constructor.name) {
            _fail(auth, "argument-error"
            /* ARGUMENT_ERROR */
            );
          }

          throw _errorWithCustomMessage(auth, "argument-error"
          /* ARGUMENT_ERROR */
          , "Type of ".concat(object.constructor.name, " does not match expected instance.") + "Did you pass a reference from a different Auth SDK?");
        }
      }

      function createErrorInternal(authOrCode) {
        for (var _len4 = arguments.length, rest = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
          rest[_key5 - 1] = arguments[_key5];
        }

        if (typeof authOrCode !== 'string') {
          var _authOrCode$_errorFac;

          var code = rest[0];

          var fullParams = _toConsumableArray(rest.slice(1));

          if (fullParams[0]) {
            fullParams[0].appName = authOrCode.name;
          }

          return (_authOrCode$_errorFac = authOrCode._errorFactory).create.apply(_authOrCode$_errorFac, [code].concat(_toConsumableArray(fullParams)));
        }

        return _DEFAULT_AUTH_ERROR_FACTORY.create.apply(_DEFAULT_AUTH_ERROR_FACTORY, [authOrCode].concat(rest));
      }

      function _assert(assertion, authOrCode) {
        if (!assertion) {
          for (var _len5 = arguments.length, rest = new Array(_len5 > 2 ? _len5 - 2 : 0), _key6 = 2; _key6 < _len5; _key6++) {
            rest[_key6 - 2] = arguments[_key6];
          }

          throw createErrorInternal.apply(void 0, [authOrCode].concat(rest));
        }
      }
      /**
       * Unconditionally fails, throwing an internal error with the given message.
       *
       * @param failure type of failure encountered
       * @throws Error
       */


      function debugFail(failure) {
        // Log the failure in addition to throw an exception, just in case the
        // exception is swallowed.
        var message = "INTERNAL ASSERTION FAILED: " + failure;

        _logError(message); // NOTE: We don't use FirebaseError here because these are internal failures
        // that cannot be handled by the user. (Also it would create a circular
        // dependency between the error and assert modules which doesn't work.)


        throw new Error(message);
      }
      /**
       * Fails if the given assertion condition is false, throwing an Error with the
       * given message if it did.
       *
       * @param assertion
       * @param message
       */


      function debugAssert(assertion, message) {
        if (!assertion) {
          debugFail(message);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var instanceCache = new Map();

      function _getInstance(cls) {
        debugAssert(cls instanceof Function, 'Expected a class definition');
        var instance = instanceCache.get(cls);

        if (instance) {
          debugAssert(instance instanceof cls, 'Instance stored in cache mismatched with class');
          return instance;
        }

        instance = new cls();
        instanceCache.set(cls, instance);
        return instance;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Initializes an {@link Auth} instance with fine-grained control over
       * {@link Dependencies}.
       *
       * @remarks
       *
       * This function allows more control over the {@link Auth} instance than
       * {@link getAuth}. `getAuth` uses platform-specific defaults to supply
       * the {@link Dependencies}. In general, `getAuth` is the easiest way to
       * initialize Auth and works for most use cases. Use `initializeAuth` if you
       * need control over which persistence layer is used, or to minimize bundle
       * size if you're not using either `signInWithPopup` or `signInWithRedirect`.
       *
       * For example, if your app only uses anonymous accounts and you only want
       * accounts saved for the current session, initialize `Auth` with:
       *
       * ```js
       * const auth = initializeAuth(app, {
       *   persistence: browserSessionPersistence,
       *   popupRedirectResolver: undefined,
       * });
       * ```
       *
       * @public
       */


      function initializeAuth(app, deps) {
        var provider = (0, _firebase_app__WEBPACK_IMPORTED_MODULE_1__._getProvider)(app, 'auth');

        if (provider.isInitialized()) {
          var _auth2 = provider.getImmediate();

          var initialOptions = provider.getOptions();

          if ((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {
            return _auth2;
          } else {
            _fail(_auth2, "already-initialized"
            /* ALREADY_INITIALIZED */
            );
          }
        }

        var auth = provider.initialize({
          options: deps
        });
        return auth;
      }

      function _initializeAuthInstance(auth, deps) {
        var persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
        var hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);

        if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
          auth._updateErrorMap(deps.errorMap);
        } // This promise is intended to float; auth initialization happens in the
        // background, meanwhile the auth object may be used by the app.
        // eslint-disable-next-line @typescript-eslint/no-floating-promises


        auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _getCurrentUrl() {
        var _a;

        return typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href) || '';
      }

      function _isHttpOrHttps() {
        return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';
      }

      function _getCurrentScheme() {
        var _a;

        return typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Determine whether the browser is working online
       */


      function _isOnline() {
        if (typeof navigator !== 'undefined' && navigator && 'onLine' in navigator && typeof navigator.onLine === 'boolean' && ( // Apply only for traditional web apps and Chrome extensions.
        // This is especially true for Cordova apps which have unreliable
        // navigator.onLine behavior unless cordova-plugin-network-information is
        // installed which overwrites the native navigator.onLine value and
        // defines navigator.connection.
        _isHttpOrHttps() || (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.isBrowserExtension)() || 'connection' in navigator)) {
          return navigator.onLine;
        } // If we can't determine the state, assume it is online.


        return true;
      }

      function _getUserLanguage() {
        if (typeof navigator === 'undefined') {
          return null;
        }

        var navigatorLanguage = navigator;
        return (// Most reliable, but only supported in Chrome/Firefox.
          navigatorLanguage.languages && navigatorLanguage.languages[0] || // Supported in most browsers, but returns the language of the browser
          // UI, not the language set in browser settings.
          navigatorLanguage.language || // Couldn't determine language.
          null
        );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * A structure to help pick between a range of long and short delay durations
       * depending on the current environment. In general, the long delay is used for
       * mobile environments whereas short delays are used for desktop environments.
       */


      var Delay = /*#__PURE__*/function () {
        function Delay(shortDelay, longDelay) {
          _classCallCheck(this, Delay);

          this.shortDelay = shortDelay;
          this.longDelay = longDelay; // Internal error when improperly initialized.

          debugAssert(longDelay > shortDelay, 'Short delay should be less than long delay!');
          this.isMobile = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.isMobileCordova)() || (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.isReactNative)();
        }

        _createClass(Delay, [{
          key: "get",
          value: function get() {
            if (!_isOnline()) {
              // Pick the shorter timeout.
              return Math.min(5000
              /* OFFLINE */
              , this.shortDelay);
            } // If running in a mobile environment, return the long delay, otherwise
            // return the short delay.
            // This could be improved in the future to dynamically change based on other
            // variables instead of just reading the current environment.


            return this.isMobile ? this.longDelay : this.shortDelay;
          }
        }]);

        return Delay;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _emulatorUrl(config, path) {
        debugAssert(config.emulator, 'Emulator should always be set here');
        var url = config.emulator.url;

        if (!path) {
          return url;
        }

        return "".concat(url).concat(path.startsWith('/') ? path.slice(1) : path);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var FetchProvider = /*#__PURE__*/function () {
        function FetchProvider() {
          _classCallCheck(this, FetchProvider);
        }

        _createClass(FetchProvider, null, [{
          key: "initialize",
          value: function initialize(fetchImpl, headersImpl, responseImpl) {
            this.fetchImpl = fetchImpl;

            if (headersImpl) {
              this.headersImpl = headersImpl;
            }

            if (responseImpl) {
              this.responseImpl = responseImpl;
            }
          }
        }, {
          key: "fetch",
          value: function fetch() {
            if (this.fetchImpl) {
              return this.fetchImpl;
            }

            if (typeof self !== 'undefined' && 'fetch' in self) {
              return self.fetch;
            }

            debugFail('Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');
          }
        }, {
          key: "headers",
          value: function headers() {
            if (this.headersImpl) {
              return this.headersImpl;
            }

            if (typeof self !== 'undefined' && 'Headers' in self) {
              return self.Headers;
            }

            debugFail('Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');
          }
        }, {
          key: "response",
          value: function response() {
            if (this.responseImpl) {
              return this.responseImpl;
            }

            if (typeof self !== 'undefined' && 'Response' in self) {
              return self.Response;
            }

            debugFail('Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');
          }
        }]);

        return FetchProvider;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Map from errors returned by the server to errors to developer visible errors
       */


      var SERVER_ERROR_MAP = (_SERVER_ERROR_MAP = {}, _defineProperty(_SERVER_ERROR_MAP, "CREDENTIAL_MISMATCH"
      /* CREDENTIAL_MISMATCH */
      , "custom-token-mismatch"), _defineProperty(_SERVER_ERROR_MAP, "MISSING_CUSTOM_TOKEN"
      /* MISSING_CUSTOM_TOKEN */
      , "internal-error"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_IDENTIFIER"
      /* INVALID_IDENTIFIER */
      , "invalid-email"), _defineProperty(_SERVER_ERROR_MAP, "MISSING_CONTINUE_URI"
      /* MISSING_CONTINUE_URI */
      , "internal-error"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_PASSWORD"
      /* INVALID_PASSWORD */
      , "wrong-password"), _defineProperty(_SERVER_ERROR_MAP, "MISSING_PASSWORD"
      /* MISSING_PASSWORD */
      , "internal-error"), _defineProperty(_SERVER_ERROR_MAP, "EMAIL_EXISTS"
      /* EMAIL_EXISTS */
      , "email-already-in-use"), _defineProperty(_SERVER_ERROR_MAP, "PASSWORD_LOGIN_DISABLED"
      /* PASSWORD_LOGIN_DISABLED */
      , "operation-not-allowed"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_IDP_RESPONSE"
      /* INVALID_IDP_RESPONSE */
      , "invalid-credential"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_PENDING_TOKEN"
      /* INVALID_PENDING_TOKEN */
      , "invalid-credential"), _defineProperty(_SERVER_ERROR_MAP, "FEDERATED_USER_ID_ALREADY_LINKED"
      /* FEDERATED_USER_ID_ALREADY_LINKED */
      , "credential-already-in-use"), _defineProperty(_SERVER_ERROR_MAP, "MISSING_REQ_TYPE"
      /* MISSING_REQ_TYPE */
      , "internal-error"), _defineProperty(_SERVER_ERROR_MAP, "EMAIL_NOT_FOUND"
      /* EMAIL_NOT_FOUND */
      , "user-not-found"), _defineProperty(_SERVER_ERROR_MAP, "RESET_PASSWORD_EXCEED_LIMIT"
      /* RESET_PASSWORD_EXCEED_LIMIT */
      , "too-many-requests"), _defineProperty(_SERVER_ERROR_MAP, "EXPIRED_OOB_CODE"
      /* EXPIRED_OOB_CODE */
      , "expired-action-code"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_OOB_CODE"
      /* INVALID_OOB_CODE */
      , "invalid-action-code"), _defineProperty(_SERVER_ERROR_MAP, "MISSING_OOB_CODE"
      /* MISSING_OOB_CODE */
      , "internal-error"), _defineProperty(_SERVER_ERROR_MAP, "CREDENTIAL_TOO_OLD_LOGIN_AGAIN"
      /* CREDENTIAL_TOO_OLD_LOGIN_AGAIN */
      , "requires-recent-login"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_ID_TOKEN"
      /* INVALID_ID_TOKEN */
      , "invalid-user-token"), _defineProperty(_SERVER_ERROR_MAP, "TOKEN_EXPIRED"
      /* TOKEN_EXPIRED */
      , "user-token-expired"), _defineProperty(_SERVER_ERROR_MAP, "USER_NOT_FOUND"
      /* USER_NOT_FOUND */
      , "user-token-expired"), _defineProperty(_SERVER_ERROR_MAP, "TOO_MANY_ATTEMPTS_TRY_LATER"
      /* TOO_MANY_ATTEMPTS_TRY_LATER */
      , "too-many-requests"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_CODE"
      /* INVALID_CODE */
      , "invalid-verification-code"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_SESSION_INFO"
      /* INVALID_SESSION_INFO */
      , "invalid-verification-id"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_TEMPORARY_PROOF"
      /* INVALID_TEMPORARY_PROOF */
      , "invalid-credential"), _defineProperty(_SERVER_ERROR_MAP, "MISSING_SESSION_INFO"
      /* MISSING_SESSION_INFO */
      , "missing-verification-id"), _defineProperty(_SERVER_ERROR_MAP, "SESSION_EXPIRED"
      /* SESSION_EXPIRED */
      , "code-expired"), _defineProperty(_SERVER_ERROR_MAP, "MISSING_ANDROID_PACKAGE_NAME"
      /* MISSING_ANDROID_PACKAGE_NAME */
      , "missing-android-pkg-name"), _defineProperty(_SERVER_ERROR_MAP, "UNAUTHORIZED_DOMAIN"
      /* UNAUTHORIZED_DOMAIN */
      , "unauthorized-continue-uri"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_OAUTH_CLIENT_ID"
      /* INVALID_OAUTH_CLIENT_ID */
      , "invalid-oauth-client-id"), _defineProperty(_SERVER_ERROR_MAP, "ADMIN_ONLY_OPERATION"
      /* ADMIN_ONLY_OPERATION */
      , "admin-restricted-operation"), _defineProperty(_SERVER_ERROR_MAP, "INVALID_MFA_PENDING_CREDENTIAL"
      /* INVALID_MFA_PENDING_CREDENTIAL */
      , "invalid-multi-factor-session"), _defineProperty(_SERVER_ERROR_MAP, "MFA_ENROLLMENT_NOT_FOUND"
      /* MFA_ENROLLMENT_NOT_FOUND */
      , "multi-factor-info-not-found"), _defineProperty(_SERVER_ERROR_MAP, "MISSING_MFA_ENROLLMENT_ID"
      /* MISSING_MFA_ENROLLMENT_ID */
      , "missing-multi-factor-info"), _defineProperty(_SERVER_ERROR_MAP, "MISSING_MFA_PENDING_CREDENTIAL"
      /* MISSING_MFA_PENDING_CREDENTIAL */
      , "missing-multi-factor-session"), _defineProperty(_SERVER_ERROR_MAP, "SECOND_FACTOR_EXISTS"
      /* SECOND_FACTOR_EXISTS */
      , "second-factor-already-in-use"), _defineProperty(_SERVER_ERROR_MAP, "SECOND_FACTOR_LIMIT_EXCEEDED"
      /* SECOND_FACTOR_LIMIT_EXCEEDED */
      , "maximum-second-factor-count-exceeded"), _defineProperty(_SERVER_ERROR_MAP, "BLOCKING_FUNCTION_ERROR_RESPONSE"
      /* BLOCKING_FUNCTION_ERROR_RESPONSE */
      , "internal-error"), _SERVER_ERROR_MAP);
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      var DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);

      function _addTidIfNecessary(auth, request) {
        if (auth.tenantId && !request.tenantId) {
          return Object.assign(Object.assign({}, request), {
            tenantId: auth.tenantId
          });
        }

        return request;
      }

      function _performApiRequest(_x26, _x27, _x28, _x29) {
        return _performApiRequest2.apply(this, arguments);
      }

      function _performApiRequest2() {
        _performApiRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee105(auth, method, path, request) {
          var customErrorMap,
              _args105 = arguments;
          return regeneratorRuntime.wrap(function _callee105$(_context105) {
            while (1) {
              switch (_context105.prev = _context105.next) {
                case 0:
                  customErrorMap = _args105.length > 4 && _args105[4] !== undefined ? _args105[4] : {};
                  return _context105.abrupt("return", _performFetchWithErrorHandling(auth, customErrorMap, function () {
                    var body = {};
                    var params = {};

                    if (request) {
                      if (method === "GET"
                      /* GET */
                      ) {
                        params = request;
                      } else {
                        body = {
                          body: JSON.stringify(request)
                        };
                      }
                    }

                    var query = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystring)(Object.assign({
                      key: auth.config.apiKey
                    }, params)).slice(1);
                    var headers = new (FetchProvider.headers())();
                    headers.set("Content-Type"
                    /* CONTENT_TYPE */
                    , 'application/json');
                    headers.set("X-Client-Version"
                    /* X_CLIENT_VERSION */
                    , auth._getSdkClientVersion());

                    if (auth.languageCode) {
                      headers.set("X-Firebase-Locale"
                      /* X_FIREBASE_LOCALE */
                      , auth.languageCode);
                    }

                    return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), Object.assign({
                      method: method,
                      headers: headers,
                      referrerPolicy: 'no-referrer'
                    }, body));
                  }));

                case 2:
                case "end":
                  return _context105.stop();
              }
            }
          }, _callee105);
        }));
        return _performApiRequest2.apply(this, arguments);
      }

      function _performFetchWithErrorHandling(_x30, _x31, _x32) {
        return _performFetchWithErrorHandling2.apply(this, arguments);
      }

      function _performFetchWithErrorHandling2() {
        _performFetchWithErrorHandling2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee106(auth, customErrorMap, fetchFn) {
          var errorMap, networkTimeout, response, json, errorMessage, _errorMessage$split, _errorMessage$split2, serverErrorCode, serverErrorMessage, authError;

          return regeneratorRuntime.wrap(function _callee106$(_context106) {
            while (1) {
              switch (_context106.prev = _context106.next) {
                case 0:
                  auth._canInitEmulator = false;
                  errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);
                  _context106.prev = 2;
                  networkTimeout = new NetworkTimeout(auth);
                  _context106.next = 6;
                  return Promise.race([fetchFn(), networkTimeout.promise]);

                case 6:
                  response = _context106.sent;
                  // If we've reached this point, the fetch succeeded and the networkTimeout
                  // didn't throw; clear the network timeout delay so that Node won't hang
                  networkTimeout.clearNetworkTimeout();
                  _context106.next = 10;
                  return response.json();

                case 10:
                  json = _context106.sent;

                  if (!('needConfirmation' in json)) {
                    _context106.next = 13;
                    break;
                  }

                  throw _makeTaggedError(auth, "account-exists-with-different-credential"
                  /* NEED_CONFIRMATION */
                  , json);

                case 13:
                  if (!(response.ok && !('errorMessage' in json))) {
                    _context106.next = 17;
                    break;
                  }

                  return _context106.abrupt("return", json);

                case 17:
                  errorMessage = response.ok ? json.errorMessage : json.error.message;
                  _errorMessage$split = errorMessage.split(' : '), _errorMessage$split2 = _slicedToArray(_errorMessage$split, 2), serverErrorCode = _errorMessage$split2[0], serverErrorMessage = _errorMessage$split2[1];

                  if (!(serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED"
                  /* FEDERATED_USER_ID_ALREADY_LINKED */
                  )) {
                    _context106.next = 23;
                    break;
                  }

                  throw _makeTaggedError(auth, "credential-already-in-use"
                  /* CREDENTIAL_ALREADY_IN_USE */
                  , json);

                case 23:
                  if (!(serverErrorCode === "EMAIL_EXISTS"
                  /* EMAIL_EXISTS */
                  )) {
                    _context106.next = 25;
                    break;
                  }

                  throw _makeTaggedError(auth, "email-already-in-use"
                  /* EMAIL_EXISTS */
                  , json);

                case 25:
                  authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\s]+/g, '-');

                  if (!serverErrorMessage) {
                    _context106.next = 30;
                    break;
                  }

                  throw _errorWithCustomMessage(auth, authError, serverErrorMessage);

                case 30:
                  _fail(auth, authError);

                case 31:
                  _context106.next = 38;
                  break;

                case 33:
                  _context106.prev = 33;
                  _context106.t0 = _context106["catch"](2);

                  if (!(_context106.t0 instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_0__.FirebaseError)) {
                    _context106.next = 37;
                    break;
                  }

                  throw _context106.t0;

                case 37:
                  _fail(auth, "network-request-failed"
                  /* NETWORK_REQUEST_FAILED */
                  );

                case 38:
                case "end":
                  return _context106.stop();
              }
            }
          }, _callee106, null, [[2, 33]]);
        }));
        return _performFetchWithErrorHandling2.apply(this, arguments);
      }

      function _performSignInRequest(_x33, _x34, _x35, _x36) {
        return _performSignInRequest2.apply(this, arguments);
      }

      function _performSignInRequest2() {
        _performSignInRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee107(auth, method, path, request) {
          var customErrorMap,
              serverResponse,
              _args107 = arguments;
          return regeneratorRuntime.wrap(function _callee107$(_context107) {
            while (1) {
              switch (_context107.prev = _context107.next) {
                case 0:
                  customErrorMap = _args107.length > 4 && _args107[4] !== undefined ? _args107[4] : {};
                  _context107.next = 3;
                  return _performApiRequest(auth, method, path, request, customErrorMap);

                case 3:
                  serverResponse = _context107.sent;

                  if ('mfaPendingCredential' in serverResponse) {
                    _fail(auth, "multi-factor-auth-required"
                    /* MFA_REQUIRED */
                    , {
                      _serverResponse: serverResponse
                    });
                  }

                  return _context107.abrupt("return", serverResponse);

                case 6:
                case "end":
                  return _context107.stop();
              }
            }
          }, _callee107);
        }));
        return _performSignInRequest2.apply(this, arguments);
      }

      function _getFinalTarget(auth, host, path, query) {
        var base = "".concat(host).concat(path, "?").concat(query);

        if (!auth.config.emulator) {
          return "".concat(auth.config.apiScheme, "://").concat(base);
        }

        return _emulatorUrl(auth.config, base);
      }

      var NetworkTimeout = /*#__PURE__*/function () {
        function NetworkTimeout(auth) {
          var _this2 = this;

          _classCallCheck(this, NetworkTimeout);

          this.auth = auth; // Node timers and browser timers are fundamentally incompatible, but we
          // don't care about the value here
          // eslint-disable-next-line @typescript-eslint/no-explicit-any

          this.timer = null;
          this.promise = new Promise(function (_, reject) {
            _this2.timer = setTimeout(function () {
              return reject(_createError(_this2.auth, "timeout"
              /* TIMEOUT */
              ));
            }, DEFAULT_API_TIMEOUT_MS.get());
          });
        }

        _createClass(NetworkTimeout, [{
          key: "clearNetworkTimeout",
          value: function clearNetworkTimeout() {
            clearTimeout(this.timer);
          }
        }]);

        return NetworkTimeout;
      }();

      function _makeTaggedError(auth, code, response) {
        var errorParams = {
          appName: auth.name
        };

        if (response.email) {
          errorParams.email = response.email;
        }

        if (response.phoneNumber) {
          errorParams.phoneNumber = response.phoneNumber;
        }

        var error = _createError(auth, code, errorParams); // We know customData is defined on error because errorParams is defined


        error.customData._tokenResponse = response;
        return error;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function deleteAccount(_x37, _x38) {
        return _deleteAccount.apply(this, arguments);
      }

      function _deleteAccount() {
        _deleteAccount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee108(auth, request) {
          return regeneratorRuntime.wrap(function _callee108$(_context108) {
            while (1) {
              switch (_context108.prev = _context108.next) {
                case 0:
                  return _context108.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:delete"
                  /* DELETE_ACCOUNT */
                  , request));

                case 1:
                case "end":
                  return _context108.stop();
              }
            }
          }, _callee108);
        }));
        return _deleteAccount.apply(this, arguments);
      }

      function deleteLinkedAccounts(_x39, _x40) {
        return _deleteLinkedAccounts.apply(this, arguments);
      }

      function _deleteLinkedAccounts() {
        _deleteLinkedAccounts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee109(auth, request) {
          return regeneratorRuntime.wrap(function _callee109$(_context109) {
            while (1) {
              switch (_context109.prev = _context109.next) {
                case 0:
                  return _context109.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:update"
                  /* SET_ACCOUNT_INFO */
                  , request));

                case 1:
                case "end":
                  return _context109.stop();
              }
            }
          }, _callee109);
        }));
        return _deleteLinkedAccounts.apply(this, arguments);
      }

      function getAccountInfo(_x41, _x42) {
        return _getAccountInfo.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _getAccountInfo() {
        _getAccountInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee110(auth, request) {
          return regeneratorRuntime.wrap(function _callee110$(_context110) {
            while (1) {
              switch (_context110.prev = _context110.next) {
                case 0:
                  return _context110.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:lookup"
                  /* GET_ACCOUNT_INFO */
                  , request));

                case 1:
                case "end":
                  return _context110.stop();
              }
            }
          }, _callee110);
        }));
        return _getAccountInfo.apply(this, arguments);
      }

      function utcTimestampToDateString(utcTimestamp) {
        if (!utcTimestamp) {
          return undefined;
        }

        try {
          // Convert to date object.
          var date = new Date(Number(utcTimestamp)); // Test date is valid.

          if (!isNaN(date.getTime())) {
            // Convert to UTC date string.
            return date.toUTCString();
          }
        } catch (e) {// Do nothing. undefined will be returned.
        }

        return undefined;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.
       *
       * @remarks
       * Returns the current token if it has not expired or if it will not expire in the next five
       * minutes. Otherwise, this will refresh the token and return a new one.
       *
       * @param user - The user.
       * @param forceRefresh - Force refresh regardless of token expiration.
       *
       * @public
       */


      function getIdToken(user) {
        var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user).getIdToken(forceRefresh);
      }
      /**
       * Returns a deserialized JSON Web Token (JWT) used to identitfy the user to a Firebase service.
       *
       * @remarks
       * Returns the current token if it has not expired or if it will not expire in the next five
       * minutes. Otherwise, this will refresh the token and return a new one.
       *
       * @param user - The user.
       * @param forceRefresh - Force refresh regardless of token expiration.
       *
       * @public
       */


      function _getIdTokenResult2(_x43) {
        return _getIdTokenResult.apply(this, arguments);
      }

      function _getIdTokenResult() {
        _getIdTokenResult = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee111(user) {
          var forceRefresh,
              userInternal,
              token,
              claims,
              firebase,
              signInProvider,
              _args111 = arguments;
          return regeneratorRuntime.wrap(function _callee111$(_context111) {
            while (1) {
              switch (_context111.prev = _context111.next) {
                case 0:
                  forceRefresh = _args111.length > 1 && _args111[1] !== undefined ? _args111[1] : false;
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);
                  _context111.next = 4;
                  return userInternal.getIdToken(forceRefresh);

                case 4:
                  token = _context111.sent;
                  claims = _parseToken(token);

                  _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  firebase = typeof claims.firebase === 'object' ? claims.firebase : undefined;
                  signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_provider'];
                  return _context111.abrupt("return", {
                    claims: claims,
                    token: token,
                    authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
                    issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
                    expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
                    signInProvider: signInProvider || null,
                    signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_second_factor']) || null
                  });

                case 10:
                case "end":
                  return _context111.stop();
              }
            }
          }, _callee111);
        }));
        return _getIdTokenResult.apply(this, arguments);
      }

      function secondsStringToMilliseconds(seconds) {
        return Number(seconds) * 1000;
      }

      function _parseToken(token) {
        var _token$split = token.split('.'),
            _token$split2 = _slicedToArray(_token$split, 3),
            algorithm = _token$split2[0],
            payload = _token$split2[1],
            signature = _token$split2[2];

        if (algorithm === undefined || payload === undefined || signature === undefined) {
          _logError('JWT malformed, contained fewer than 3 sections');

          return null;
        }

        try {
          var decoded = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.base64Decode)(payload);

          if (!decoded) {
            _logError('Failed to decode base64 JWT payload');

            return null;
          }

          return JSON.parse(decoded);
        } catch (e) {
          _logError('Caught error parsing JWT payload as JSON', e);

          return null;
        }
      }
      /**
       * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.
       */


      function _tokenExpiresIn(token) {
        var parsedToken = _parseToken(token);

        _assert(parsedToken, "internal-error"
        /* INTERNAL_ERROR */
        );

        _assert(typeof parsedToken.exp !== 'undefined', "internal-error"
        /* INTERNAL_ERROR */
        );

        _assert(typeof parsedToken.iat !== 'undefined', "internal-error"
        /* INTERNAL_ERROR */
        );

        return Number(parsedToken.exp) - Number(parsedToken.iat);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _logoutIfInvalidated(_x44, _x45) {
        return _logoutIfInvalidated2.apply(this, arguments);
      }

      function _logoutIfInvalidated2() {
        _logoutIfInvalidated2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee112(user, promise) {
          var bypassAuthState,
              _args112 = arguments;
          return regeneratorRuntime.wrap(function _callee112$(_context112) {
            while (1) {
              switch (_context112.prev = _context112.next) {
                case 0:
                  bypassAuthState = _args112.length > 2 && _args112[2] !== undefined ? _args112[2] : false;

                  if (!bypassAuthState) {
                    _context112.next = 3;
                    break;
                  }

                  return _context112.abrupt("return", promise);

                case 3:
                  _context112.prev = 3;
                  _context112.next = 6;
                  return promise;

                case 6:
                  return _context112.abrupt("return", _context112.sent);

                case 9:
                  _context112.prev = 9;
                  _context112.t0 = _context112["catch"](3);

                  if (!(_context112.t0 instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_0__.FirebaseError && isUserInvalidated(_context112.t0))) {
                    _context112.next = 15;
                    break;
                  }

                  if (!(user.auth.currentUser === user)) {
                    _context112.next = 15;
                    break;
                  }

                  _context112.next = 15;
                  return user.auth.signOut();

                case 15:
                  throw _context112.t0;

                case 16:
                case "end":
                  return _context112.stop();
              }
            }
          }, _callee112, null, [[3, 9]]);
        }));
        return _logoutIfInvalidated2.apply(this, arguments);
      }

      function isUserInvalidated(_ref4) {
        var code = _ref4.code;
        return code === "auth/".concat("user-disabled"
        /* USER_DISABLED */
        ) || code === "auth/".concat("user-token-expired"
        /* TOKEN_EXPIRED */
        );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var ProactiveRefresh = /*#__PURE__*/function () {
        function ProactiveRefresh(user) {
          _classCallCheck(this, ProactiveRefresh);

          this.user = user;
          this.isRunning = false; // Node timers and browser timers return fundamentally different types.
          // We don't actually care what the value is but TS won't accept unknown and
          // we can't cast properly in both environments.
          // eslint-disable-next-line @typescript-eslint/no-explicit-any

          this.timerId = null;
          this.errorBackoff = 30000
          /* RETRY_BACKOFF_MIN */
          ;
        }

        _createClass(ProactiveRefresh, [{
          key: "_start",
          value: function _start() {
            if (this.isRunning) {
              return;
            }

            this.isRunning = true;
            this.schedule();
          }
        }, {
          key: "_stop",
          value: function _stop() {
            if (!this.isRunning) {
              return;
            }

            this.isRunning = false;

            if (this.timerId !== null) {
              clearTimeout(this.timerId);
            }
          }
        }, {
          key: "getInterval",
          value: function getInterval(wasError) {
            var _a;

            if (wasError) {
              var interval = this.errorBackoff;
              this.errorBackoff = Math.min(this.errorBackoff * 2, 960000
              /* RETRY_BACKOFF_MAX */
              );
              return interval;
            } else {
              // Reset the error backoff
              this.errorBackoff = 30000
              /* RETRY_BACKOFF_MIN */
              ;
              var expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;

              var _interval = expTime - Date.now() - 300000
              /* OFFSET */
              ;

              return Math.max(0, _interval);
            }
          }
        }, {
          key: "schedule",
          value: function schedule() {
            var _this3 = this;

            var wasError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            if (!this.isRunning) {
              // Just in case...
              return;
            }

            var interval = this.getInterval(wasError);
            this.timerId = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
              return regeneratorRuntime.wrap(function _callee20$(_context20) {
                while (1) {
                  switch (_context20.prev = _context20.next) {
                    case 0:
                      _context20.next = 2;
                      return _this3.iteration();

                    case 2:
                    case "end":
                      return _context20.stop();
                  }
                }
              }, _callee20);
            })), interval);
          }
        }, {
          key: "iteration",
          value: function () {
            var _iteration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
              return regeneratorRuntime.wrap(function _callee21$(_context21) {
                while (1) {
                  switch (_context21.prev = _context21.next) {
                    case 0:
                      _context21.prev = 0;
                      _context21.next = 3;
                      return this.user.getIdToken(true);

                    case 3:
                      _context21.next = 9;
                      break;

                    case 5:
                      _context21.prev = 5;
                      _context21.t0 = _context21["catch"](0);

                      // Only retry on network errors
                      if (_context21.t0.code === "auth/".concat("network-request-failed"
                      /* NETWORK_REQUEST_FAILED */
                      )) {
                        this.schedule(
                        /* wasError */
                        true);
                      }

                      return _context21.abrupt("return");

                    case 9:
                      this.schedule();

                    case 10:
                    case "end":
                      return _context21.stop();
                  }
                }
              }, _callee21, this, [[0, 5]]);
            }));

            function iteration() {
              return _iteration.apply(this, arguments);
            }

            return iteration;
          }()
        }]);

        return ProactiveRefresh;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var UserMetadata = /*#__PURE__*/function () {
        function UserMetadata(createdAt, lastLoginAt) {
          _classCallCheck(this, UserMetadata);

          this.createdAt = createdAt;
          this.lastLoginAt = lastLoginAt;

          this._initializeTime();
        }

        _createClass(UserMetadata, [{
          key: "_initializeTime",
          value: function _initializeTime() {
            this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
            this.creationTime = utcTimestampToDateString(this.createdAt);
          }
        }, {
          key: "_copy",
          value: function _copy(metadata) {
            this.createdAt = metadata.createdAt;
            this.lastLoginAt = metadata.lastLoginAt;

            this._initializeTime();
          }
        }, {
          key: "toJSON",
          value: function toJSON() {
            return {
              createdAt: this.createdAt,
              lastLoginAt: this.lastLoginAt
            };
          }
        }]);

        return UserMetadata;
      }();
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _reloadWithoutSaving(_x46) {
        return _reloadWithoutSaving2.apply(this, arguments);
      }
      /**
       * Reloads user account data, if signed in.
       *
       * @param user - The user.
       *
       * @public
       */


      function _reloadWithoutSaving2() {
        _reloadWithoutSaving2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee113(user) {
          var _a, auth, idToken, response, coreAccount, newProviderData, providerData, oldIsAnonymous, newIsAnonymous, isAnonymous, updates;

          return regeneratorRuntime.wrap(function _callee113$(_context113) {
            while (1) {
              switch (_context113.prev = _context113.next) {
                case 0:
                  auth = user.auth;
                  _context113.next = 3;
                  return user.getIdToken();

                case 3:
                  idToken = _context113.sent;
                  _context113.next = 6;
                  return _logoutIfInvalidated(user, getAccountInfo(auth, {
                    idToken: idToken
                  }));

                case 6:
                  response = _context113.sent;

                  _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  coreAccount = response.users[0];

                  user._notifyReloadListener(coreAccount);

                  newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length) ? extractProviderData(coreAccount.providerUserInfo) : [];
                  providerData = mergeProviderData(user.providerData, newProviderData); // Preserves the non-nonymous status of the stored user, even if no more
                  // credentials (federated or email/password) are linked to the user. If
                  // the user was previously anonymous, then use provider data to update.
                  // On the other hand, if it was not anonymous before, it should never be
                  // considered anonymous now.

                  oldIsAnonymous = user.isAnonymous;
                  newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
                  isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
                  updates = {
                    uid: coreAccount.localId,
                    displayName: coreAccount.displayName || null,
                    photoURL: coreAccount.photoUrl || null,
                    email: coreAccount.email || null,
                    emailVerified: coreAccount.emailVerified || false,
                    phoneNumber: coreAccount.phoneNumber || null,
                    tenantId: coreAccount.tenantId || null,
                    providerData: providerData,
                    metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
                    isAnonymous: isAnonymous
                  };
                  Object.assign(user, updates);

                case 17:
                case "end":
                  return _context113.stop();
              }
            }
          }, _callee113);
        }));
        return _reloadWithoutSaving2.apply(this, arguments);
      }

      function _reload2(_x47) {
        return _reload.apply(this, arguments);
      }

      function _reload() {
        _reload = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee114(user) {
          var userInternal;
          return regeneratorRuntime.wrap(function _callee114$(_context114) {
            while (1) {
              switch (_context114.prev = _context114.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);
                  _context114.next = 3;
                  return _reloadWithoutSaving(userInternal);

                case 3:
                  _context114.next = 5;
                  return userInternal.auth._persistUserIfCurrent(userInternal);

                case 5:
                  userInternal.auth._notifyListenersIfCurrent(userInternal);

                case 6:
                case "end":
                  return _context114.stop();
              }
            }
          }, _callee114);
        }));
        return _reload.apply(this, arguments);
      }

      function mergeProviderData(original, newData) {
        var deduped = original.filter(function (o) {
          return !newData.some(function (n) {
            return n.providerId === o.providerId;
          });
        });
        return [].concat(_toConsumableArray(deduped), _toConsumableArray(newData));
      }

      function extractProviderData(providers) {
        return providers.map(function (_a) {
          var providerId = _a.providerId,
              provider = (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, ["providerId"]);
          return {
            providerId: providerId,
            uid: provider.rawId || '',
            displayName: provider.displayName || null,
            email: provider.email || null,
            phoneNumber: provider.phoneNumber || null,
            photoURL: provider.photoUrl || null
          };
        });
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function requestStsToken(_x48, _x49) {
        return _requestStsToken.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * We need to mark this class as internal explicitly to exclude it in the public typings, because
       * it references AuthInternal which has a circular dependency with UserInternal.
       *
       * @internal
       */


      function _requestStsToken() {
        _requestStsToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee115(auth, refreshToken) {
          var response;
          return regeneratorRuntime.wrap(function _callee115$(_context115) {
            while (1) {
              switch (_context115.prev = _context115.next) {
                case 0:
                  _context115.next = 2;
                  return _performFetchWithErrorHandling(auth, {}, function () {
                    var body = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystring)({
                      'grant_type': 'refresh_token',
                      'refresh_token': refreshToken
                    }).slice(1);
                    var _auth$config = auth.config,
                        tokenApiHost = _auth$config.tokenApiHost,
                        apiKey = _auth$config.apiKey;

                    var url = _getFinalTarget(auth, tokenApiHost, "/v1/token"
                    /* TOKEN */
                    , "key=".concat(apiKey));

                    return FetchProvider.fetch()(url, {
                      method: "POST"
                      /* POST */
                      ,
                      headers: {
                        'X-Client-Version': auth._getSdkClientVersion(),
                        'Content-Type': 'application/x-www-form-urlencoded'
                      },
                      body: body
                    });
                  });

                case 2:
                  response = _context115.sent;
                  return _context115.abrupt("return", {
                    accessToken: response.access_token,
                    expiresIn: response.expires_in,
                    refreshToken: response.refresh_token
                  });

                case 4:
                case "end":
                  return _context115.stop();
              }
            }
          }, _callee115);
        }));
        return _requestStsToken.apply(this, arguments);
      }

      var StsTokenManager = /*#__PURE__*/function () {
        function StsTokenManager() {
          _classCallCheck(this, StsTokenManager);

          this.refreshToken = null;
          this.accessToken = null;
          this.expirationTime = null;
        }

        _createClass(StsTokenManager, [{
          key: "isExpired",
          get: function get() {
            return !this.expirationTime || Date.now() > this.expirationTime - 30000
            /* TOKEN_REFRESH */
            ;
          }
        }, {
          key: "updateFromServerResponse",
          value: function updateFromServerResponse(response) {
            _assert(response.idToken, "internal-error"
            /* INTERNAL_ERROR */
            );

            _assert(typeof response.idToken !== 'undefined', "internal-error"
            /* INTERNAL_ERROR */
            );

            _assert(typeof response.refreshToken !== 'undefined', "internal-error"
            /* INTERNAL_ERROR */
            );

            var expiresIn = 'expiresIn' in response && typeof response.expiresIn !== 'undefined' ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);
            this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
          }
        }, {
          key: "getToken",
          value: function () {
            var _getToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(auth) {
              var forceRefresh,
                  _args22 = arguments;
              return regeneratorRuntime.wrap(function _callee22$(_context22) {
                while (1) {
                  switch (_context22.prev = _context22.next) {
                    case 0:
                      forceRefresh = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : false;

                      _assert(!this.accessToken || this.refreshToken, auth, "user-token-expired"
                      /* TOKEN_EXPIRED */
                      );

                      if (!(!forceRefresh && this.accessToken && !this.isExpired)) {
                        _context22.next = 4;
                        break;
                      }

                      return _context22.abrupt("return", this.accessToken);

                    case 4:
                      if (!this.refreshToken) {
                        _context22.next = 8;
                        break;
                      }

                      _context22.next = 7;
                      return this.refresh(auth, this.refreshToken);

                    case 7:
                      return _context22.abrupt("return", this.accessToken);

                    case 8:
                      return _context22.abrupt("return", null);

                    case 9:
                    case "end":
                      return _context22.stop();
                  }
                }
              }, _callee22, this);
            }));

            function getToken(_x50) {
              return _getToken.apply(this, arguments);
            }

            return getToken;
          }()
        }, {
          key: "clearRefreshToken",
          value: function clearRefreshToken() {
            this.refreshToken = null;
          }
        }, {
          key: "refresh",
          value: function () {
            var _refresh = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(auth, oldToken) {
              var _yield$requestStsToke, accessToken, refreshToken, expiresIn;

              return regeneratorRuntime.wrap(function _callee23$(_context23) {
                while (1) {
                  switch (_context23.prev = _context23.next) {
                    case 0:
                      _context23.next = 2;
                      return requestStsToken(auth, oldToken);

                    case 2:
                      _yield$requestStsToke = _context23.sent;
                      accessToken = _yield$requestStsToke.accessToken;
                      refreshToken = _yield$requestStsToke.refreshToken;
                      expiresIn = _yield$requestStsToke.expiresIn;
                      this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));

                    case 7:
                    case "end":
                      return _context23.stop();
                  }
                }
              }, _callee23, this);
            }));

            function refresh(_x51, _x52) {
              return _refresh.apply(this, arguments);
            }

            return refresh;
          }()
        }, {
          key: "updateTokensAndExpiration",
          value: function updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {
            this.refreshToken = refreshToken || null;
            this.accessToken = accessToken || null;
            this.expirationTime = Date.now() + expiresInSec * 1000;
          }
        }, {
          key: "toJSON",
          value: function toJSON() {
            return {
              refreshToken: this.refreshToken,
              accessToken: this.accessToken,
              expirationTime: this.expirationTime
            };
          }
        }, {
          key: "_assign",
          value: function _assign(stsTokenManager) {
            this.accessToken = stsTokenManager.accessToken;
            this.refreshToken = stsTokenManager.refreshToken;
            this.expirationTime = stsTokenManager.expirationTime;
          }
        }, {
          key: "_clone",
          value: function _clone() {
            return Object.assign(new StsTokenManager(), this.toJSON());
          }
        }, {
          key: "_performRefresh",
          value: function _performRefresh() {
            return debugFail('not implemented');
          }
        }], [{
          key: "fromJSON",
          value: function fromJSON(appName, object) {
            var refreshToken = object.refreshToken,
                accessToken = object.accessToken,
                expirationTime = object.expirationTime;
            var manager = new StsTokenManager();

            if (refreshToken) {
              _assert(typeof refreshToken === 'string', "internal-error"
              /* INTERNAL_ERROR */
              , {
                appName: appName
              });

              manager.refreshToken = refreshToken;
            }

            if (accessToken) {
              _assert(typeof accessToken === 'string', "internal-error"
              /* INTERNAL_ERROR */
              , {
                appName: appName
              });

              manager.accessToken = accessToken;
            }

            if (expirationTime) {
              _assert(typeof expirationTime === 'number', "internal-error"
              /* INTERNAL_ERROR */
              , {
                appName: appName
              });

              manager.expirationTime = expirationTime;
            }

            return manager;
          }
        }]);

        return StsTokenManager;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function assertStringOrUndefined(assertion, appName) {
        _assert(typeof assertion === 'string' || typeof assertion === 'undefined', "internal-error"
        /* INTERNAL_ERROR */
        , {
          appName: appName
        });
      }

      var UserImpl = /*#__PURE__*/function () {
        function UserImpl(_a) {
          _classCallCheck(this, UserImpl);

          var uid = _a.uid,
              auth = _a.auth,
              stsTokenManager = _a.stsTokenManager,
              opt = (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, ["uid", "auth", "stsTokenManager"]); // For the user object, provider is always Firebase.

          this.providerId = "firebase"
          /* FIREBASE */
          ;
          this.emailVerified = false;
          this.isAnonymous = false;
          this.tenantId = null;
          this.providerData = [];
          this.proactiveRefresh = new ProactiveRefresh(this);
          this.reloadUserInfo = null;
          this.reloadListener = null;
          this.uid = uid;
          this.auth = auth;
          this.stsTokenManager = stsTokenManager;
          this.accessToken = stsTokenManager.accessToken;
          this.displayName = opt.displayName || null;
          this.email = opt.email || null;
          this.emailVerified = opt.emailVerified || false;
          this.phoneNumber = opt.phoneNumber || null;
          this.photoURL = opt.photoURL || null;
          this.isAnonymous = opt.isAnonymous || false;
          this.tenantId = opt.tenantId || null;
          this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);
        }

        _createClass(UserImpl, [{
          key: "getIdToken",
          value: function () {
            var _getIdToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(forceRefresh) {
              var accessToken;
              return regeneratorRuntime.wrap(function _callee24$(_context24) {
                while (1) {
                  switch (_context24.prev = _context24.next) {
                    case 0:
                      _context24.next = 2;
                      return _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));

                    case 2:
                      accessToken = _context24.sent;

                      _assert(accessToken, this.auth, "internal-error"
                      /* INTERNAL_ERROR */
                      );

                      if (!(this.accessToken !== accessToken)) {
                        _context24.next = 9;
                        break;
                      }

                      this.accessToken = accessToken;
                      _context24.next = 8;
                      return this.auth._persistUserIfCurrent(this);

                    case 8:
                      this.auth._notifyListenersIfCurrent(this);

                    case 9:
                      return _context24.abrupt("return", accessToken);

                    case 10:
                    case "end":
                      return _context24.stop();
                  }
                }
              }, _callee24, this);
            }));

            function getIdToken(_x53) {
              return _getIdToken.apply(this, arguments);
            }

            return getIdToken;
          }()
        }, {
          key: "getIdTokenResult",
          value: function getIdTokenResult(forceRefresh) {
            return _getIdTokenResult2(this, forceRefresh);
          }
        }, {
          key: "reload",
          value: function reload() {
            return _reload2(this);
          }
        }, {
          key: "_assign",
          value: function _assign(user) {
            if (this === user) {
              return;
            }

            _assert(this.uid === user.uid, this.auth, "internal-error"
            /* INTERNAL_ERROR */
            );

            this.displayName = user.displayName;
            this.photoURL = user.photoURL;
            this.email = user.email;
            this.emailVerified = user.emailVerified;
            this.phoneNumber = user.phoneNumber;
            this.isAnonymous = user.isAnonymous;
            this.tenantId = user.tenantId;
            this.providerData = user.providerData.map(function (userInfo) {
              return Object.assign({}, userInfo);
            });

            this.metadata._copy(user.metadata);

            this.stsTokenManager._assign(user.stsTokenManager);
          }
        }, {
          key: "_clone",
          value: function _clone(auth) {
            return new UserImpl(Object.assign(Object.assign({}, this), {
              auth: auth,
              stsTokenManager: this.stsTokenManager._clone()
            }));
          }
        }, {
          key: "_onReload",
          value: function _onReload(callback) {
            // There should only ever be one listener, and that is a single instance of MultiFactorUser
            _assert(!this.reloadListener, this.auth, "internal-error"
            /* INTERNAL_ERROR */
            );

            this.reloadListener = callback;

            if (this.reloadUserInfo) {
              this._notifyReloadListener(this.reloadUserInfo);

              this.reloadUserInfo = null;
            }
          }
        }, {
          key: "_notifyReloadListener",
          value: function _notifyReloadListener(userInfo) {
            if (this.reloadListener) {
              this.reloadListener(userInfo);
            } else {
              // If no listener is subscribed yet, save the result so it's available when they do subscribe
              this.reloadUserInfo = userInfo;
            }
          }
        }, {
          key: "_startProactiveRefresh",
          value: function _startProactiveRefresh() {
            this.proactiveRefresh._start();
          }
        }, {
          key: "_stopProactiveRefresh",
          value: function _stopProactiveRefresh() {
            this.proactiveRefresh._stop();
          }
        }, {
          key: "_updateTokensIfNecessary",
          value: function () {
            var _updateTokensIfNecessary2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(response) {
              var reload,
                  tokensRefreshed,
                  _args25 = arguments;
              return regeneratorRuntime.wrap(function _callee25$(_context25) {
                while (1) {
                  switch (_context25.prev = _context25.next) {
                    case 0:
                      reload = _args25.length > 1 && _args25[1] !== undefined ? _args25[1] : false;
                      tokensRefreshed = false;

                      if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {
                        this.stsTokenManager.updateFromServerResponse(response);
                        tokensRefreshed = true;
                      }

                      if (!reload) {
                        _context25.next = 6;
                        break;
                      }

                      _context25.next = 6;
                      return _reloadWithoutSaving(this);

                    case 6:
                      _context25.next = 8;
                      return this.auth._persistUserIfCurrent(this);

                    case 8:
                      if (tokensRefreshed) {
                        this.auth._notifyListenersIfCurrent(this);
                      }

                    case 9:
                    case "end":
                      return _context25.stop();
                  }
                }
              }, _callee25, this);
            }));

            function _updateTokensIfNecessary(_x54) {
              return _updateTokensIfNecessary2.apply(this, arguments);
            }

            return _updateTokensIfNecessary;
          }()
        }, {
          key: "delete",
          value: function () {
            var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26() {
              var idToken;
              return regeneratorRuntime.wrap(function _callee26$(_context26) {
                while (1) {
                  switch (_context26.prev = _context26.next) {
                    case 0:
                      _context26.next = 2;
                      return this.getIdToken();

                    case 2:
                      idToken = _context26.sent;
                      _context26.next = 5;
                      return _logoutIfInvalidated(this, deleteAccount(this.auth, {
                        idToken: idToken
                      }));

                    case 5:
                      this.stsTokenManager.clearRefreshToken(); // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()
                      //       cancels pending actions...

                      return _context26.abrupt("return", this.auth.signOut());

                    case 7:
                    case "end":
                      return _context26.stop();
                  }
                }
              }, _callee26, this);
            }));

            function _delete() {
              return _delete2.apply(this, arguments);
            }

            return _delete;
          }()
        }, {
          key: "toJSON",
          value: function toJSON() {
            return Object.assign(Object.assign({
              uid: this.uid,
              email: this.email || undefined,
              emailVerified: this.emailVerified,
              displayName: this.displayName || undefined,
              isAnonymous: this.isAnonymous,
              photoURL: this.photoURL || undefined,
              phoneNumber: this.phoneNumber || undefined,
              tenantId: this.tenantId || undefined,
              providerData: this.providerData.map(function (userInfo) {
                return Object.assign({}, userInfo);
              }),
              stsTokenManager: this.stsTokenManager.toJSON(),
              // Redirect event ID must be maintained in case there is a pending
              // redirect event.
              _redirectEventId: this._redirectEventId
            }, this.metadata.toJSON()), {
              // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):
              apiKey: this.auth.config.apiKey,
              appName: this.auth.name
            });
          }
        }, {
          key: "refreshToken",
          get: function get() {
            return this.stsTokenManager.refreshToken || '';
          }
        }], [{
          key: "_fromJSON",
          value: function _fromJSON(auth, object) {
            var _a, _b, _c, _d, _e, _f, _g, _h;

            var displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;
            var email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;
            var phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;
            var photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;
            var tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;

            var _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;

            var createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;
            var lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;
            var uid = object.uid,
                emailVerified = object.emailVerified,
                isAnonymous = object.isAnonymous,
                providerData = object.providerData,
                plainObjectTokenManager = object.stsTokenManager;

            _assert(uid && plainObjectTokenManager, auth, "internal-error"
            /* INTERNAL_ERROR */
            );

            var stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);

            _assert(typeof uid === 'string', auth, "internal-error"
            /* INTERNAL_ERROR */
            );

            assertStringOrUndefined(displayName, auth.name);
            assertStringOrUndefined(email, auth.name);

            _assert(typeof emailVerified === 'boolean', auth, "internal-error"
            /* INTERNAL_ERROR */
            );

            _assert(typeof isAnonymous === 'boolean', auth, "internal-error"
            /* INTERNAL_ERROR */
            );

            assertStringOrUndefined(phoneNumber, auth.name);
            assertStringOrUndefined(photoURL, auth.name);
            assertStringOrUndefined(tenantId, auth.name);
            assertStringOrUndefined(_redirectEventId, auth.name);
            assertStringOrUndefined(createdAt, auth.name);
            assertStringOrUndefined(lastLoginAt, auth.name);
            var user = new UserImpl({
              uid: uid,
              auth: auth,
              email: email,
              emailVerified: emailVerified,
              displayName: displayName,
              isAnonymous: isAnonymous,
              photoURL: photoURL,
              phoneNumber: phoneNumber,
              tenantId: tenantId,
              stsTokenManager: stsTokenManager,
              createdAt: createdAt,
              lastLoginAt: lastLoginAt
            });

            if (providerData && Array.isArray(providerData)) {
              user.providerData = providerData.map(function (userInfo) {
                return Object.assign({}, userInfo);
              });
            }

            if (_redirectEventId) {
              user._redirectEventId = _redirectEventId;
            }

            return user;
          }
          /**
           * Initialize a User from an idToken server response
           * @param auth
           * @param idTokenResponse
           */

        }, {
          key: "_fromIdTokenResponse",
          value: function () {
            var _fromIdTokenResponse2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(auth, idTokenResponse) {
              var isAnonymous,
                  stsTokenManager,
                  user,
                  _args27 = arguments;
              return regeneratorRuntime.wrap(function _callee27$(_context27) {
                while (1) {
                  switch (_context27.prev = _context27.next) {
                    case 0:
                      isAnonymous = _args27.length > 2 && _args27[2] !== undefined ? _args27[2] : false;
                      stsTokenManager = new StsTokenManager();
                      stsTokenManager.updateFromServerResponse(idTokenResponse); // Initialize the Firebase Auth user.

                      user = new UserImpl({
                        uid: idTokenResponse.localId,
                        auth: auth,
                        stsTokenManager: stsTokenManager,
                        isAnonymous: isAnonymous
                      }); // Updates the user info and data and resolves with a user instance.

                      _context27.next = 6;
                      return _reloadWithoutSaving(user);

                    case 6:
                      return _context27.abrupt("return", user);

                    case 7:
                    case "end":
                      return _context27.stop();
                  }
                }
              }, _callee27);
            }));

            function _fromIdTokenResponse(_x55, _x56) {
              return _fromIdTokenResponse2.apply(this, arguments);
            }

            return _fromIdTokenResponse;
          }()
        }]);

        return UserImpl;
      }();
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var InMemoryPersistence = /*#__PURE__*/function () {
        function InMemoryPersistence() {
          _classCallCheck(this, InMemoryPersistence);

          this.type = "NONE"
          /* NONE */
          ;
          this.storage = {};
        }

        _createClass(InMemoryPersistence, [{
          key: "_isAvailable",
          value: function () {
            var _isAvailable2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28() {
              return regeneratorRuntime.wrap(function _callee28$(_context28) {
                while (1) {
                  switch (_context28.prev = _context28.next) {
                    case 0:
                      return _context28.abrupt("return", true);

                    case 1:
                    case "end":
                      return _context28.stop();
                  }
                }
              }, _callee28);
            }));

            function _isAvailable() {
              return _isAvailable2.apply(this, arguments);
            }

            return _isAvailable;
          }()
        }, {
          key: "_set",
          value: function () {
            var _set2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(key, value) {
              return regeneratorRuntime.wrap(function _callee29$(_context29) {
                while (1) {
                  switch (_context29.prev = _context29.next) {
                    case 0:
                      this.storage[key] = value;

                    case 1:
                    case "end":
                      return _context29.stop();
                  }
                }
              }, _callee29, this);
            }));

            function _set(_x57, _x58) {
              return _set2.apply(this, arguments);
            }

            return _set;
          }()
        }, {
          key: "_get",
          value: function () {
            var _get2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(key) {
              var value;
              return regeneratorRuntime.wrap(function _callee30$(_context30) {
                while (1) {
                  switch (_context30.prev = _context30.next) {
                    case 0:
                      value = this.storage[key];
                      return _context30.abrupt("return", value === undefined ? null : value);

                    case 2:
                    case "end":
                      return _context30.stop();
                  }
                }
              }, _callee30, this);
            }));

            function _get(_x59) {
              return _get2.apply(this, arguments);
            }

            return _get;
          }()
        }, {
          key: "_remove",
          value: function () {
            var _remove2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(key) {
              return regeneratorRuntime.wrap(function _callee31$(_context31) {
                while (1) {
                  switch (_context31.prev = _context31.next) {
                    case 0:
                      delete this.storage[key];

                    case 1:
                    case "end":
                      return _context31.stop();
                  }
                }
              }, _callee31, this);
            }));

            function _remove(_x60) {
              return _remove2.apply(this, arguments);
            }

            return _remove;
          }()
        }, {
          key: "_addListener",
          value: function _addListener(_key, _listener) {
            // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers
            return;
          }
        }, {
          key: "_removeListener",
          value: function _removeListener(_key, _listener) {
            // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers
            return;
          }
        }]);

        return InMemoryPersistence;
      }();

      InMemoryPersistence.type = 'NONE';
      /**
       * An implementation of {@link Persistence} of type 'NONE'.
       *
       * @public
       */

      var inMemoryPersistence = InMemoryPersistence;
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      function _persistenceKeyName(key, apiKey, appName) {
        return "firebase"
        /* PERSISTENCE */
        .concat(":", key, ":").concat(apiKey, ":").concat(appName);
      }

      var PersistenceUserManager = /*#__PURE__*/function () {
        function PersistenceUserManager(persistence, auth, userKey) {
          _classCallCheck(this, PersistenceUserManager);

          this.persistence = persistence;
          this.auth = auth;
          this.userKey = userKey;
          var _this$auth = this.auth,
              config = _this$auth.config,
              name = _this$auth.name;
          this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);
          this.fullPersistenceKey = _persistenceKeyName("persistence"
          /* PERSISTENCE_USER */
          , config.apiKey, name);
          this.boundEventHandler = auth._onStorageEvent.bind(auth);

          this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
        }

        _createClass(PersistenceUserManager, [{
          key: "setCurrentUser",
          value: function setCurrentUser(user) {
            return this.persistence._set(this.fullUserKey, user.toJSON());
          }
        }, {
          key: "getCurrentUser",
          value: function () {
            var _getCurrentUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32() {
              var blob;
              return regeneratorRuntime.wrap(function _callee32$(_context32) {
                while (1) {
                  switch (_context32.prev = _context32.next) {
                    case 0:
                      _context32.next = 2;
                      return this.persistence._get(this.fullUserKey);

                    case 2:
                      blob = _context32.sent;
                      return _context32.abrupt("return", blob ? UserImpl._fromJSON(this.auth, blob) : null);

                    case 4:
                    case "end":
                      return _context32.stop();
                  }
                }
              }, _callee32, this);
            }));

            function getCurrentUser() {
              return _getCurrentUser.apply(this, arguments);
            }

            return getCurrentUser;
          }()
        }, {
          key: "removeCurrentUser",
          value: function removeCurrentUser() {
            return this.persistence._remove(this.fullUserKey);
          }
        }, {
          key: "savePersistenceForRedirect",
          value: function savePersistenceForRedirect() {
            return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
          }
        }, {
          key: "setPersistence",
          value: function () {
            var _setPersistence2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(newPersistence) {
              var currentUser;
              return regeneratorRuntime.wrap(function _callee33$(_context33) {
                while (1) {
                  switch (_context33.prev = _context33.next) {
                    case 0:
                      if (!(this.persistence === newPersistence)) {
                        _context33.next = 2;
                        break;
                      }

                      return _context33.abrupt("return");

                    case 2:
                      _context33.next = 4;
                      return this.getCurrentUser();

                    case 4:
                      currentUser = _context33.sent;
                      _context33.next = 7;
                      return this.removeCurrentUser();

                    case 7:
                      this.persistence = newPersistence;

                      if (!currentUser) {
                        _context33.next = 10;
                        break;
                      }

                      return _context33.abrupt("return", this.setCurrentUser(currentUser));

                    case 10:
                    case "end":
                      return _context33.stop();
                  }
                }
              }, _callee33, this);
            }));

            function setPersistence(_x61) {
              return _setPersistence2.apply(this, arguments);
            }

            return setPersistence;
          }()
        }, {
          key: "delete",
          value: function _delete() {
            this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
          }
        }], [{
          key: "create",
          value: function () {
            var _create = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(auth, persistenceHierarchy) {
              var userKey,
                  availablePersistences,
                  selectedPersistence,
                  key,
                  userToMigrate,
                  _iterator,
                  _step,
                  persistence,
                  blob,
                  user,
                  migrationHierarchy,
                  _args36 = arguments;

              return regeneratorRuntime.wrap(function _callee36$(_context36) {
                while (1) {
                  switch (_context36.prev = _context36.next) {
                    case 0:
                      userKey = _args36.length > 2 && _args36[2] !== undefined ? _args36[2] : "authUser";

                      if (persistenceHierarchy.length) {
                        _context36.next = 3;
                        break;
                      }

                      return _context36.abrupt("return", new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey));

                    case 3:
                      _context36.next = 5;
                      return Promise.all(persistenceHierarchy.map( /*#__PURE__*/function () {
                        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(persistence) {
                          return regeneratorRuntime.wrap(function _callee34$(_context34) {
                            while (1) {
                              switch (_context34.prev = _context34.next) {
                                case 0:
                                  _context34.next = 2;
                                  return persistence._isAvailable();

                                case 2:
                                  if (!_context34.sent) {
                                    _context34.next = 4;
                                    break;
                                  }

                                  return _context34.abrupt("return", persistence);

                                case 4:
                                  return _context34.abrupt("return", undefined);

                                case 5:
                                case "end":
                                  return _context34.stop();
                              }
                            }
                          }, _callee34);
                        }));

                        return function (_x64) {
                          return _ref6.apply(this, arguments);
                        };
                      }()));

                    case 5:
                      availablePersistences = _context36.sent.filter(function (persistence) {
                        return persistence;
                      });
                      // Fall back to the first persistence listed, or in memory if none available
                      selectedPersistence = availablePersistences[0] || _getInstance(inMemoryPersistence);
                      key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name); // Pull out the existing user, setting the chosen persistence to that
                      // persistence if the user exists.

                      userToMigrate = null; // Note, here we check for a user in _all_ persistences, not just the
                      // ones deemed available. If we can migrate a user out of a broken
                      // persistence, we will (but only if that persistence supports migration).

                      _iterator = _createForOfIteratorHelper(persistenceHierarchy);
                      _context36.prev = 10;

                      _iterator.s();

                    case 12:
                      if ((_step = _iterator.n()).done) {
                        _context36.next = 29;
                        break;
                      }

                      persistence = _step.value;
                      _context36.prev = 14;
                      _context36.next = 17;
                      return persistence._get(key);

                    case 17:
                      blob = _context36.sent;

                      if (!blob) {
                        _context36.next = 23;
                        break;
                      }

                      user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)

                      if (persistence !== selectedPersistence) {
                        userToMigrate = user;
                      }

                      selectedPersistence = persistence;
                      return _context36.abrupt("break", 29);

                    case 23:
                      _context36.next = 27;
                      break;

                    case 25:
                      _context36.prev = 25;
                      _context36.t0 = _context36["catch"](14);

                    case 27:
                      _context36.next = 12;
                      break;

                    case 29:
                      _context36.next = 34;
                      break;

                    case 31:
                      _context36.prev = 31;
                      _context36.t1 = _context36["catch"](10);

                      _iterator.e(_context36.t1);

                    case 34:
                      _context36.prev = 34;

                      _iterator.f();

                      return _context36.finish(34);

                    case 37:
                      // If we find the user in a persistence that does support migration, use
                      // that migration path (of only persistences that support migration)
                      migrationHierarchy = availablePersistences.filter(function (p) {
                        return p._shouldAllowMigration;
                      }); // If the persistence does _not_ allow migration, just finish off here

                      if (!(!selectedPersistence._shouldAllowMigration || !migrationHierarchy.length)) {
                        _context36.next = 40;
                        break;
                      }

                      return _context36.abrupt("return", new PersistenceUserManager(selectedPersistence, auth, userKey));

                    case 40:
                      selectedPersistence = migrationHierarchy[0];

                      if (!userToMigrate) {
                        _context36.next = 44;
                        break;
                      }

                      _context36.next = 44;
                      return selectedPersistence._set(key, userToMigrate.toJSON());

                    case 44:
                      _context36.next = 46;
                      return Promise.all(persistenceHierarchy.map( /*#__PURE__*/function () {
                        var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(persistence) {
                          return regeneratorRuntime.wrap(function _callee35$(_context35) {
                            while (1) {
                              switch (_context35.prev = _context35.next) {
                                case 0:
                                  if (!(persistence !== selectedPersistence)) {
                                    _context35.next = 8;
                                    break;
                                  }

                                  _context35.prev = 1;
                                  _context35.next = 4;
                                  return persistence._remove(key);

                                case 4:
                                  _context35.next = 8;
                                  break;

                                case 6:
                                  _context35.prev = 6;
                                  _context35.t0 = _context35["catch"](1);

                                case 8:
                                case "end":
                                  return _context35.stop();
                              }
                            }
                          }, _callee35, null, [[1, 6]]);
                        }));

                        return function (_x65) {
                          return _ref7.apply(this, arguments);
                        };
                      }()));

                    case 46:
                      return _context36.abrupt("return", new PersistenceUserManager(selectedPersistence, auth, userKey));

                    case 47:
                    case "end":
                      return _context36.stop();
                  }
                }
              }, _callee36, null, [[10, 31, 34, 37], [14, 25]]);
            }));

            function create(_x62, _x63) {
              return _create.apply(this, arguments);
            }

            return create;
          }()
        }]);

        return PersistenceUserManager;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Determine the browser for the purposes of reporting usage to the API
       */


      function _getBrowserName(userAgent) {
        var ua = userAgent.toLowerCase();

        if (ua.includes('opera/') || ua.includes('opr/') || ua.includes('opios/')) {
          return "Opera"
          /* OPERA */
          ;
        } else if (_isIEMobile(ua)) {
          // Windows phone IEMobile browser.
          return "IEMobile"
          /* IEMOBILE */
          ;
        } else if (ua.includes('msie') || ua.includes('trident/')) {
          return "IE"
          /* IE */
          ;
        } else if (ua.includes('edge/')) {
          return "Edge"
          /* EDGE */
          ;
        } else if (_isFirefox(ua)) {
          return "Firefox"
          /* FIREFOX */
          ;
        } else if (ua.includes('silk/')) {
          return "Silk"
          /* SILK */
          ;
        } else if (_isBlackBerry(ua)) {
          // Blackberry browser.
          return "Blackberry"
          /* BLACKBERRY */
          ;
        } else if (_isWebOS(ua)) {
          // WebOS default browser.
          return "Webos"
          /* WEBOS */
          ;
        } else if (_isSafari(ua)) {
          return "Safari"
          /* SAFARI */
          ;
        } else if ((ua.includes('chrome/') || _isChromeIOS(ua)) && !ua.includes('edge/')) {
          return "Chrome"
          /* CHROME */
          ;
        } else if (_isAndroid(ua)) {
          // Android stock browser.
          return "Android"
          /* ANDROID */
          ;
        } else {
          // Most modern browsers have name/version at end of user agent string.
          var re = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
          var matches = userAgent.match(re);

          if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {
            return matches[1];
          }
        }

        return "Other"
        /* OTHER */
        ;
      }

      function _isFirefox() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        return /firefox\//i.test(ua);
      }

      function _isSafari() {
        var userAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        var ua = userAgent.toLowerCase();
        return ua.includes('safari/') && !ua.includes('chrome/') && !ua.includes('crios/') && !ua.includes('android');
      }

      function _isChromeIOS() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        return /crios\//i.test(ua);
      }

      function _isIEMobile() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        return /iemobile/i.test(ua);
      }

      function _isAndroid() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        return /android/i.test(ua);
      }

      function _isBlackBerry() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        return /blackberry/i.test(ua);
      }

      function _isWebOS() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        return /webos/i.test(ua);
      }

      function _isIOS() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        return /iphone|ipad|ipod/i.test(ua);
      }

      function _isIOS7Or8() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        return /(iPad|iPhone|iPod).*OS 7_\d/i.test(ua) || /(iPad|iPhone|iPod).*OS 8_\d/i.test(ua);
      }

      function _isIOSStandalone() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();

        var _a;

        return _isIOS(ua) && !!((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.standalone);
      }

      function _isIE10() {
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.isIE)() && document.documentMode === 10;
      }

      function _isMobileBrowser() {
        var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        // TODO: implement getBrowserName equivalent for OS.
        return _isIOS(ua) || _isAndroid(ua) || _isWebOS(ua) || _isBlackBerry(ua) || /windows phone/i.test(ua) || _isIEMobile(ua);
      }

      function _isIframe() {
        try {
          // Check that the current window is not the top window.
          // If so, return true.
          return !!(window && window !== window.top);
        } catch (e) {
          return false;
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /*
       * Determine the SDK version string
       */


      function _getClientVersion(clientPlatform) {
        var frameworks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var reportedPlatform;

        switch (clientPlatform) {
          case "Browser"
          /* BROWSER */
          :
            // In a browser environment, report the browser name.
            reportedPlatform = _getBrowserName((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)());
            break;

          case "Worker"
          /* WORKER */
          :
            // Technically a worker runs from a browser but we need to differentiate a
            // worker from a browser.
            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.
            reportedPlatform = "".concat(_getBrowserName((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)()), "-").concat(clientPlatform);
            break;

          default:
            reportedPlatform = clientPlatform;
        }

        var reportedFrameworks = frameworks.length ? frameworks.join(',') : 'FirebaseCore-web';
        /* default value if no other framework is used */

        return "".concat(reportedPlatform, "/", "JsCore"
        /* CORE */
        , "/").concat(_firebase_app__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION, "/").concat(reportedFrameworks);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var AuthImpl = /*#__PURE__*/function () {
        function AuthImpl(app, config) {
          _classCallCheck(this, AuthImpl);

          this.app = app;
          this.config = config;
          this.currentUser = null;
          this.emulatorConfig = null;
          this.operations = Promise.resolve();
          this.authStateSubscription = new Subscription(this);
          this.idTokenSubscription = new Subscription(this);
          this.redirectUser = null;
          this.isProactiveRefreshEnabled = false; // Any network calls will set this to true and prevent subsequent emulator
          // initialization

          this._canInitEmulator = true;
          this._isInitialized = false;
          this._deleted = false;
          this._initializationPromise = null;
          this._popupRedirectResolver = null;
          this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY; // Tracks the last notified UID for state change listeners to prevent
          // repeated calls to the callbacks. Undefined means it's never been
          // called, whereas null means it's been called with a signed out user

          this.lastNotifiedUid = undefined;
          this.languageCode = null;
          this.tenantId = null;
          this.settings = {
            appVerificationDisabledForTesting: false
          };
          this.frameworks = [];
          this.name = app.name;
          this.clientVersion = config.sdkClientVersion;
        }

        _createClass(AuthImpl, [{
          key: "_initializeWithPersistence",
          value: function _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {
            var _this4 = this;

            if (popupRedirectResolver) {
              this._popupRedirectResolver = _getInstance(popupRedirectResolver);
            } // Have to check for app deletion throughout initialization (after each
            // promise resolution)


            this._initializationPromise = this.queue( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37() {
              var _a, _b;

              return regeneratorRuntime.wrap(function _callee37$(_context37) {
                while (1) {
                  switch (_context37.prev = _context37.next) {
                    case 0:
                      if (!_this4._deleted) {
                        _context37.next = 2;
                        break;
                      }

                      return _context37.abrupt("return");

                    case 2:
                      _context37.next = 4;
                      return PersistenceUserManager.create(_this4, persistenceHierarchy);

                    case 4:
                      _this4.persistenceManager = _context37.sent;

                      if (!_this4._deleted) {
                        _context37.next = 7;
                        break;
                      }

                      return _context37.abrupt("return");

                    case 7:
                      if (!((_a = _this4._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively)) {
                        _context37.next = 10;
                        break;
                      }

                      _context37.next = 10;
                      return _this4._popupRedirectResolver._initialize(_this4);

                    case 10:
                      _context37.next = 12;
                      return _this4.initializeCurrentUser(popupRedirectResolver);

                    case 12:
                      _this4.lastNotifiedUid = ((_b = _this4.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;

                      if (!_this4._deleted) {
                        _context37.next = 15;
                        break;
                      }

                      return _context37.abrupt("return");

                    case 15:
                      _this4._isInitialized = true;

                    case 16:
                    case "end":
                      return _context37.stop();
                  }
                }
              }, _callee37);
            })));
            return this._initializationPromise;
          }
          /**
           * If the persistence is changed in another window, the user manager will let us know
           */

        }, {
          key: "_onStorageEvent",
          value: function () {
            var _onStorageEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38() {
              var user;
              return regeneratorRuntime.wrap(function _callee38$(_context38) {
                while (1) {
                  switch (_context38.prev = _context38.next) {
                    case 0:
                      if (!this._deleted) {
                        _context38.next = 2;
                        break;
                      }

                      return _context38.abrupt("return");

                    case 2:
                      _context38.next = 4;
                      return this.assertedPersistence.getCurrentUser();

                    case 4:
                      user = _context38.sent;

                      if (!(!this.currentUser && !user)) {
                        _context38.next = 7;
                        break;
                      }

                      return _context38.abrupt("return");

                    case 7:
                      if (!(this.currentUser && user && this.currentUser.uid === user.uid)) {
                        _context38.next = 12;
                        break;
                      }

                      // Data update, simply copy data changes.
                      this._currentUser._assign(user); // If tokens changed from previous user tokens, this will trigger
                      // notifyAuthListeners_.


                      _context38.next = 11;
                      return this.currentUser.getIdToken();

                    case 11:
                      return _context38.abrupt("return");

                    case 12:
                      _context38.next = 14;
                      return this._updateCurrentUser(user);

                    case 14:
                    case "end":
                      return _context38.stop();
                  }
                }
              }, _callee38, this);
            }));

            function _onStorageEvent() {
              return _onStorageEvent2.apply(this, arguments);
            }

            return _onStorageEvent;
          }()
        }, {
          key: "initializeCurrentUser",
          value: function () {
            var _initializeCurrentUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(popupRedirectResolver) {
              var _a, storedUser, redirectUserEventId, storedUserEventId, result;

              return regeneratorRuntime.wrap(function _callee39$(_context39) {
                while (1) {
                  switch (_context39.prev = _context39.next) {
                    case 0:
                      _context39.next = 2;
                      return this.assertedPersistence.getCurrentUser();

                    case 2:
                      storedUser = _context39.sent;

                      if (!(popupRedirectResolver && this.config.authDomain)) {
                        _context39.next = 12;
                        break;
                      }

                      _context39.next = 6;
                      return this.getOrInitRedirectPersistenceManager();

                    case 6:
                      redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;
                      storedUserEventId = storedUser === null || storedUser === void 0 ? void 0 : storedUser._redirectEventId;
                      _context39.next = 10;
                      return this.tryRedirectSignIn(popupRedirectResolver);

                    case 10:
                      result = _context39.sent;

                      // If the stored user (i.e. the old "currentUser") has a redirectId that
                      // matches the redirect user, then we want to initially sign in with the
                      // new user object from result.
                      // TODO(samgho): More thoroughly test all of this
                      if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {
                        storedUser = result.user;
                      }

                    case 12:
                      if (storedUser) {
                        _context39.next = 14;
                        break;
                      }

                      return _context39.abrupt("return", this.directlySetCurrentUser(null));

                    case 14:
                      if (storedUser._redirectEventId) {
                        _context39.next = 16;
                        break;
                      }

                      return _context39.abrupt("return", this.reloadAndSetCurrentUserOrClear(storedUser));

                    case 16:
                      _assert(this._popupRedirectResolver, this, "argument-error"
                      /* ARGUMENT_ERROR */
                      );

                      _context39.next = 19;
                      return this.getOrInitRedirectPersistenceManager();

                    case 19:
                      if (!(this.redirectUser && this.redirectUser._redirectEventId === storedUser._redirectEventId)) {
                        _context39.next = 21;
                        break;
                      }

                      return _context39.abrupt("return", this.directlySetCurrentUser(storedUser));

                    case 21:
                      return _context39.abrupt("return", this.reloadAndSetCurrentUserOrClear(storedUser));

                    case 22:
                    case "end":
                      return _context39.stop();
                  }
                }
              }, _callee39, this);
            }));

            function initializeCurrentUser(_x66) {
              return _initializeCurrentUser.apply(this, arguments);
            }

            return initializeCurrentUser;
          }()
        }, {
          key: "tryRedirectSignIn",
          value: function () {
            var _tryRedirectSignIn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(redirectResolver) {
              var result;
              return regeneratorRuntime.wrap(function _callee40$(_context40) {
                while (1) {
                  switch (_context40.prev = _context40.next) {
                    case 0:
                      // The redirect user needs to be checked (and signed in if available)
                      // during auth initialization. All of the normal sign in and link/reauth
                      // flows call back into auth and push things onto the promise queue. We
                      // need to await the result of the redirect sign in *inside the promise
                      // queue*. This presents a problem: we run into deadlock. See:
                      //    ┌> [Initialization] ─────┐
                      //    ┌> [<other queue tasks>] │
                      //    └─ [getRedirectResult] <─┘
                      //    where [] are tasks on the queue and arrows denote awaits
                      // Initialization will never complete because it's waiting on something
                      // that's waiting for initialization to complete!
                      //
                      // Instead, this method calls getRedirectResult() (stored in
                      // _completeRedirectFn) with an optional parameter that instructs all of
                      // the underlying auth operations to skip anything that mutates auth state.
                      result = null;
                      _context40.prev = 1;
                      _context40.next = 4;
                      return this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);

                    case 4:
                      result = _context40.sent;
                      _context40.next = 11;
                      break;

                    case 7:
                      _context40.prev = 7;
                      _context40.t0 = _context40["catch"](1);
                      _context40.next = 11;
                      return this._setRedirectUser(null);

                    case 11:
                      return _context40.abrupt("return", result);

                    case 12:
                    case "end":
                      return _context40.stop();
                  }
                }
              }, _callee40, this, [[1, 7]]);
            }));

            function tryRedirectSignIn(_x67) {
              return _tryRedirectSignIn.apply(this, arguments);
            }

            return tryRedirectSignIn;
          }()
        }, {
          key: "reloadAndSetCurrentUserOrClear",
          value: function () {
            var _reloadAndSetCurrentUserOrClear = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(user) {
              return regeneratorRuntime.wrap(function _callee41$(_context41) {
                while (1) {
                  switch (_context41.prev = _context41.next) {
                    case 0:
                      _context41.prev = 0;
                      _context41.next = 3;
                      return _reloadWithoutSaving(user);

                    case 3:
                      _context41.next = 9;
                      break;

                    case 5:
                      _context41.prev = 5;
                      _context41.t0 = _context41["catch"](0);

                      if (!(_context41.t0.code !== "auth/".concat("network-request-failed"
                      /* NETWORK_REQUEST_FAILED */
                      ))) {
                        _context41.next = 9;
                        break;
                      }

                      return _context41.abrupt("return", this.directlySetCurrentUser(null));

                    case 9:
                      return _context41.abrupt("return", this.directlySetCurrentUser(user));

                    case 10:
                    case "end":
                      return _context41.stop();
                  }
                }
              }, _callee41, this, [[0, 5]]);
            }));

            function reloadAndSetCurrentUserOrClear(_x68) {
              return _reloadAndSetCurrentUserOrClear.apply(this, arguments);
            }

            return reloadAndSetCurrentUserOrClear;
          }()
        }, {
          key: "useDeviceLanguage",
          value: function useDeviceLanguage() {
            this.languageCode = _getUserLanguage();
          }
        }, {
          key: "_delete",
          value: function () {
            var _delete3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42() {
              return regeneratorRuntime.wrap(function _callee42$(_context42) {
                while (1) {
                  switch (_context42.prev = _context42.next) {
                    case 0:
                      this._deleted = true;

                    case 1:
                    case "end":
                      return _context42.stop();
                  }
                }
              }, _callee42, this);
            }));

            function _delete() {
              return _delete3.apply(this, arguments);
            }

            return _delete;
          }()
        }, {
          key: "updateCurrentUser",
          value: function () {
            var _updateCurrentUser2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee43(userExtern) {
              var user;
              return regeneratorRuntime.wrap(function _callee43$(_context43) {
                while (1) {
                  switch (_context43.prev = _context43.next) {
                    case 0:
                      // The public updateCurrentUser method needs to make a copy of the user,
                      // and also check that the project matches
                      user = userExtern ? (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(userExtern) : null;

                      if (user) {
                        _assert(user.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"
                        /* INVALID_AUTH */
                        );
                      }

                      return _context43.abrupt("return", this._updateCurrentUser(user && user._clone(this)));

                    case 3:
                    case "end":
                      return _context43.stop();
                  }
                }
              }, _callee43, this);
            }));

            function updateCurrentUser(_x69) {
              return _updateCurrentUser2.apply(this, arguments);
            }

            return updateCurrentUser;
          }()
        }, {
          key: "_updateCurrentUser",
          value: function () {
            var _updateCurrentUser3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee45(user) {
              var _this5 = this;

              return regeneratorRuntime.wrap(function _callee45$(_context45) {
                while (1) {
                  switch (_context45.prev = _context45.next) {
                    case 0:
                      if (!this._deleted) {
                        _context45.next = 2;
                        break;
                      }

                      return _context45.abrupt("return");

                    case 2:
                      if (user) {
                        _assert(this.tenantId === user.tenantId, this, "tenant-id-mismatch"
                        /* TENANT_ID_MISMATCH */
                        );
                      }

                      return _context45.abrupt("return", this.queue( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee44() {
                        return regeneratorRuntime.wrap(function _callee44$(_context44) {
                          while (1) {
                            switch (_context44.prev = _context44.next) {
                              case 0:
                                _context44.next = 2;
                                return _this5.directlySetCurrentUser(user);

                              case 2:
                                _this5.notifyAuthListeners();

                              case 3:
                              case "end":
                                return _context44.stop();
                            }
                          }
                        }, _callee44);
                      }))));

                    case 4:
                    case "end":
                      return _context45.stop();
                  }
                }
              }, _callee45, this);
            }));

            function _updateCurrentUser(_x70) {
              return _updateCurrentUser3.apply(this, arguments);
            }

            return _updateCurrentUser;
          }()
        }, {
          key: "signOut",
          value: function () {
            var _signOut = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee46() {
              return regeneratorRuntime.wrap(function _callee46$(_context46) {
                while (1) {
                  switch (_context46.prev = _context46.next) {
                    case 0:
                      if (!(this.redirectPersistenceManager || this._popupRedirectResolver)) {
                        _context46.next = 3;
                        break;
                      }

                      _context46.next = 3;
                      return this._setRedirectUser(null);

                    case 3:
                      return _context46.abrupt("return", this._updateCurrentUser(null));

                    case 4:
                    case "end":
                      return _context46.stop();
                  }
                }
              }, _callee46, this);
            }));

            function signOut() {
              return _signOut.apply(this, arguments);
            }

            return signOut;
          }()
        }, {
          key: "setPersistence",
          value: function setPersistence(persistence) {
            var _this6 = this;

            return this.queue( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee47() {
              return regeneratorRuntime.wrap(function _callee47$(_context47) {
                while (1) {
                  switch (_context47.prev = _context47.next) {
                    case 0:
                      _context47.next = 2;
                      return _this6.assertedPersistence.setPersistence(_getInstance(persistence));

                    case 2:
                    case "end":
                      return _context47.stop();
                  }
                }
              }, _callee47);
            })));
          }
        }, {
          key: "_getPersistence",
          value: function _getPersistence() {
            return this.assertedPersistence.persistence.type;
          }
        }, {
          key: "_updateErrorMap",
          value: function _updateErrorMap(errorMap) {
            this._errorFactory = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.ErrorFactory('auth', 'Firebase', errorMap());
          }
        }, {
          key: "onAuthStateChanged",
          value: function onAuthStateChanged(nextOrObserver, error, completed) {
            return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);
          }
        }, {
          key: "onIdTokenChanged",
          value: function onIdTokenChanged(nextOrObserver, error, completed) {
            return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);
          }
        }, {
          key: "toJSON",
          value: function toJSON() {
            var _a;

            return {
              apiKey: this.config.apiKey,
              authDomain: this.config.authDomain,
              appName: this.name,
              currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()
            };
          }
        }, {
          key: "_setRedirectUser",
          value: function () {
            var _setRedirectUser2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee48(user, popupRedirectResolver) {
              var redirectManager;
              return regeneratorRuntime.wrap(function _callee48$(_context48) {
                while (1) {
                  switch (_context48.prev = _context48.next) {
                    case 0:
                      _context48.next = 2;
                      return this.getOrInitRedirectPersistenceManager(popupRedirectResolver);

                    case 2:
                      redirectManager = _context48.sent;
                      return _context48.abrupt("return", user === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user));

                    case 4:
                    case "end":
                      return _context48.stop();
                  }
                }
              }, _callee48, this);
            }));

            function _setRedirectUser(_x71, _x72) {
              return _setRedirectUser2.apply(this, arguments);
            }

            return _setRedirectUser;
          }()
        }, {
          key: "getOrInitRedirectPersistenceManager",
          value: function () {
            var _getOrInitRedirectPersistenceManager = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee49(popupRedirectResolver) {
              var resolver;
              return regeneratorRuntime.wrap(function _callee49$(_context49) {
                while (1) {
                  switch (_context49.prev = _context49.next) {
                    case 0:
                      if (this.redirectPersistenceManager) {
                        _context49.next = 9;
                        break;
                      }

                      resolver = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;

                      _assert(resolver, this, "argument-error"
                      /* ARGUMENT_ERROR */
                      );

                      _context49.next = 5;
                      return PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], "redirectUser"
                      /* REDIRECT_USER */
                      );

                    case 5:
                      this.redirectPersistenceManager = _context49.sent;
                      _context49.next = 8;
                      return this.redirectPersistenceManager.getCurrentUser();

                    case 8:
                      this.redirectUser = _context49.sent;

                    case 9:
                      return _context49.abrupt("return", this.redirectPersistenceManager);

                    case 10:
                    case "end":
                      return _context49.stop();
                  }
                }
              }, _callee49, this);
            }));

            function getOrInitRedirectPersistenceManager(_x73) {
              return _getOrInitRedirectPersistenceManager.apply(this, arguments);
            }

            return getOrInitRedirectPersistenceManager;
          }()
        }, {
          key: "_redirectUserForId",
          value: function () {
            var _redirectUserForId2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee51(id) {
              var _a, _b;

              return regeneratorRuntime.wrap(function _callee51$(_context51) {
                while (1) {
                  switch (_context51.prev = _context51.next) {
                    case 0:
                      if (!this._isInitialized) {
                        _context51.next = 3;
                        break;
                      }

                      _context51.next = 3;
                      return this.queue( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee50() {
                        return regeneratorRuntime.wrap(function _callee50$(_context50) {
                          while (1) {
                            switch (_context50.prev = _context50.next) {
                              case 0:
                              case "end":
                                return _context50.stop();
                            }
                          }
                        }, _callee50);
                      })));

                    case 3:
                      if (!(((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id)) {
                        _context51.next = 5;
                        break;
                      }

                      return _context51.abrupt("return", this._currentUser);

                    case 5:
                      if (!(((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id)) {
                        _context51.next = 7;
                        break;
                      }

                      return _context51.abrupt("return", this.redirectUser);

                    case 7:
                      return _context51.abrupt("return", null);

                    case 8:
                    case "end":
                      return _context51.stop();
                  }
                }
              }, _callee51, this);
            }));

            function _redirectUserForId(_x74) {
              return _redirectUserForId2.apply(this, arguments);
            }

            return _redirectUserForId;
          }()
        }, {
          key: "_persistUserIfCurrent",
          value: function () {
            var _persistUserIfCurrent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee53(user) {
              var _this7 = this;

              return regeneratorRuntime.wrap(function _callee53$(_context53) {
                while (1) {
                  switch (_context53.prev = _context53.next) {
                    case 0:
                      if (!(user === this.currentUser)) {
                        _context53.next = 2;
                        break;
                      }

                      return _context53.abrupt("return", this.queue( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee52() {
                        return regeneratorRuntime.wrap(function _callee52$(_context52) {
                          while (1) {
                            switch (_context52.prev = _context52.next) {
                              case 0:
                                return _context52.abrupt("return", _this7.directlySetCurrentUser(user));

                              case 1:
                              case "end":
                                return _context52.stop();
                            }
                          }
                        }, _callee52);
                      }))));

                    case 2:
                    case "end":
                      return _context53.stop();
                  }
                }
              }, _callee53, this);
            }));

            function _persistUserIfCurrent(_x75) {
              return _persistUserIfCurrent2.apply(this, arguments);
            }

            return _persistUserIfCurrent;
          }()
          /** Notifies listeners only if the user is current */

        }, {
          key: "_notifyListenersIfCurrent",
          value: function _notifyListenersIfCurrent(user) {
            if (user === this.currentUser) {
              this.notifyAuthListeners();
            }
          }
        }, {
          key: "_key",
          value: function _key() {
            return "".concat(this.config.authDomain, ":").concat(this.config.apiKey, ":").concat(this.name);
          }
        }, {
          key: "_startProactiveRefresh",
          value: function _startProactiveRefresh() {
            this.isProactiveRefreshEnabled = true;

            if (this.currentUser) {
              this._currentUser._startProactiveRefresh();
            }
          }
        }, {
          key: "_stopProactiveRefresh",
          value: function _stopProactiveRefresh() {
            this.isProactiveRefreshEnabled = false;

            if (this.currentUser) {
              this._currentUser._stopProactiveRefresh();
            }
          }
          /** Returns the current user cast as the internal type */

        }, {
          key: "_currentUser",
          get: function get() {
            return this.currentUser;
          }
        }, {
          key: "notifyAuthListeners",
          value: function notifyAuthListeners() {
            var _a, _b;

            if (!this._isInitialized) {
              return;
            }

            this.idTokenSubscription.next(this.currentUser);
            var currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;

            if (this.lastNotifiedUid !== currentUid) {
              this.lastNotifiedUid = currentUid;
              this.authStateSubscription.next(this.currentUser);
            }
          }
        }, {
          key: "registerStateListener",
          value: function registerStateListener(subscription, nextOrObserver, error, completed) {
            var _this8 = this;

            if (this._deleted) {
              return function () {};
            }

            var cb = typeof nextOrObserver === 'function' ? nextOrObserver : nextOrObserver.next.bind(nextOrObserver);
            var promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;

            _assert(promise, this, "internal-error"
            /* INTERNAL_ERROR */
            ); // The callback needs to be called asynchronously per the spec.
            // eslint-disable-next-line @typescript-eslint/no-floating-promises


            promise.then(function () {
              return cb(_this8.currentUser);
            });

            if (typeof nextOrObserver === 'function') {
              return subscription.addObserver(nextOrObserver, error, completed);
            } else {
              return subscription.addObserver(nextOrObserver);
            }
          }
          /**
           * Unprotected (from race conditions) method to set the current user. This
           * should only be called from within a queued callback. This is necessary
           * because the queue shouldn't rely on another queued callback.
           */

        }, {
          key: "directlySetCurrentUser",
          value: function () {
            var _directlySetCurrentUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee54(user) {
              return regeneratorRuntime.wrap(function _callee54$(_context54) {
                while (1) {
                  switch (_context54.prev = _context54.next) {
                    case 0:
                      if (this.currentUser && this.currentUser !== user) {
                        this._currentUser._stopProactiveRefresh();

                        if (user && this.isProactiveRefreshEnabled) {
                          user._startProactiveRefresh();
                        }
                      }

                      this.currentUser = user;

                      if (!user) {
                        _context54.next = 7;
                        break;
                      }

                      _context54.next = 5;
                      return this.assertedPersistence.setCurrentUser(user);

                    case 5:
                      _context54.next = 9;
                      break;

                    case 7:
                      _context54.next = 9;
                      return this.assertedPersistence.removeCurrentUser();

                    case 9:
                    case "end":
                      return _context54.stop();
                  }
                }
              }, _callee54, this);
            }));

            function directlySetCurrentUser(_x76) {
              return _directlySetCurrentUser.apply(this, arguments);
            }

            return directlySetCurrentUser;
          }()
        }, {
          key: "queue",
          value: function queue(action) {
            // In case something errors, the callback still should be called in order
            // to keep the promise chain alive
            this.operations = this.operations.then(action, action);
            return this.operations;
          }
        }, {
          key: "assertedPersistence",
          get: function get() {
            _assert(this.persistenceManager, this, "internal-error"
            /* INTERNAL_ERROR */
            );

            return this.persistenceManager;
          }
        }, {
          key: "_logFramework",
          value: function _logFramework(framework) {
            if (!framework || this.frameworks.includes(framework)) {
              return;
            }

            this.frameworks.push(framework); // Sort alphabetically so that "FirebaseCore-web,FirebaseUI-web" and
            // "FirebaseUI-web,FirebaseCore-web" aren't viewed as different.

            this.frameworks.sort();
            this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
          }
        }, {
          key: "_getFrameworks",
          value: function _getFrameworks() {
            return this.frameworks;
          }
        }, {
          key: "_getSdkClientVersion",
          value: function _getSdkClientVersion() {
            return this.clientVersion;
          }
        }]);

        return AuthImpl;
      }();
      /**
       * Method to be used to cast down to our private implmentation of Auth.
       * It will also handle unwrapping from the compat type if necessary
       *
       * @param auth Auth object passed in from developer
       */


      function _castAuth(auth) {
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth);
      }
      /** Helper class to wrap subscriber logic */


      var Subscription = /*#__PURE__*/function () {
        function Subscription(auth) {
          var _this9 = this;

          _classCallCheck(this, Subscription);

          this.auth = auth;
          this.observer = null;
          this.addObserver = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.createSubscribe)(function (observer) {
            return _this9.observer = observer;
          });
        }

        _createClass(Subscription, [{
          key: "next",
          get: function get() {
            _assert(this.observer, this.auth, "internal-error"
            /* INTERNAL_ERROR */
            );

            return this.observer.next.bind(this.observer);
          }
        }]);

        return Subscription;
      }();
      /**
       * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production
       * Firebase Auth services.
       *
       * @remarks
       * This must be called synchronously immediately following the first call to
       * {@link initializeAuth}.  Do not use with production credentials as emulator
       * traffic is not encrypted.
       *
       *
       * @example
       * ```javascript
       * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });
       * ```
       *
       * @param auth - The {@link Auth} instance.
       * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').
       * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to
       * `true` to disable the warning banner attached to the DOM.
       *
       * @public
       */


      function connectAuthEmulator(auth, url, options) {
        var authInternal = _castAuth(auth);

        _assert(authInternal._canInitEmulator, authInternal, "emulator-config-failed"
        /* EMULATOR_CONFIG_FAILED */
        );

        _assert(/^https?:\/\//.test(url), authInternal, "invalid-emulator-scheme"
        /* INVALID_EMULATOR_SCHEME */
        );

        var disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);
        var protocol = extractProtocol(url);

        var _extractHostAndPort = extractHostAndPort(url),
            host = _extractHostAndPort.host,
            port = _extractHostAndPort.port;

        var portStr = port === null ? '' : ":".concat(port); // Always replace path with "/" (even if input url had no path at all, or had a different one).

        authInternal.config.emulator = {
          url: "".concat(protocol, "//").concat(host).concat(portStr, "/")
        };
        authInternal.settings.appVerificationDisabledForTesting = true;
        authInternal.emulatorConfig = Object.freeze({
          host: host,
          port: port,
          protocol: protocol.replace(':', ''),
          options: Object.freeze({
            disableWarnings: disableWarnings
          })
        });

        if (!disableWarnings) {
          emitEmulatorWarning();
        }
      }

      function extractProtocol(url) {
        var protocolEnd = url.indexOf(':');
        return protocolEnd < 0 ? '' : url.substr(0, protocolEnd + 1);
      }

      function extractHostAndPort(url) {
        var protocol = extractProtocol(url);
        var authority = /(\/\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.

        if (!authority) {
          return {
            host: '',
            port: null
          };
        }

        var hostAndPort = authority[2].split('@').pop() || ''; // Strip out "username:password@".

        var bracketedIPv6 = /^(\[[^\]]+\])(:|$)/.exec(hostAndPort);

        if (bracketedIPv6) {
          var host = bracketedIPv6[1];
          return {
            host: host,
            port: parsePort(hostAndPort.substr(host.length + 1))
          };
        } else {
          var _hostAndPort$split = hostAndPort.split(':'),
              _hostAndPort$split2 = _slicedToArray(_hostAndPort$split, 2),
              _host = _hostAndPort$split2[0],
              port = _hostAndPort$split2[1];

          return {
            host: _host,
            port: parsePort(port)
          };
        }
      }

      function parsePort(portStr) {
        if (!portStr) {
          return null;
        }

        var port = Number(portStr);

        if (isNaN(port)) {
          return null;
        }

        return port;
      }

      function emitEmulatorWarning() {
        function attachBanner() {
          var el = document.createElement('p');
          var sty = el.style;
          el.innerText = 'Running in emulator mode. Do not use with production credentials.';
          sty.position = 'fixed';
          sty.width = '100%';
          sty.backgroundColor = '#ffffff';
          sty.border = '.1em solid #000000';
          sty.color = '#b50000';
          sty.bottom = '0px';
          sty.left = '0px';
          sty.margin = '0px';
          sty.zIndex = '10000';
          sty.textAlign = 'center';
          el.classList.add('firebase-emulator-warning');
          document.body.appendChild(el);
        }

        if (typeof console !== 'undefined' && typeof console.info === 'function') {
          console.info('WARNING: You are using the Auth Emulator,' + ' which is intended for local testing only.  Do not use with' + ' production credentials.');
        }

        if (typeof window !== 'undefined' && typeof document !== 'undefined') {
          if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', attachBanner);
          } else {
            attachBanner();
          }
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Interface that represents the credentials returned by an {@link AuthProvider}.
       *
       * @remarks
       * Implementations specify the details about each auth provider's credential requirements.
       *
       * @public
       */


      var AuthCredential = /*#__PURE__*/function () {
        /** @internal */
        function AuthCredential(
        /**
         * The authentication provider ID for the credential.
         *
         * @remarks
         * For example, 'facebook.com', or 'google.com'.
         */
        providerId,
        /**
         * The authentication sign in method for the credential.
         *
         * @remarks
         * For example, {@link SignInMethod}.EMAIL_PASSWORD, or
         * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method
         * identifier as returned in {@link fetchSignInMethodsForEmail}.
         */
        signInMethod) {
          _classCallCheck(this, AuthCredential);

          this.providerId = providerId;
          this.signInMethod = signInMethod;
        }
        /**
         * Returns a JSON-serializable representation of this object.
         *
         * @returns a JSON-serializable representation of this object.
         */


        _createClass(AuthCredential, [{
          key: "toJSON",
          value: function toJSON() {
            return debugFail('not implemented');
          }
          /** @internal */

        }, {
          key: "_getIdTokenResponse",
          value: function _getIdTokenResponse(_auth) {
            return debugFail('not implemented');
          }
          /** @internal */

        }, {
          key: "_linkToIdToken",
          value: function _linkToIdToken(_auth, _idToken) {
            return debugFail('not implemented');
          }
          /** @internal */

        }, {
          key: "_getReauthenticationResolver",
          value: function _getReauthenticationResolver(_auth) {
            return debugFail('not implemented');
          }
        }]);

        return AuthCredential;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function resetPassword(_x77, _x78) {
        return _resetPassword.apply(this, arguments);
      }

      function _resetPassword() {
        _resetPassword = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee116(auth, request) {
          return regeneratorRuntime.wrap(function _callee116$(_context116) {
            while (1) {
              switch (_context116.prev = _context116.next) {
                case 0:
                  return _context116.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:resetPassword"
                  /* RESET_PASSWORD */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context116.stop();
              }
            }
          }, _callee116);
        }));
        return _resetPassword.apply(this, arguments);
      }

      function updateEmailPassword(_x79, _x80) {
        return _updateEmailPassword.apply(this, arguments);
      }

      function _updateEmailPassword() {
        _updateEmailPassword = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee117(auth, request) {
          return regeneratorRuntime.wrap(function _callee117$(_context117) {
            while (1) {
              switch (_context117.prev = _context117.next) {
                case 0:
                  return _context117.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:update"
                  /* SET_ACCOUNT_INFO */
                  , request));

                case 1:
                case "end":
                  return _context117.stop();
              }
            }
          }, _callee117);
        }));
        return _updateEmailPassword.apply(this, arguments);
      }

      function applyActionCode$1(_x81, _x82) {
        return _applyActionCode$.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _applyActionCode$() {
        _applyActionCode$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee118(auth, request) {
          return regeneratorRuntime.wrap(function _callee118$(_context118) {
            while (1) {
              switch (_context118.prev = _context118.next) {
                case 0:
                  return _context118.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:update"
                  /* SET_ACCOUNT_INFO */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context118.stop();
              }
            }
          }, _callee118);
        }));
        return _applyActionCode$.apply(this, arguments);
      }

      function signInWithPassword(_x83, _x84) {
        return _signInWithPassword.apply(this, arguments);
      }

      function _signInWithPassword() {
        _signInWithPassword = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee119(auth, request) {
          return regeneratorRuntime.wrap(function _callee119$(_context119) {
            while (1) {
              switch (_context119.prev = _context119.next) {
                case 0:
                  return _context119.abrupt("return", _performSignInRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:signInWithPassword"
                  /* SIGN_IN_WITH_PASSWORD */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context119.stop();
              }
            }
          }, _callee119);
        }));
        return _signInWithPassword.apply(this, arguments);
      }

      function sendOobCode(_x85, _x86) {
        return _sendOobCode.apply(this, arguments);
      }

      function _sendOobCode() {
        _sendOobCode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee120(auth, request) {
          return regeneratorRuntime.wrap(function _callee120$(_context120) {
            while (1) {
              switch (_context120.prev = _context120.next) {
                case 0:
                  return _context120.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:sendOobCode"
                  /* SEND_OOB_CODE */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context120.stop();
              }
            }
          }, _callee120);
        }));
        return _sendOobCode.apply(this, arguments);
      }

      function sendEmailVerification$1(_x87, _x88) {
        return _sendEmailVerification$.apply(this, arguments);
      }

      function _sendEmailVerification$() {
        _sendEmailVerification$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee121(auth, request) {
          return regeneratorRuntime.wrap(function _callee121$(_context121) {
            while (1) {
              switch (_context121.prev = _context121.next) {
                case 0:
                  return _context121.abrupt("return", sendOobCode(auth, request));

                case 1:
                case "end":
                  return _context121.stop();
              }
            }
          }, _callee121);
        }));
        return _sendEmailVerification$.apply(this, arguments);
      }

      function sendPasswordResetEmail$1(_x89, _x90) {
        return _sendPasswordResetEmail$.apply(this, arguments);
      }

      function _sendPasswordResetEmail$() {
        _sendPasswordResetEmail$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee122(auth, request) {
          return regeneratorRuntime.wrap(function _callee122$(_context122) {
            while (1) {
              switch (_context122.prev = _context122.next) {
                case 0:
                  return _context122.abrupt("return", sendOobCode(auth, request));

                case 1:
                case "end":
                  return _context122.stop();
              }
            }
          }, _callee122);
        }));
        return _sendPasswordResetEmail$.apply(this, arguments);
      }

      function sendSignInLinkToEmail$1(_x91, _x92) {
        return _sendSignInLinkToEmail$.apply(this, arguments);
      }

      function _sendSignInLinkToEmail$() {
        _sendSignInLinkToEmail$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee123(auth, request) {
          return regeneratorRuntime.wrap(function _callee123$(_context123) {
            while (1) {
              switch (_context123.prev = _context123.next) {
                case 0:
                  return _context123.abrupt("return", sendOobCode(auth, request));

                case 1:
                case "end":
                  return _context123.stop();
              }
            }
          }, _callee123);
        }));
        return _sendSignInLinkToEmail$.apply(this, arguments);
      }

      function verifyAndChangeEmail(_x93, _x94) {
        return _verifyAndChangeEmail.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _verifyAndChangeEmail() {
        _verifyAndChangeEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee124(auth, request) {
          return regeneratorRuntime.wrap(function _callee124$(_context124) {
            while (1) {
              switch (_context124.prev = _context124.next) {
                case 0:
                  return _context124.abrupt("return", sendOobCode(auth, request));

                case 1:
                case "end":
                  return _context124.stop();
              }
            }
          }, _callee124);
        }));
        return _verifyAndChangeEmail.apply(this, arguments);
      }

      function signInWithEmailLink$1(_x95, _x96) {
        return _signInWithEmailLink$.apply(this, arguments);
      }

      function _signInWithEmailLink$() {
        _signInWithEmailLink$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee125(auth, request) {
          return regeneratorRuntime.wrap(function _callee125$(_context125) {
            while (1) {
              switch (_context125.prev = _context125.next) {
                case 0:
                  return _context125.abrupt("return", _performSignInRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:signInWithEmailLink"
                  /* SIGN_IN_WITH_EMAIL_LINK */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context125.stop();
              }
            }
          }, _callee125);
        }));
        return _signInWithEmailLink$.apply(this, arguments);
      }

      function signInWithEmailLinkForLinking(_x97, _x98) {
        return _signInWithEmailLinkForLinking.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Interface that represents the credentials returned by {@link EmailAuthProvider} for
       * {@link ProviderId}.PASSWORD
       *
       * @remarks
       * Covers both {@link SignInMethod}.EMAIL_PASSWORD and
       * {@link SignInMethod}.EMAIL_LINK.
       *
       * @public
       */


      function _signInWithEmailLinkForLinking() {
        _signInWithEmailLinkForLinking = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee126(auth, request) {
          return regeneratorRuntime.wrap(function _callee126$(_context126) {
            while (1) {
              switch (_context126.prev = _context126.next) {
                case 0:
                  return _context126.abrupt("return", _performSignInRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:signInWithEmailLink"
                  /* SIGN_IN_WITH_EMAIL_LINK */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context126.stop();
              }
            }
          }, _callee126);
        }));
        return _signInWithEmailLinkForLinking.apply(this, arguments);
      }

      var EmailAuthCredential = /*#__PURE__*/function (_AuthCredential) {
        _inherits(EmailAuthCredential, _AuthCredential);

        var _super = _createSuper(EmailAuthCredential);

        /** @internal */
        function EmailAuthCredential(
        /** @internal */
        _email,
        /** @internal */
        _password, signInMethod) {
          var _this10;

          var _tenantId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

          _classCallCheck(this, EmailAuthCredential);

          _this10 = _super.call(this, "password"
          /* PASSWORD */
          , signInMethod);
          _this10._email = _email;
          _this10._password = _password;
          _this10._tenantId = _tenantId;
          return _this10;
        }
        /** @internal */


        _createClass(EmailAuthCredential, [{
          key: "toJSON",
          value:
          /** {@inheritdoc AuthCredential.toJSON} */
          function toJSON() {
            return {
              email: this._email,
              password: this._password,
              signInMethod: this.signInMethod,
              tenantId: this._tenantId
            };
          }
          /**
           * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.
           *
           * @param json - Either `object` or the stringified representation of the object. When string is
           * provided, `JSON.parse` would be called first.
           *
           * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.
           */

        }, {
          key: "_getIdTokenResponse",
          value:
          /** @internal */
          function () {
            var _getIdTokenResponse2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee55(auth) {
              return regeneratorRuntime.wrap(function _callee55$(_context55) {
                while (1) {
                  switch (_context55.prev = _context55.next) {
                    case 0:
                      _context55.t0 = this.signInMethod;
                      _context55.next = _context55.t0 === "password"
                      /* EMAIL_PASSWORD */
                      ? 3 : _context55.t0 === "emailLink"
                      /* EMAIL_LINK */
                      ? 4 : 5;
                      break;

                    case 3:
                      return _context55.abrupt("return", signInWithPassword(auth, {
                        returnSecureToken: true,
                        email: this._email,
                        password: this._password
                      }));

                    case 4:
                      return _context55.abrupt("return", signInWithEmailLink$1(auth, {
                        email: this._email,
                        oobCode: this._password
                      }));

                    case 5:
                      _fail(auth, "internal-error"
                      /* INTERNAL_ERROR */
                      );

                    case 6:
                    case "end":
                      return _context55.stop();
                  }
                }
              }, _callee55, this);
            }));

            function _getIdTokenResponse(_x99) {
              return _getIdTokenResponse2.apply(this, arguments);
            }

            return _getIdTokenResponse;
          }()
          /** @internal */

        }, {
          key: "_linkToIdToken",
          value: function () {
            var _linkToIdToken2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee56(auth, idToken) {
              return regeneratorRuntime.wrap(function _callee56$(_context56) {
                while (1) {
                  switch (_context56.prev = _context56.next) {
                    case 0:
                      _context56.t0 = this.signInMethod;
                      _context56.next = _context56.t0 === "password"
                      /* EMAIL_PASSWORD */
                      ? 3 : _context56.t0 === "emailLink"
                      /* EMAIL_LINK */
                      ? 4 : 5;
                      break;

                    case 3:
                      return _context56.abrupt("return", updateEmailPassword(auth, {
                        idToken: idToken,
                        returnSecureToken: true,
                        email: this._email,
                        password: this._password
                      }));

                    case 4:
                      return _context56.abrupt("return", signInWithEmailLinkForLinking(auth, {
                        idToken: idToken,
                        email: this._email,
                        oobCode: this._password
                      }));

                    case 5:
                      _fail(auth, "internal-error"
                      /* INTERNAL_ERROR */
                      );

                    case 6:
                    case "end":
                      return _context56.stop();
                  }
                }
              }, _callee56, this);
            }));

            function _linkToIdToken(_x100, _x101) {
              return _linkToIdToken2.apply(this, arguments);
            }

            return _linkToIdToken;
          }()
          /** @internal */

        }, {
          key: "_getReauthenticationResolver",
          value: function _getReauthenticationResolver(auth) {
            return this._getIdTokenResponse(auth);
          }
        }], [{
          key: "_fromEmailAndPassword",
          value: function _fromEmailAndPassword(email, password) {
            return new EmailAuthCredential(email, password, "password"
            /* EMAIL_PASSWORD */
            );
          }
          /** @internal */

        }, {
          key: "_fromEmailAndCode",
          value: function _fromEmailAndCode(email, oobCode) {
            var tenantId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            return new EmailAuthCredential(email, oobCode, "emailLink"
            /* EMAIL_LINK */
            , tenantId);
          }
        }, {
          key: "fromJSON",
          value: function fromJSON(json) {
            var obj = typeof json === 'string' ? JSON.parse(json) : json;

            if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {
              if (obj.signInMethod === "password"
              /* EMAIL_PASSWORD */
              ) {
                return this._fromEmailAndPassword(obj.email, obj.password);
              } else if (obj.signInMethod === "emailLink"
              /* EMAIL_LINK */
              ) {
                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);
              }
            }

            return null;
          }
        }]);

        return EmailAuthCredential;
      }(AuthCredential);
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function signInWithIdp(_x102, _x103) {
        return _signInWithIdp.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _signInWithIdp() {
        _signInWithIdp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee127(auth, request) {
          return regeneratorRuntime.wrap(function _callee127$(_context127) {
            while (1) {
              switch (_context127.prev = _context127.next) {
                case 0:
                  return _context127.abrupt("return", _performSignInRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:signInWithIdp"
                  /* SIGN_IN_WITH_IDP */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context127.stop();
              }
            }
          }, _callee127);
        }));
        return _signInWithIdp.apply(this, arguments);
      }

      var IDP_REQUEST_URI$1 = 'http://localhost';
      /**
       * Represents the OAuth credentials returned by an {@link OAuthProvider}.
       *
       * @remarks
       * Implementations specify the details about each auth provider's credential requirements.
       *
       * @public
       */

      var OAuthCredential = /*#__PURE__*/function (_AuthCredential2) {
        _inherits(OAuthCredential, _AuthCredential2);

        var _super2 = _createSuper(OAuthCredential);

        function OAuthCredential() {
          var _this11;

          _classCallCheck(this, OAuthCredential);

          _this11 = _super2.apply(this, arguments);
          _this11.pendingToken = null;
          return _this11;
        }
        /** @internal */


        _createClass(OAuthCredential, [{
          key: "toJSON",
          value:
          /** {@inheritdoc AuthCredential.toJSON}  */
          function toJSON() {
            return {
              idToken: this.idToken,
              accessToken: this.accessToken,
              secret: this.secret,
              nonce: this.nonce,
              pendingToken: this.pendingToken,
              providerId: this.providerId,
              signInMethod: this.signInMethod
            };
          }
          /**
           * Static method to deserialize a JSON representation of an object into an
           * {@link  AuthCredential}.
           *
           * @param json - Input can be either Object or the stringified representation of the object.
           * When string is provided, JSON.parse would be called first.
           *
           * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
           */

        }, {
          key: "_getIdTokenResponse",
          value:
          /** @internal */
          function _getIdTokenResponse(auth) {
            var request = this.buildRequest();
            return signInWithIdp(auth, request);
          }
          /** @internal */

        }, {
          key: "_linkToIdToken",
          value: function _linkToIdToken(auth, idToken) {
            var request = this.buildRequest();
            request.idToken = idToken;
            return signInWithIdp(auth, request);
          }
          /** @internal */

        }, {
          key: "_getReauthenticationResolver",
          value: function _getReauthenticationResolver(auth) {
            var request = this.buildRequest();
            request.autoCreate = false;
            return signInWithIdp(auth, request);
          }
        }, {
          key: "buildRequest",
          value: function buildRequest() {
            var request = {
              requestUri: IDP_REQUEST_URI$1,
              returnSecureToken: true
            };

            if (this.pendingToken) {
              request.pendingToken = this.pendingToken;
            } else {
              var postBody = {};

              if (this.idToken) {
                postBody['id_token'] = this.idToken;
              }

              if (this.accessToken) {
                postBody['access_token'] = this.accessToken;
              }

              if (this.secret) {
                postBody['oauth_token_secret'] = this.secret;
              }

              postBody['providerId'] = this.providerId;

              if (this.nonce && !this.pendingToken) {
                postBody['nonce'] = this.nonce;
              }

              request.postBody = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystring)(postBody);
            }

            return request;
          }
        }], [{
          key: "_fromParams",
          value: function _fromParams(params) {
            var cred = new OAuthCredential(params.providerId, params.signInMethod);

            if (params.idToken || params.accessToken) {
              // OAuth 2 and either ID token or access token.
              if (params.idToken) {
                cred.idToken = params.idToken;
              }

              if (params.accessToken) {
                cred.accessToken = params.accessToken;
              } // Add nonce if available and no pendingToken is present.


              if (params.nonce && !params.pendingToken) {
                cred.nonce = params.nonce;
              }

              if (params.pendingToken) {
                cred.pendingToken = params.pendingToken;
              }
            } else if (params.oauthToken && params.oauthTokenSecret) {
              // OAuth 1 and OAuth token with token secret
              cred.accessToken = params.oauthToken;
              cred.secret = params.oauthTokenSecret;
            } else {
              _fail("argument-error"
              /* ARGUMENT_ERROR */
              );
            }

            return cred;
          }
        }, {
          key: "fromJSON",
          value: function fromJSON(json) {
            var obj = typeof json === 'string' ? JSON.parse(json) : json;
            var providerId = obj.providerId,
                signInMethod = obj.signInMethod,
                rest = (0, tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(obj, ["providerId", "signInMethod"]);

            if (!providerId || !signInMethod) {
              return null;
            }

            var cred = new OAuthCredential(providerId, signInMethod);
            cred.idToken = rest.idToken || undefined;
            cred.accessToken = rest.accessToken || undefined;
            cred.secret = rest.secret;
            cred.nonce = rest.nonce;
            cred.pendingToken = rest.pendingToken || null;
            return cred;
          }
        }]);

        return OAuthCredential;
      }(AuthCredential);
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function sendPhoneVerificationCode(_x104, _x105) {
        return _sendPhoneVerificationCode.apply(this, arguments);
      }

      function _sendPhoneVerificationCode() {
        _sendPhoneVerificationCode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee128(auth, request) {
          return regeneratorRuntime.wrap(function _callee128$(_context128) {
            while (1) {
              switch (_context128.prev = _context128.next) {
                case 0:
                  return _context128.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:sendVerificationCode"
                  /* SEND_VERIFICATION_CODE */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context128.stop();
              }
            }
          }, _callee128);
        }));
        return _sendPhoneVerificationCode.apply(this, arguments);
      }

      function signInWithPhoneNumber$1(_x106, _x107) {
        return _signInWithPhoneNumber$.apply(this, arguments);
      }

      function _signInWithPhoneNumber$() {
        _signInWithPhoneNumber$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee129(auth, request) {
          return regeneratorRuntime.wrap(function _callee129$(_context129) {
            while (1) {
              switch (_context129.prev = _context129.next) {
                case 0:
                  return _context129.abrupt("return", _performSignInRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:signInWithPhoneNumber"
                  /* SIGN_IN_WITH_PHONE_NUMBER */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context129.stop();
              }
            }
          }, _callee129);
        }));
        return _signInWithPhoneNumber$.apply(this, arguments);
      }

      function linkWithPhoneNumber$1(_x108, _x109) {
        return _linkWithPhoneNumber$.apply(this, arguments);
      }

      function _linkWithPhoneNumber$() {
        _linkWithPhoneNumber$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee130(auth, request) {
          var response;
          return regeneratorRuntime.wrap(function _callee130$(_context130) {
            while (1) {
              switch (_context130.prev = _context130.next) {
                case 0:
                  _context130.next = 2;
                  return _performSignInRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:signInWithPhoneNumber"
                  /* SIGN_IN_WITH_PHONE_NUMBER */
                  , _addTidIfNecessary(auth, request));

                case 2:
                  response = _context130.sent;

                  if (!response.temporaryProof) {
                    _context130.next = 5;
                    break;
                  }

                  throw _makeTaggedError(auth, "account-exists-with-different-credential"
                  /* NEED_CONFIRMATION */
                  , response);

                case 5:
                  return _context130.abrupt("return", response);

                case 6:
                case "end":
                  return _context130.stop();
              }
            }
          }, _callee130);
        }));
        return _linkWithPhoneNumber$.apply(this, arguments);
      }

      var VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = _defineProperty({}, "USER_NOT_FOUND"
      /* USER_NOT_FOUND */
      , "user-not-found");

      function verifyPhoneNumberForExisting(_x110, _x111) {
        return _verifyPhoneNumberForExisting.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Represents the credentials returned by {@link PhoneAuthProvider}.
       *
       * @public
       */


      function _verifyPhoneNumberForExisting() {
        _verifyPhoneNumberForExisting = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee131(auth, request) {
          var apiRequest;
          return regeneratorRuntime.wrap(function _callee131$(_context131) {
            while (1) {
              switch (_context131.prev = _context131.next) {
                case 0:
                  apiRequest = Object.assign(Object.assign({}, request), {
                    operation: 'REAUTH'
                  });
                  return _context131.abrupt("return", _performSignInRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:signInWithPhoneNumber"
                  /* SIGN_IN_WITH_PHONE_NUMBER */
                  , _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_));

                case 2:
                case "end":
                  return _context131.stop();
              }
            }
          }, _callee131);
        }));
        return _verifyPhoneNumberForExisting.apply(this, arguments);
      }

      var PhoneAuthCredential = /*#__PURE__*/function (_AuthCredential3) {
        _inherits(PhoneAuthCredential, _AuthCredential3);

        var _super3 = _createSuper(PhoneAuthCredential);

        function PhoneAuthCredential(params) {
          var _this12;

          _classCallCheck(this, PhoneAuthCredential);

          _this12 = _super3.call(this, "phone"
          /* PHONE */
          , "phone"
          /* PHONE */
          );
          _this12.params = params;
          return _this12;
        }
        /** @internal */


        _createClass(PhoneAuthCredential, [{
          key: "_getIdTokenResponse",
          value:
          /** @internal */
          function _getIdTokenResponse(auth) {
            return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());
          }
          /** @internal */

        }, {
          key: "_linkToIdToken",
          value: function _linkToIdToken(auth, idToken) {
            return linkWithPhoneNumber$1(auth, Object.assign({
              idToken: idToken
            }, this._makeVerificationRequest()));
          }
          /** @internal */

        }, {
          key: "_getReauthenticationResolver",
          value: function _getReauthenticationResolver(auth) {
            return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());
          }
          /** @internal */

        }, {
          key: "_makeVerificationRequest",
          value: function _makeVerificationRequest() {
            var _this$params = this.params,
                temporaryProof = _this$params.temporaryProof,
                phoneNumber = _this$params.phoneNumber,
                verificationId = _this$params.verificationId,
                verificationCode = _this$params.verificationCode;

            if (temporaryProof && phoneNumber) {
              return {
                temporaryProof: temporaryProof,
                phoneNumber: phoneNumber
              };
            }

            return {
              sessionInfo: verificationId,
              code: verificationCode
            };
          }
          /** {@inheritdoc AuthCredential.toJSON} */

        }, {
          key: "toJSON",
          value: function toJSON() {
            var obj = {
              providerId: this.providerId
            };

            if (this.params.phoneNumber) {
              obj.phoneNumber = this.params.phoneNumber;
            }

            if (this.params.temporaryProof) {
              obj.temporaryProof = this.params.temporaryProof;
            }

            if (this.params.verificationCode) {
              obj.verificationCode = this.params.verificationCode;
            }

            if (this.params.verificationId) {
              obj.verificationId = this.params.verificationId;
            }

            return obj;
          }
          /** Generates a phone credential based on a plain object or a JSON string. */

        }], [{
          key: "_fromVerification",
          value: function _fromVerification(verificationId, verificationCode) {
            return new PhoneAuthCredential({
              verificationId: verificationId,
              verificationCode: verificationCode
            });
          }
          /** @internal */

        }, {
          key: "_fromTokenResponse",
          value: function _fromTokenResponse(phoneNumber, temporaryProof) {
            return new PhoneAuthCredential({
              phoneNumber: phoneNumber,
              temporaryProof: temporaryProof
            });
          }
        }, {
          key: "fromJSON",
          value: function fromJSON(json) {
            if (typeof json === 'string') {
              json = JSON.parse(json);
            }

            var _json = json,
                verificationId = _json.verificationId,
                verificationCode = _json.verificationCode,
                phoneNumber = _json.phoneNumber,
                temporaryProof = _json.temporaryProof;

            if (!verificationCode && !verificationId && !phoneNumber && !temporaryProof) {
              return null;
            }

            return new PhoneAuthCredential({
              verificationId: verificationId,
              verificationCode: verificationCode,
              phoneNumber: phoneNumber,
              temporaryProof: temporaryProof
            });
          }
        }]);

        return PhoneAuthCredential;
      }(AuthCredential);
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Maps the mode string in action code URL to Action Code Info operation.
       *
       * @param mode
       */


      function parseMode(mode) {
        switch (mode) {
          case 'recoverEmail':
            return "RECOVER_EMAIL"
            /* RECOVER_EMAIL */
            ;

          case 'resetPassword':
            return "PASSWORD_RESET"
            /* PASSWORD_RESET */
            ;

          case 'signIn':
            return "EMAIL_SIGNIN"
            /* EMAIL_SIGNIN */
            ;

          case 'verifyEmail':
            return "VERIFY_EMAIL"
            /* VERIFY_EMAIL */
            ;

          case 'verifyAndChangeEmail':
            return "VERIFY_AND_CHANGE_EMAIL"
            /* VERIFY_AND_CHANGE_EMAIL */
            ;

          case 'revertSecondFactorAddition':
            return "REVERT_SECOND_FACTOR_ADDITION"
            /* REVERT_SECOND_FACTOR_ADDITION */
            ;

          default:
            return null;
        }
      }
      /**
       * Helper to parse FDL links
       *
       * @param url
       */


      function parseDeepLink(url) {
        var link = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystringDecode)((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.extractQuerystring)(url))['link']; // Double link case (automatic redirect).

        var doubleDeepLink = link ? (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystringDecode)((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.extractQuerystring)(link))['deep_link_id'] : null; // iOS custom scheme links.

        var iOSDeepLink = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystringDecode)((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.extractQuerystring)(url))['deep_link_id'];
        var iOSDoubleDeepLink = iOSDeepLink ? (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystringDecode)((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.extractQuerystring)(iOSDeepLink))['link'] : null;
        return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
      }
      /**
       * A utility class to parse email action URLs such as password reset, email verification,
       * email link sign in, etc.
       *
       * @public
       */


      var ActionCodeURL = /*#__PURE__*/function () {
        /**
         * @param actionLink - The link from which to extract the URL.
         * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
         *
         * @internal
         */
        function ActionCodeURL(actionLink) {
          _classCallCheck(this, ActionCodeURL);

          var _a, _b, _c, _d, _e, _f;

          var searchParams = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystringDecode)((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.extractQuerystring)(actionLink));
          var apiKey = (_a = searchParams["apiKey"
          /* API_KEY */
          ]) !== null && _a !== void 0 ? _a : null;
          var code = (_b = searchParams["oobCode"
          /* CODE */
          ]) !== null && _b !== void 0 ? _b : null;
          var operation = parseMode((_c = searchParams["mode"
          /* MODE */
          ]) !== null && _c !== void 0 ? _c : null); // Validate API key, code and mode.

          _assert(apiKey && code && operation, "argument-error"
          /* ARGUMENT_ERROR */
          );

          this.apiKey = apiKey;
          this.operation = operation;
          this.code = code;
          this.continueUrl = (_d = searchParams["continueUrl"
          /* CONTINUE_URL */
          ]) !== null && _d !== void 0 ? _d : null;
          this.languageCode = (_e = searchParams["languageCode"
          /* LANGUAGE_CODE */
          ]) !== null && _e !== void 0 ? _e : null;
          this.tenantId = (_f = searchParams["tenantId"
          /* TENANT_ID */
          ]) !== null && _f !== void 0 ? _f : null;
        }
        /**
         * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,
         * otherwise returns null.
         *
         * @param link  - The email action link string.
         * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
         *
         * @public
         */


        _createClass(ActionCodeURL, null, [{
          key: "parseLink",
          value: function parseLink(link) {
            var actionLink = parseDeepLink(link);

            try {
              return new ActionCodeURL(actionLink);
            } catch (_a) {
              return null;
            }
          }
        }]);

        return ActionCodeURL;
      }();
      /**
       * Parses the email action link string and returns an {@link ActionCodeURL} if
       * the link is valid, otherwise returns null.
       *
       * @public
       */


      function parseActionCodeURL(link) {
        return ActionCodeURL.parseLink(link);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Provider for generating {@link EmailAuthCredential}.
       *
       * @public
       */


      var EmailAuthProvider = /*#__PURE__*/function () {
        function EmailAuthProvider() {
          _classCallCheck(this, EmailAuthProvider);

          /**
           * Always set to {@link ProviderId}.PASSWORD, even for email link.
           */
          this.providerId = EmailAuthProvider.PROVIDER_ID;
        }
        /**
         * Initialize an {@link AuthCredential} using an email and password.
         *
         * @example
         * ```javascript
         * const authCredential = EmailAuthProvider.credential(email, password);
         * const userCredential = await signInWithCredential(auth, authCredential);
         * ```
         *
         * @example
         * ```javascript
         * const userCredential = await signInWithEmailAndPassword(auth, email, password);
         * ```
         *
         * @param email - Email address.
         * @param password - User account password.
         * @returns The auth provider credential.
         */


        _createClass(EmailAuthProvider, null, [{
          key: "credential",
          value: function credential(email, password) {
            return EmailAuthCredential._fromEmailAndPassword(email, password);
          }
          /**
           * Initialize an {@link AuthCredential} using an email and an email link after a sign in with
           * email link operation.
           *
           * @example
           * ```javascript
           * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);
           * const userCredential = await signInWithCredential(auth, authCredential);
           * ```
           *
           * @example
           * ```javascript
           * await sendSignInLinkToEmail(auth, email);
           * // Obtain emailLink from user.
           * const userCredential = await signInWithEmailLink(auth, email, emailLink);
           * ```
           *
           * @param auth - The {@link Auth} instance used to verify the link.
           * @param email - Email address.
           * @param emailLink - Sign-in email link.
           * @returns - The auth provider credential.
           */

        }, {
          key: "credentialWithLink",
          value: function credentialWithLink(email, emailLink) {
            var actionCodeUrl = ActionCodeURL.parseLink(emailLink);

            _assert(actionCodeUrl, "argument-error"
            /* ARGUMENT_ERROR */
            );

            return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);
          }
        }]);

        return EmailAuthProvider;
      }();
      /**
       * Always set to {@link ProviderId}.PASSWORD, even for email link.
       */


      EmailAuthProvider.PROVIDER_ID = "password"
      /* PASSWORD */
      ;
      /**
       * Always set to {@link SignInMethod}.EMAIL_PASSWORD.
       */

      EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = "password"
      /* EMAIL_PASSWORD */
      ;
      /**
       * Always set to {@link SignInMethod}.EMAIL_LINK.
       */

      EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = "emailLink"
      /* EMAIL_LINK */
      ;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * The base class for all Federated providers (OAuth (including OIDC), SAML).
       *
       * This class is not meant to be instantiated directly.
       *
       * @public
       */

      var FederatedAuthProvider = /*#__PURE__*/function () {
        /**
         * Constructor for generic OAuth providers.
         *
         * @param providerId - Provider for which credentials should be generated.
         */
        function FederatedAuthProvider(providerId) {
          _classCallCheck(this, FederatedAuthProvider);

          this.providerId = providerId;
          /** @internal */

          this.defaultLanguageCode = null;
          /** @internal */

          this.customParameters = {};
        }
        /**
         * Set the language gode.
         *
         * @param languageCode - language code
         */


        _createClass(FederatedAuthProvider, [{
          key: "setDefaultLanguage",
          value: function setDefaultLanguage(languageCode) {
            this.defaultLanguageCode = languageCode;
          }
          /**
           * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in
           * operations.
           *
           * @remarks
           * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,
           * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.
           *
           * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.
           */

        }, {
          key: "setCustomParameters",
          value: function setCustomParameters(customOAuthParameters) {
            this.customParameters = customOAuthParameters;
            return this;
          }
          /**
           * Retrieve the current list of {@link CustomParameters}.
           */

        }, {
          key: "getCustomParameters",
          value: function getCustomParameters() {
            return this.customParameters;
          }
        }]);

        return FederatedAuthProvider;
      }();
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Common code to all OAuth providers. This is separate from the
       * {@link OAuthProvider} so that child providers (like
       * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.
       * Instead, they rely on a static `credential` method.
       */


      var BaseOAuthProvider = /*#__PURE__*/function (_FederatedAuthProvide) {
        _inherits(BaseOAuthProvider, _FederatedAuthProvide);

        var _super4 = _createSuper(BaseOAuthProvider);

        function BaseOAuthProvider() {
          var _this13;

          _classCallCheck(this, BaseOAuthProvider);

          _this13 = _super4.apply(this, arguments);
          /** @internal */

          _this13.scopes = [];
          return _this13;
        }
        /**
         * Add an OAuth scope to the credential.
         *
         * @param scope - Provider OAuth scope to add.
         */


        _createClass(BaseOAuthProvider, [{
          key: "addScope",
          value: function addScope(scope) {
            // If not already added, add scope to list.
            if (!this.scopes.includes(scope)) {
              this.scopes.push(scope);
            }

            return this;
          }
          /**
           * Retrieve the current list of OAuth scopes.
           */

        }, {
          key: "getScopes",
          value: function getScopes() {
            return _toConsumableArray(this.scopes);
          }
        }]);

        return BaseOAuthProvider;
      }(FederatedAuthProvider);
      /**
       * Provider for generating generic {@link OAuthCredential}.
       *
       * @example
       * ```javascript
       * // Sign in using a redirect.
       * const provider = new OAuthProvider('google.com');
       * // Start a sign in process for an unauthenticated user.
       * provider.addScope('profile');
       * provider.addScope('email');
       * await signInWithRedirect(auth, provider);
       * // This will trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * if (result) {
       *   // This is the signed-in user
       *   const user = result.user;
       *   // This gives you a OAuth Access Token for the provider.
       *   const credential = provider.credentialFromResult(auth, result);
       *   const token = credential.accessToken;
       * }
       * ```
       *
       * @example
       * ```javascript
       * // Sign in using a popup.
       * const provider = new OAuthProvider('google.com');
       * provider.addScope('profile');
       * provider.addScope('email');
       * const result = await signInWithPopup(auth, provider);
       *
       * // The signed-in user info.
       * const user = result.user;
       * // This gives you a OAuth Access Token for the provider.
       * const credential = provider.credentialFromResult(auth, result);
       * const token = credential.accessToken;
       * ```
       * @public
       */


      var OAuthProvider = /*#__PURE__*/function (_BaseOAuthProvider) {
        _inherits(OAuthProvider, _BaseOAuthProvider);

        var _super5 = _createSuper(OAuthProvider);

        function OAuthProvider() {
          _classCallCheck(this, OAuthProvider);

          return _super5.apply(this, arguments);
        }

        _createClass(OAuthProvider, [{
          key: "credential",
          value:
          /**
           * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.
           *
           * @remarks
           * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of
           * the raw nonce must match the nonce field in the ID token.
           *
           * @example
           * ```javascript
           * // `googleUser` from the onsuccess Google Sign In callback.
           * // Initialize a generate OAuth provider with a `google.com` providerId.
           * const provider = new OAuthProvider('google.com');
           * const credential = provider.credential({
           *   idToken: googleUser.getAuthResponse().id_token,
           * });
           * const result = await signInWithCredential(credential);
           * ```
           *
           * @param params - Either the options object containing the ID token, access token and raw nonce
           * or the ID token string.
           */
          function credential(params) {
            return this._credential(Object.assign(Object.assign({}, params), {
              nonce: params.rawNonce
            }));
          }
          /** An internal credential method that accepts more permissive options */

        }, {
          key: "_credential",
          value: function _credential(params) {
            _assert(params.idToken || params.accessToken, "argument-error"
            /* ARGUMENT_ERROR */
            ); // For OAuthCredential, sign in method is same as providerId.


            return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), {
              providerId: this.providerId,
              signInMethod: this.providerId
            }));
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
           *
           * @param userCredential - The user credential.
           */

        }], [{
          key: "credentialFromJSON",
          value:
          /**
           * Creates an {@link OAuthCredential} from a JSON string or a plain object.
           * @param json - A plain object or a JSON string
           */
          function credentialFromJSON(json) {
            var obj = typeof json === 'string' ? JSON.parse(json) : json;

            _assert('providerId' in obj && 'signInMethod' in obj, "argument-error"
            /* ARGUMENT_ERROR */
            );

            return OAuthCredential._fromParams(obj);
          }
        }, {
          key: "credentialFromResult",
          value: function credentialFromResult(userCredential) {
            return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
           * thrown during a sign-in, link, or reauthenticate operation.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromError",
          value: function credentialFromError(error) {
            return OAuthProvider.oauthCredentialFromTaggedObject(error.customData || {});
          }
        }, {
          key: "oauthCredentialFromTaggedObject",
          value: function oauthCredentialFromTaggedObject(_ref13) {
            var tokenResponse = _ref13._tokenResponse;

            if (!tokenResponse) {
              return null;
            }

            var oauthIdToken = tokenResponse.oauthIdToken,
                oauthAccessToken = tokenResponse.oauthAccessToken,
                oauthTokenSecret = tokenResponse.oauthTokenSecret,
                pendingToken = tokenResponse.pendingToken,
                nonce = tokenResponse.nonce,
                providerId = tokenResponse.providerId;

            if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {
              return null;
            }

            if (!providerId) {
              return null;
            }

            try {
              return new OAuthProvider(providerId)._credential({
                idToken: oauthIdToken,
                accessToken: oauthAccessToken,
                nonce: nonce,
                pendingToken: pendingToken
              });
            } catch (e) {
              return null;
            }
          }
        }]);

        return OAuthProvider;
      }(BaseOAuthProvider);
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.
       *
       * @example
       * ```javascript
       * // Sign in using a redirect.
       * const provider = new FacebookAuthProvider();
       * // Start a sign in process for an unauthenticated user.
       * provider.addScope('user_birthday');
       * await signInWithRedirect(auth, provider);
       * // This will trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * if (result) {
       *   // This is the signed-in user
       *   const user = result.user;
       *   // This gives you a Facebook Access Token.
       *   const credential = provider.credentialFromResult(auth, result);
       *   const token = credential.accessToken;
       * }
       * ```
       *
       * @example
       * ```javascript
       * // Sign in using a popup.
       * const provider = new FacebookAuthProvider();
       * provider.addScope('user_birthday');
       * const result = await signInWithPopup(auth, provider);
       *
       * // The signed-in user info.
       * const user = result.user;
       * // This gives you a Facebook Access Token.
       * const credential = provider.credentialFromResult(auth, result);
       * const token = credential.accessToken;
       * ```
       *
       * @public
       */


      var FacebookAuthProvider = /*#__PURE__*/function (_BaseOAuthProvider2) {
        _inherits(FacebookAuthProvider, _BaseOAuthProvider2);

        var _super6 = _createSuper(FacebookAuthProvider);

        function FacebookAuthProvider() {
          _classCallCheck(this, FacebookAuthProvider);

          return _super6.call(this, "facebook.com"
          /* FACEBOOK */
          );
        }
        /**
         * Creates a credential for Facebook.
         *
         * @example
         * ```javascript
         * // `event` from the Facebook auth.authResponseChange callback.
         * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);
         * const result = await signInWithCredential(credential);
         * ```
         *
         * @param accessToken - Facebook access token.
         */


        _createClass(FacebookAuthProvider, null, [{
          key: "credential",
          value: function credential(accessToken) {
            return OAuthCredential._fromParams({
              providerId: FacebookAuthProvider.PROVIDER_ID,
              signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
              accessToken: accessToken
            });
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromResult",
          value: function credentialFromResult(userCredential) {
            return FacebookAuthProvider.credentialFromTaggedObject(userCredential);
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
           * thrown during a sign-in, link, or reauthenticate operation.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromError",
          value: function credentialFromError(error) {
            return FacebookAuthProvider.credentialFromTaggedObject(error.customData || {});
          }
        }, {
          key: "credentialFromTaggedObject",
          value: function credentialFromTaggedObject(_ref14) {
            var tokenResponse = _ref14._tokenResponse;

            if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {
              return null;
            }

            if (!tokenResponse.oauthAccessToken) {
              return null;
            }

            try {
              return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);
            } catch (_a) {
              return null;
            }
          }
        }]);

        return FacebookAuthProvider;
      }(BaseOAuthProvider);
      /** Always set to {@link SignInMethod}.FACEBOOK. */


      FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com"
      /* FACEBOOK */
      ;
      /** Always set to {@link ProviderId}.FACEBOOK. */

      FacebookAuthProvider.PROVIDER_ID = "facebook.com"
      /* FACEBOOK */
      ;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Provider for generating an an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.
       *
       * @example
       * ```javascript
       * // Sign in using a redirect.
       * const provider = new GoogleAuthProvider();
       * // Start a sign in process for an unauthenticated user.
       * provider.addScope('profile');
       * provider.addScope('email');
       * await signInWithRedirect(auth, provider);
       * // This will trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * if (result) {
       *   // This is the signed-in user
       *   const user = result.user;
       *   // This gives you a Google Access Token.
       *   const credential = provider.credentialFromResult(auth, result);
       *   const token = credential.accessToken;
       * }
       * ```
       *
       * @example
       * ```javascript
       * // Sign in using a popup.
       * const provider = new GoogleAuthProvider();
       * provider.addScope('profile');
       * provider.addScope('email');
       * const result = await signInWithPopup(auth, provider);
       *
       * // The signed-in user info.
       * const user = result.user;
       * // This gives you a Google Access Token.
       * const credential = provider.credentialFromResult(auth, result);
       * const token = credential.accessToken;
       * ```
       *
       * @public
       */

      var GoogleAuthProvider = /*#__PURE__*/function (_BaseOAuthProvider3) {
        _inherits(GoogleAuthProvider, _BaseOAuthProvider3);

        var _super7 = _createSuper(GoogleAuthProvider);

        function GoogleAuthProvider() {
          var _this14;

          _classCallCheck(this, GoogleAuthProvider);

          _this14 = _super7.call(this, "google.com"
          /* GOOGLE */
          );

          _this14.addScope('profile');

          return _this14;
        }
        /**
         * Creates a credential for Google. At least one of ID token and access token is required.
         *
         * @example
         * ```javascript
         * // \`googleUser\` from the onsuccess Google Sign In callback.
         * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);
         * const result = await signInWithCredential(credential);
         * ```
         *
         * @param idToken - Google ID token.
         * @param accessToken - Google access token.
         */


        _createClass(GoogleAuthProvider, null, [{
          key: "credential",
          value: function credential(idToken, accessToken) {
            return OAuthCredential._fromParams({
              providerId: GoogleAuthProvider.PROVIDER_ID,
              signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
              idToken: idToken,
              accessToken: accessToken
            });
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromResult",
          value: function credentialFromResult(userCredential) {
            return GoogleAuthProvider.credentialFromTaggedObject(userCredential);
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
           * thrown during a sign-in, link, or reauthenticate operation.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromError",
          value: function credentialFromError(error) {
            return GoogleAuthProvider.credentialFromTaggedObject(error.customData || {});
          }
        }, {
          key: "credentialFromTaggedObject",
          value: function credentialFromTaggedObject(_ref15) {
            var tokenResponse = _ref15._tokenResponse;

            if (!tokenResponse) {
              return null;
            }

            var oauthIdToken = tokenResponse.oauthIdToken,
                oauthAccessToken = tokenResponse.oauthAccessToken;

            if (!oauthIdToken && !oauthAccessToken) {
              // This could be an oauth 1 credential or a phone credential
              return null;
            }

            try {
              return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);
            } catch (_a) {
              return null;
            }
          }
        }]);

        return GoogleAuthProvider;
      }(BaseOAuthProvider);
      /** Always set to {@link SignInMethod}.GOOGLE. */


      GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com"
      /* GOOGLE */
      ;
      /** Always set to {@link ProviderId}.GOOGLE. */

      GoogleAuthProvider.PROVIDER_ID = "google.com"
      /* GOOGLE */
      ;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.
       *
       * @remarks
       * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use
       * the {@link signInWithPopup} handler:
       *
       * @example
       * ```javascript
       * // Sign in using a redirect.
       * const provider = new GithubAuthProvider();
       * // Start a sign in process for an unauthenticated user.
       * provider.addScope('repo');
       * await signInWithRedirect(auth, provider);
       * // This will trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * if (result) {
       *   // This is the signed-in user
       *   const user = result.user;
       *   // This gives you a Github Access Token.
       *   const credential = provider.credentialFromResult(auth, result);
       *   const token = credential.accessToken;
       * }
       * ```
       *
       * @example
       * ```javascript
       * // Sign in using a popup.
       * const provider = new GithubAuthProvider();
       * provider.addScope('repo');
       * const result = await signInWithPopup(auth, provider);
       *
       * // The signed-in user info.
       * const user = result.user;
       * // This gives you a Github Access Token.
       * const credential = provider.credentialFromResult(auth, result);
       * const token = credential.accessToken;
       * ```
       * @public
       */

      var GithubAuthProvider = /*#__PURE__*/function (_BaseOAuthProvider4) {
        _inherits(GithubAuthProvider, _BaseOAuthProvider4);

        var _super8 = _createSuper(GithubAuthProvider);

        function GithubAuthProvider() {
          _classCallCheck(this, GithubAuthProvider);

          return _super8.call(this, "github.com"
          /* GITHUB */
          );
        }
        /**
         * Creates a credential for Github.
         *
         * @param accessToken - Github access token.
         */


        _createClass(GithubAuthProvider, null, [{
          key: "credential",
          value: function credential(accessToken) {
            return OAuthCredential._fromParams({
              providerId: GithubAuthProvider.PROVIDER_ID,
              signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
              accessToken: accessToken
            });
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromResult",
          value: function credentialFromResult(userCredential) {
            return GithubAuthProvider.credentialFromTaggedObject(userCredential);
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
           * thrown during a sign-in, link, or reauthenticate operation.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromError",
          value: function credentialFromError(error) {
            return GithubAuthProvider.credentialFromTaggedObject(error.customData || {});
          }
        }, {
          key: "credentialFromTaggedObject",
          value: function credentialFromTaggedObject(_ref16) {
            var tokenResponse = _ref16._tokenResponse;

            if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {
              return null;
            }

            if (!tokenResponse.oauthAccessToken) {
              return null;
            }

            try {
              return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);
            } catch (_a) {
              return null;
            }
          }
        }]);

        return GithubAuthProvider;
      }(BaseOAuthProvider);
      /** Always set to {@link SignInMethod}.GITHUB. */


      GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com"
      /* GITHUB */
      ;
      /** Always set to {@link ProviderId}.GITHUB. */

      GithubAuthProvider.PROVIDER_ID = "github.com"
      /* GITHUB */
      ;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      var IDP_REQUEST_URI = 'http://localhost';
      /**
       * @public
       */

      var SAMLAuthCredential = /*#__PURE__*/function (_AuthCredential4) {
        _inherits(SAMLAuthCredential, _AuthCredential4);

        var _super9 = _createSuper(SAMLAuthCredential);

        /** @internal */
        function SAMLAuthCredential(providerId, pendingToken) {
          var _this15;

          _classCallCheck(this, SAMLAuthCredential);

          _this15 = _super9.call(this, providerId, providerId);
          _this15.pendingToken = pendingToken;
          return _this15;
        }
        /** @internal */


        _createClass(SAMLAuthCredential, [{
          key: "_getIdTokenResponse",
          value: function _getIdTokenResponse(auth) {
            var request = this.buildRequest();
            return signInWithIdp(auth, request);
          }
          /** @internal */

        }, {
          key: "_linkToIdToken",
          value: function _linkToIdToken(auth, idToken) {
            var request = this.buildRequest();
            request.idToken = idToken;
            return signInWithIdp(auth, request);
          }
          /** @internal */

        }, {
          key: "_getReauthenticationResolver",
          value: function _getReauthenticationResolver(auth) {
            var request = this.buildRequest();
            request.autoCreate = false;
            return signInWithIdp(auth, request);
          }
          /** {@inheritdoc AuthCredential.toJSON}  */

        }, {
          key: "toJSON",
          value: function toJSON() {
            return {
              signInMethod: this.signInMethod,
              providerId: this.providerId,
              pendingToken: this.pendingToken
            };
          }
          /**
           * Static method to deserialize a JSON representation of an object into an
           * {@link  AuthCredential}.
           *
           * @param json - Input can be either Object or the stringified representation of the object.
           * When string is provided, JSON.parse would be called first.
           *
           * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
           */

        }, {
          key: "buildRequest",
          value: function buildRequest() {
            return {
              requestUri: IDP_REQUEST_URI,
              returnSecureToken: true,
              pendingToken: this.pendingToken
            };
          }
        }], [{
          key: "fromJSON",
          value: function fromJSON(json) {
            var obj = typeof json === 'string' ? JSON.parse(json) : json;
            var providerId = obj.providerId,
                signInMethod = obj.signInMethod,
                pendingToken = obj.pendingToken;

            if (!providerId || !signInMethod || !pendingToken || providerId !== signInMethod) {
              return null;
            }

            return new SAMLAuthCredential(providerId, pendingToken);
          }
          /**
           * Helper static method to avoid exposing the constructor to end users.
           *
           * @internal
           */

        }, {
          key: "_create",
          value: function _create(providerId, pendingToken) {
            return new SAMLAuthCredential(providerId, pendingToken);
          }
        }]);

        return SAMLAuthCredential;
      }(AuthCredential);
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var SAML_PROVIDER_PREFIX = 'saml.';
      /**
       * An {@link AuthProvider} for SAML.
       *
       * @public
       */

      var SAMLAuthProvider = /*#__PURE__*/function (_FederatedAuthProvide2) {
        _inherits(SAMLAuthProvider, _FederatedAuthProvide2);

        var _super10 = _createSuper(SAMLAuthProvider);

        /**
         * Constructor. The providerId must start with "saml."
         * @param providerId - SAML provider ID.
         */
        function SAMLAuthProvider(providerId) {
          _classCallCheck(this, SAMLAuthProvider);

          _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), "argument-error"
          /* ARGUMENT_ERROR */
          );

          return _super10.call(this, providerId);
        }
        /**
         * Generates an {@link AuthCredential} from a {@link UserCredential} after a
         * successful SAML flow completes.
         *
         * @remarks
         *
         * For example, to get an {@link AuthCredential}, you could write the
         * following code:
         *
         * ```js
         * const userCredential = await signInWithPopup(auth, samlProvider);
         * const credential = SAMLAuthProvider.credentialFromResult(userCredential);
         * ```
         *
         * @param userCredential - The user credential.
         */


        _createClass(SAMLAuthProvider, null, [{
          key: "credentialFromResult",
          value: function credentialFromResult(userCredential) {
            return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
           * thrown during a sign-in, link, or reauthenticate operation.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromError",
          value: function credentialFromError(error) {
            return SAMLAuthProvider.samlCredentialFromTaggedObject(error.customData || {});
          }
          /**
           * Creates an {@link AuthCredential} from a JSON string or a plain object.
           * @param json - A plain object or a JSON string
           */

        }, {
          key: "credentialFromJSON",
          value: function credentialFromJSON(json) {
            var credential = SAMLAuthCredential.fromJSON(json);

            _assert(credential, "argument-error"
            /* ARGUMENT_ERROR */
            );

            return credential;
          }
        }, {
          key: "samlCredentialFromTaggedObject",
          value: function samlCredentialFromTaggedObject(_ref17) {
            var tokenResponse = _ref17._tokenResponse;

            if (!tokenResponse) {
              return null;
            }

            var pendingToken = tokenResponse.pendingToken,
                providerId = tokenResponse.providerId;

            if (!pendingToken || !providerId) {
              return null;
            }

            try {
              return SAMLAuthCredential._create(providerId, pendingToken);
            } catch (e) {
              return null;
            }
          }
        }]);

        return SAMLAuthProvider;
      }(FederatedAuthProvider);
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.
       *
       * @example
       * ```javascript
       * // Sign in using a redirect.
       * const provider = new TwitterAuthProvider();
       * // Start a sign in process for an unauthenticated user.
       * await signInWithRedirect(auth, provider);
       * // This will trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * if (result) {
       *   // This is the signed-in user
       *   const user = result.user;
       *   // This gives you a Twitter Access Token and Secret.
       *   const credential = provider.credentialFromResult(auth, result);
       *   const token = credential.accessToken;
       *   const secret = credential.secret;
       * }
       * ```
       *
       * @example
       * ```javascript
       * // Sign in using a popup.
       * const provider = new TwitterAuthProvider();
       * const result = await signInWithPopup(auth, provider);
       *
       * // The signed-in user info.
       * const user = result.user;
       * // This gives you a Twitter Access Token and Secret.
       * const credential = provider.credentialFromResult(auth, result);
       * const token = credential.accessToken;
       * const secret = credential.secret;
       * ```
       *
       * @public
       */


      var TwitterAuthProvider = /*#__PURE__*/function (_BaseOAuthProvider5) {
        _inherits(TwitterAuthProvider, _BaseOAuthProvider5);

        var _super11 = _createSuper(TwitterAuthProvider);

        function TwitterAuthProvider() {
          _classCallCheck(this, TwitterAuthProvider);

          return _super11.call(this, "twitter.com"
          /* TWITTER */
          );
        }
        /**
         * Creates a credential for Twitter.
         *
         * @param token - Twitter access token.
         * @param secret - Twitter secret.
         */


        _createClass(TwitterAuthProvider, null, [{
          key: "credential",
          value: function credential(token, secret) {
            return OAuthCredential._fromParams({
              providerId: TwitterAuthProvider.PROVIDER_ID,
              signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
              oauthToken: token,
              oauthTokenSecret: secret
            });
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromResult",
          value: function credentialFromResult(userCredential) {
            return TwitterAuthProvider.credentialFromTaggedObject(userCredential);
          }
          /**
           * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
           * thrown during a sign-in, link, or reauthenticate operation.
           *
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromError",
          value: function credentialFromError(error) {
            return TwitterAuthProvider.credentialFromTaggedObject(error.customData || {});
          }
        }, {
          key: "credentialFromTaggedObject",
          value: function credentialFromTaggedObject(_ref18) {
            var tokenResponse = _ref18._tokenResponse;

            if (!tokenResponse) {
              return null;
            }

            var oauthAccessToken = tokenResponse.oauthAccessToken,
                oauthTokenSecret = tokenResponse.oauthTokenSecret;

            if (!oauthAccessToken || !oauthTokenSecret) {
              return null;
            }

            try {
              return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);
            } catch (_a) {
              return null;
            }
          }
        }]);

        return TwitterAuthProvider;
      }(BaseOAuthProvider);
      /** Always set to {@link SignInMethod}.TWITTER. */


      TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com"
      /* TWITTER */
      ;
      /** Always set to {@link ProviderId}.TWITTER. */

      TwitterAuthProvider.PROVIDER_ID = "twitter.com"
      /* TWITTER */
      ;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      function signUp(_x112, _x113) {
        return _signUp.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _signUp() {
        _signUp = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee132(auth, request) {
          return regeneratorRuntime.wrap(function _callee132$(_context132) {
            while (1) {
              switch (_context132.prev = _context132.next) {
                case 0:
                  return _context132.abrupt("return", _performSignInRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:signUp"
                  /* SIGN_UP */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context132.stop();
              }
            }
          }, _callee132);
        }));
        return _signUp.apply(this, arguments);
      }

      var UserCredentialImpl = /*#__PURE__*/function () {
        function UserCredentialImpl(params) {
          _classCallCheck(this, UserCredentialImpl);

          this.user = params.user;
          this.providerId = params.providerId;
          this._tokenResponse = params._tokenResponse;
          this.operationType = params.operationType;
        }

        _createClass(UserCredentialImpl, null, [{
          key: "_fromIdTokenResponse",
          value: function () {
            var _fromIdTokenResponse3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee57(auth, operationType, idTokenResponse) {
              var isAnonymous,
                  user,
                  providerId,
                  userCred,
                  _args57 = arguments;
              return regeneratorRuntime.wrap(function _callee57$(_context57) {
                while (1) {
                  switch (_context57.prev = _context57.next) {
                    case 0:
                      isAnonymous = _args57.length > 3 && _args57[3] !== undefined ? _args57[3] : false;
                      _context57.next = 3;
                      return UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);

                    case 3:
                      user = _context57.sent;
                      providerId = providerIdForResponse(idTokenResponse);
                      userCred = new UserCredentialImpl({
                        user: user,
                        providerId: providerId,
                        _tokenResponse: idTokenResponse,
                        operationType: operationType
                      });
                      return _context57.abrupt("return", userCred);

                    case 7:
                    case "end":
                      return _context57.stop();
                  }
                }
              }, _callee57);
            }));

            function _fromIdTokenResponse(_x114, _x115, _x116) {
              return _fromIdTokenResponse3.apply(this, arguments);
            }

            return _fromIdTokenResponse;
          }()
        }, {
          key: "_forOperation",
          value: function () {
            var _forOperation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee58(user, operationType, response) {
              var providerId;
              return regeneratorRuntime.wrap(function _callee58$(_context58) {
                while (1) {
                  switch (_context58.prev = _context58.next) {
                    case 0:
                      _context58.next = 2;
                      return user._updateTokensIfNecessary(response,
                      /* reload */
                      true);

                    case 2:
                      providerId = providerIdForResponse(response);
                      return _context58.abrupt("return", new UserCredentialImpl({
                        user: user,
                        providerId: providerId,
                        _tokenResponse: response,
                        operationType: operationType
                      }));

                    case 4:
                    case "end":
                      return _context58.stop();
                  }
                }
              }, _callee58);
            }));

            function _forOperation(_x117, _x118, _x119) {
              return _forOperation2.apply(this, arguments);
            }

            return _forOperation;
          }()
        }]);

        return UserCredentialImpl;
      }();

      function providerIdForResponse(response) {
        if (response.providerId) {
          return response.providerId;
        }

        if ('phoneNumber' in response) {
          return "phone"
          /* PHONE */
          ;
        }

        return null;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Asynchronously signs in as an anonymous user.
       *
       * @remarks
       * If there is already an anonymous user signed in, that user will be returned; otherwise, a
       * new anonymous user identity will be created and returned.
       *
       * @param auth - The {@link Auth} instance.
       *
       * @public
       */


      function signInAnonymously(_x120) {
        return _signInAnonymously.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _signInAnonymously() {
        _signInAnonymously = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee133(auth) {
          var _a, authInternal, response, userCredential;

          return regeneratorRuntime.wrap(function _callee133$(_context133) {
            while (1) {
              switch (_context133.prev = _context133.next) {
                case 0:
                  authInternal = _castAuth(auth);
                  _context133.next = 3;
                  return authInternal._initializationPromise;

                case 3:
                  if (!((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
                    _context133.next = 5;
                    break;
                  }

                  return _context133.abrupt("return", new UserCredentialImpl({
                    user: authInternal.currentUser,
                    providerId: null,
                    operationType: "signIn"
                    /* SIGN_IN */

                  }));

                case 5:
                  _context133.next = 7;
                  return signUp(authInternal, {
                    returnSecureToken: true
                  });

                case 7:
                  response = _context133.sent;
                  _context133.next = 10;
                  return UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn"
                  /* SIGN_IN */
                  , response, true);

                case 10:
                  userCredential = _context133.sent;
                  _context133.next = 13;
                  return authInternal._updateCurrentUser(userCredential.user);

                case 13:
                  return _context133.abrupt("return", userCredential);

                case 14:
                case "end":
                  return _context133.stop();
              }
            }
          }, _callee133);
        }));
        return _signInAnonymously.apply(this, arguments);
      }

      var MultiFactorError = /*#__PURE__*/function (_firebase_util__WEBPA) {
        _inherits(MultiFactorError, _firebase_util__WEBPA);

        var _super12 = _createSuper(MultiFactorError);

        function MultiFactorError(auth, error, operationType, user) {
          var _this16;

          _classCallCheck(this, MultiFactorError);

          var _a;

          _this16 = _super12.call(this, error.code, error.message);
          _this16.operationType = operationType;
          _this16.user = user; // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work

          Object.setPrototypeOf(_assertThisInitialized(_this16), MultiFactorError.prototype);
          _this16.customData = {
            appName: auth.name,
            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,
            _serverResponse: error.customData._serverResponse,
            operationType: operationType
          };
          return _this16;
        }

        _createClass(MultiFactorError, null, [{
          key: "_fromErrorAndOperation",
          value: function _fromErrorAndOperation(auth, error, operationType, user) {
            return new MultiFactorError(auth, error, operationType, user);
          }
        }]);

        return MultiFactorError;
      }(_firebase_util__WEBPACK_IMPORTED_MODULE_0__.FirebaseError);

      function _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {
        var idTokenProvider = operationType === "reauthenticate"
        /* REAUTHENTICATE */
        ? credential._getReauthenticationResolver(auth) : credential._getIdTokenResponse(auth);
        return idTokenProvider["catch"](function (error) {
          if (error.code === "auth/".concat("multi-factor-auth-required"
          /* MFA_REQUIRED */
          )) {
            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);
          }

          throw error;
        });
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Takes a set of UserInfo provider data and converts it to a set of names
       */


      function providerDataAsNames(providerData) {
        return new Set(providerData.map(function (_ref19) {
          var providerId = _ref19.providerId;
          return providerId;
        }).filter(function (pid) {
          return !!pid;
        }));
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Unlinks a provider from a user account.
       *
       * @param user - The user.
       * @param providerId - The provider to unlink.
       *
       * @public
       */


      function unlink(_x121, _x122) {
        return _unlink2.apply(this, arguments);
      }

      function _unlink2() {
        _unlink2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee134(user, providerId) {
          var userInternal, _yield$deleteLinkedAc, providerUserInfo, providersLeft;

          return regeneratorRuntime.wrap(function _callee134$(_context134) {
            while (1) {
              switch (_context134.prev = _context134.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);
                  _context134.next = 3;
                  return _assertLinkedStatus(true, userInternal, providerId);

                case 3:
                  _context134.t0 = deleteLinkedAccounts;
                  _context134.t1 = userInternal.auth;
                  _context134.next = 7;
                  return userInternal.getIdToken();

                case 7:
                  _context134.t2 = _context134.sent;
                  _context134.t3 = [providerId];
                  _context134.t4 = {
                    idToken: _context134.t2,
                    deleteProvider: _context134.t3
                  };
                  _context134.next = 12;
                  return (0, _context134.t0)(_context134.t1, _context134.t4);

                case 12:
                  _yield$deleteLinkedAc = _context134.sent;
                  providerUserInfo = _yield$deleteLinkedAc.providerUserInfo;
                  providersLeft = providerDataAsNames(providerUserInfo || []);
                  userInternal.providerData = userInternal.providerData.filter(function (pd) {
                    return providersLeft.has(pd.providerId);
                  });

                  if (!providersLeft.has("phone"
                  /* PHONE */
                  )) {
                    userInternal.phoneNumber = null;
                  }

                  _context134.next = 19;
                  return userInternal.auth._persistUserIfCurrent(userInternal);

                case 19:
                  return _context134.abrupt("return", userInternal);

                case 20:
                case "end":
                  return _context134.stop();
              }
            }
          }, _callee134);
        }));
        return _unlink2.apply(this, arguments);
      }

      function _link$1(_x123, _x124) {
        return _link$.apply(this, arguments);
      }

      function _link$() {
        _link$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee135(user, credential) {
          var bypassAuthState,
              response,
              _args135 = arguments;
          return regeneratorRuntime.wrap(function _callee135$(_context135) {
            while (1) {
              switch (_context135.prev = _context135.next) {
                case 0:
                  bypassAuthState = _args135.length > 2 && _args135[2] !== undefined ? _args135[2] : false;
                  _context135.t0 = _logoutIfInvalidated;
                  _context135.t1 = user;
                  _context135.t2 = credential;
                  _context135.t3 = user.auth;
                  _context135.next = 7;
                  return user.getIdToken();

                case 7:
                  _context135.t4 = _context135.sent;
                  _context135.t5 = _context135.t2._linkToIdToken.call(_context135.t2, _context135.t3, _context135.t4);
                  _context135.t6 = bypassAuthState;
                  _context135.next = 12;
                  return (0, _context135.t0)(_context135.t1, _context135.t5, _context135.t6);

                case 12:
                  response = _context135.sent;
                  return _context135.abrupt("return", UserCredentialImpl._forOperation(user, "link"
                  /* LINK */
                  , response));

                case 14:
                case "end":
                  return _context135.stop();
              }
            }
          }, _callee135);
        }));
        return _link$.apply(this, arguments);
      }

      function _assertLinkedStatus(_x125, _x126, _x127) {
        return _assertLinkedStatus2.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _assertLinkedStatus2() {
        _assertLinkedStatus2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee136(expected, user, provider) {
          var providerIds, code;
          return regeneratorRuntime.wrap(function _callee136$(_context136) {
            while (1) {
              switch (_context136.prev = _context136.next) {
                case 0:
                  _context136.next = 2;
                  return _reloadWithoutSaving(user);

                case 2:
                  providerIds = providerDataAsNames(user.providerData);
                  code = expected === false ? "provider-already-linked"
                  /* PROVIDER_ALREADY_LINKED */
                  : "no-such-provider";

                  _assert(providerIds.has(provider) === expected, user.auth, code);

                case 5:
                case "end":
                  return _context136.stop();
              }
            }
          }, _callee136);
        }));
        return _assertLinkedStatus2.apply(this, arguments);
      }

      function _reauthenticate(_x128, _x129) {
        return _reauthenticate2.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _reauthenticate2() {
        _reauthenticate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee137(user, credential) {
          var bypassAuthState,
              auth,
              operationType,
              response,
              parsed,
              localId,
              _args137 = arguments;
          return regeneratorRuntime.wrap(function _callee137$(_context137) {
            while (1) {
              switch (_context137.prev = _context137.next) {
                case 0:
                  bypassAuthState = _args137.length > 2 && _args137[2] !== undefined ? _args137[2] : false;
                  auth = user.auth;
                  operationType = "reauthenticate";
                  _context137.prev = 3;
                  _context137.next = 6;
                  return _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);

                case 6:
                  response = _context137.sent;

                  _assert(response.idToken, auth, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  parsed = _parseToken(response.idToken);

                  _assert(parsed, auth, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  localId = parsed.sub;

                  _assert(user.uid === localId, auth, "user-mismatch"
                  /* USER_MISMATCH */
                  );

                  return _context137.abrupt("return", UserCredentialImpl._forOperation(user, operationType, response));

                case 15:
                  _context137.prev = 15;
                  _context137.t0 = _context137["catch"](3);

                  // Convert user deleted error into user mismatch
                  if ((_context137.t0 === null || _context137.t0 === void 0 ? void 0 : _context137.t0.code) === "auth/".concat("user-not-found"
                  /* USER_DELETED */
                  )) {
                    _fail(auth, "user-mismatch"
                    /* USER_MISMATCH */
                    );
                  }

                  throw _context137.t0;

                case 19:
                case "end":
                  return _context137.stop();
              }
            }
          }, _callee137, null, [[3, 15]]);
        }));
        return _reauthenticate2.apply(this, arguments);
      }

      function _signInWithCredential(_x130, _x131) {
        return _signInWithCredential2.apply(this, arguments);
      }
      /**
       * Asynchronously signs in with the given credentials.
       *
       * @remarks
       * An {@link AuthProvider} can be used to generate the credential.
       *
       * @param auth - The {@link Auth} instance.
       * @param credential - The auth credential.
       *
       * @public
       */


      function _signInWithCredential2() {
        _signInWithCredential2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee138(auth, credential) {
          var bypassAuthState,
              operationType,
              response,
              userCredential,
              _args138 = arguments;
          return regeneratorRuntime.wrap(function _callee138$(_context138) {
            while (1) {
              switch (_context138.prev = _context138.next) {
                case 0:
                  bypassAuthState = _args138.length > 2 && _args138[2] !== undefined ? _args138[2] : false;
                  operationType = "signIn";
                  _context138.next = 4;
                  return _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);

                case 4:
                  response = _context138.sent;
                  _context138.next = 7;
                  return UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);

                case 7:
                  userCredential = _context138.sent;

                  if (bypassAuthState) {
                    _context138.next = 11;
                    break;
                  }

                  _context138.next = 11;
                  return auth._updateCurrentUser(userCredential.user);

                case 11:
                  return _context138.abrupt("return", userCredential);

                case 12:
                case "end":
                  return _context138.stop();
              }
            }
          }, _callee138);
        }));
        return _signInWithCredential2.apply(this, arguments);
      }

      function signInWithCredential(_x132, _x133) {
        return _signInWithCredential3.apply(this, arguments);
      }
      /**
       * Links the user account with the given credentials.
       *
       * @remarks
       * An {@link AuthProvider} can be used to generate the credential.
       *
       * @param user - The user.
       * @param credential - The auth credential.
       *
       * @public
       */


      function _signInWithCredential3() {
        _signInWithCredential3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee139(auth, credential) {
          return regeneratorRuntime.wrap(function _callee139$(_context139) {
            while (1) {
              switch (_context139.prev = _context139.next) {
                case 0:
                  return _context139.abrupt("return", _signInWithCredential(_castAuth(auth), credential));

                case 1:
                case "end":
                  return _context139.stop();
              }
            }
          }, _callee139);
        }));
        return _signInWithCredential3.apply(this, arguments);
      }

      function linkWithCredential(_x134, _x135) {
        return _linkWithCredential2.apply(this, arguments);
      }
      /**
       * Re-authenticates a user using a fresh credential.
       *
       * @remarks
       * Use before operations such as {@link updatePassword} that require tokens from recent sign-in
       * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error.
       *
       * @param user - The user.
       * @param credential - The auth credential.
       *
       * @public
       */


      function _linkWithCredential2() {
        _linkWithCredential2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee140(user, credential) {
          var userInternal;
          return regeneratorRuntime.wrap(function _callee140$(_context140) {
            while (1) {
              switch (_context140.prev = _context140.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);
                  _context140.next = 3;
                  return _assertLinkedStatus(false, userInternal, credential.providerId);

                case 3:
                  return _context140.abrupt("return", _link$1(userInternal, credential));

                case 4:
                case "end":
                  return _context140.stop();
              }
            }
          }, _callee140);
        }));
        return _linkWithCredential2.apply(this, arguments);
      }

      function reauthenticateWithCredential(_x136, _x137) {
        return _reauthenticateWithCredential2.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _reauthenticateWithCredential2() {
        _reauthenticateWithCredential2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee141(user, credential) {
          return regeneratorRuntime.wrap(function _callee141$(_context141) {
            while (1) {
              switch (_context141.prev = _context141.next) {
                case 0:
                  return _context141.abrupt("return", _reauthenticate((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user), credential));

                case 1:
                case "end":
                  return _context141.stop();
              }
            }
          }, _callee141);
        }));
        return _reauthenticateWithCredential2.apply(this, arguments);
      }

      function signInWithCustomToken$1(_x138, _x139) {
        return _signInWithCustomToken$.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Asynchronously signs in using a custom token.
       *
       * @remarks
       * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must
       * be generated by an auth backend using the
       * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}
       * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .
       *
       * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.
       *
       * @param auth - The {@link Auth} instance.
       * @param customToken - The custom token to sign in with.
       *
       * @public
       */


      function _signInWithCustomToken$() {
        _signInWithCustomToken$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee142(auth, request) {
          return regeneratorRuntime.wrap(function _callee142$(_context142) {
            while (1) {
              switch (_context142.prev = _context142.next) {
                case 0:
                  return _context142.abrupt("return", _performSignInRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:signInWithCustomToken"
                  /* SIGN_IN_WITH_CUSTOM_TOKEN */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context142.stop();
              }
            }
          }, _callee142);
        }));
        return _signInWithCustomToken$.apply(this, arguments);
      }

      function signInWithCustomToken(_x140, _x141) {
        return _signInWithCustomToken.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _signInWithCustomToken() {
        _signInWithCustomToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee143(auth, customToken) {
          var authInternal, response, cred;
          return regeneratorRuntime.wrap(function _callee143$(_context143) {
            while (1) {
              switch (_context143.prev = _context143.next) {
                case 0:
                  authInternal = _castAuth(auth);
                  _context143.next = 3;
                  return signInWithCustomToken$1(authInternal, {
                    token: customToken,
                    returnSecureToken: true
                  });

                case 3:
                  response = _context143.sent;
                  _context143.next = 6;
                  return UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn"
                  /* SIGN_IN */
                  , response);

                case 6:
                  cred = _context143.sent;
                  _context143.next = 9;
                  return authInternal._updateCurrentUser(cred.user);

                case 9:
                  return _context143.abrupt("return", cred);

                case 10:
                case "end":
                  return _context143.stop();
              }
            }
          }, _callee143);
        }));
        return _signInWithCustomToken.apply(this, arguments);
      }

      var MultiFactorInfoImpl = /*#__PURE__*/function () {
        function MultiFactorInfoImpl(factorId, response) {
          _classCallCheck(this, MultiFactorInfoImpl);

          this.factorId = factorId;
          this.uid = response.mfaEnrollmentId;
          this.enrollmentTime = new Date(response.enrolledAt).toUTCString();
          this.displayName = response.displayName;
        }

        _createClass(MultiFactorInfoImpl, null, [{
          key: "_fromServerResponse",
          value: function _fromServerResponse(auth, enrollment) {
            if ('phoneInfo' in enrollment) {
              return PhoneMultiFactorInfo._fromServerResponse(auth, enrollment);
            }

            return _fail(auth, "internal-error"
            /* INTERNAL_ERROR */
            );
          }
        }]);

        return MultiFactorInfoImpl;
      }();

      var PhoneMultiFactorInfo = /*#__PURE__*/function (_MultiFactorInfoImpl) {
        _inherits(PhoneMultiFactorInfo, _MultiFactorInfoImpl);

        var _super13 = _createSuper(PhoneMultiFactorInfo);

        function PhoneMultiFactorInfo(response) {
          var _this17;

          _classCallCheck(this, PhoneMultiFactorInfo);

          _this17 = _super13.call(this, "phone"
          /* PHONE */
          , response);
          _this17.phoneNumber = response.phoneInfo;
          return _this17;
        }

        _createClass(PhoneMultiFactorInfo, null, [{
          key: "_fromServerResponse",
          value: function _fromServerResponse(_auth, enrollment) {
            return new PhoneMultiFactorInfo(enrollment);
          }
        }]);

        return PhoneMultiFactorInfo;
      }(MultiFactorInfoImpl);
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {
        var _a;

        _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, "invalid-continue-uri"
        /* INVALID_CONTINUE_URI */
        );

        _assert(typeof actionCodeSettings.dynamicLinkDomain === 'undefined' || actionCodeSettings.dynamicLinkDomain.length > 0, auth, "invalid-dynamic-link-domain"
        /* INVALID_DYNAMIC_LINK_DOMAIN */
        );

        request.continueUrl = actionCodeSettings.url;
        request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
        request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;

        if (actionCodeSettings.iOS) {
          _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, "missing-ios-bundle-id"
          /* MISSING_IOS_BUNDLE_ID */
          );

          request.iOSBundleId = actionCodeSettings.iOS.bundleId;
        }

        if (actionCodeSettings.android) {
          _assert(actionCodeSettings.android.packageName.length > 0, auth, "missing-android-pkg-name"
          /* MISSING_ANDROID_PACKAGE_NAME */
          );

          request.androidInstallApp = actionCodeSettings.android.installApp;
          request.androidMinimumVersionCode = actionCodeSettings.android.minimumVersion;
          request.androidPackageName = actionCodeSettings.android.packageName;
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Sends a password reset email to the given email address.
       *
       * @remarks
       * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in
       * the email sent to the user, along with the new password specified by the user.
       *
       * @example
       * ```javascript
       * const actionCodeSettings = {
       *   url: 'https://www.example.com/?email=user@example.com',
       *   iOS: {
       *      bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true
       * };
       * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);
       * // Obtain code from user.
       * await confirmPasswordReset('user@example.com', code);
       * ```
       *
       * @param auth - The {@link Auth} instance.
       * @param email - The user's email address.
       * @param actionCodeSettings - The {@link ActionCodeSettings}.
       *
       * @public
       */


      function sendPasswordResetEmail(_x142, _x143, _x144) {
        return _sendPasswordResetEmail.apply(this, arguments);
      }
      /**
       * Completes the password reset process, given a confirmation code and new password.
       *
       * @param auth - The {@link Auth} instance.
       * @param oobCode - A confirmation code sent to the user.
       * @param newPassword - The new password.
       *
       * @public
       */


      function _sendPasswordResetEmail() {
        _sendPasswordResetEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee144(auth, email, actionCodeSettings) {
          var authModular, request;
          return regeneratorRuntime.wrap(function _callee144$(_context144) {
            while (1) {
              switch (_context144.prev = _context144.next) {
                case 0:
                  authModular = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth);
                  request = {
                    requestType: "PASSWORD_RESET"
                    /* PASSWORD_RESET */
                    ,
                    email: email
                  };

                  if (actionCodeSettings) {
                    _setActionCodeSettingsOnRequest(authModular, request, actionCodeSettings);
                  }

                  _context144.next = 5;
                  return sendPasswordResetEmail$1(authModular, request);

                case 5:
                case "end":
                  return _context144.stop();
              }
            }
          }, _callee144);
        }));
        return _sendPasswordResetEmail.apply(this, arguments);
      }

      function confirmPasswordReset(_x145, _x146, _x147) {
        return _confirmPasswordReset.apply(this, arguments);
      }
      /**
       * Applies a verification code sent to the user by email or other out-of-band mechanism.
       *
       * @param auth - The {@link Auth} instance.
       * @param oobCode - A verification code sent to the user.
       *
       * @public
       */


      function _confirmPasswordReset() {
        _confirmPasswordReset = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee145(auth, oobCode, newPassword) {
          return regeneratorRuntime.wrap(function _callee145$(_context145) {
            while (1) {
              switch (_context145.prev = _context145.next) {
                case 0:
                  _context145.next = 2;
                  return resetPassword((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth), {
                    oobCode: oobCode,
                    newPassword: newPassword
                  });

                case 2:
                case "end":
                  return _context145.stop();
              }
            }
          }, _callee145);
        }));
        return _confirmPasswordReset.apply(this, arguments);
      }

      function applyActionCode(_x148, _x149) {
        return _applyActionCode.apply(this, arguments);
      }
      /**
       * Checks a verification code sent to the user by email or other out-of-band mechanism.
       *
       * @returns metadata about the code.
       *
       * @param auth - The {@link Auth} instance.
       * @param oobCode - A verification code sent to the user.
       *
       * @public
       */


      function _applyActionCode() {
        _applyActionCode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee146(auth, oobCode) {
          return regeneratorRuntime.wrap(function _callee146$(_context146) {
            while (1) {
              switch (_context146.prev = _context146.next) {
                case 0:
                  _context146.next = 2;
                  return applyActionCode$1((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth), {
                    oobCode: oobCode
                  });

                case 2:
                case "end":
                  return _context146.stop();
              }
            }
          }, _callee146);
        }));
        return _applyActionCode.apply(this, arguments);
      }

      function checkActionCode(_x150, _x151) {
        return _checkActionCode.apply(this, arguments);
      }
      /**
       * Checks a password reset code sent to the user by email or other out-of-band mechanism.
       *
       * @returns the user's email address if valid.
       *
       * @param auth - The {@link Auth} instance.
       * @param code - A verification code sent to the user.
       *
       * @public
       */


      function _checkActionCode() {
        _checkActionCode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee147(auth, oobCode) {
          var authModular, response, operation, multiFactorInfo;
          return regeneratorRuntime.wrap(function _callee147$(_context147) {
            while (1) {
              switch (_context147.prev = _context147.next) {
                case 0:
                  authModular = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth);
                  _context147.next = 3;
                  return resetPassword(authModular, {
                    oobCode: oobCode
                  });

                case 3:
                  response = _context147.sent;
                  // Email could be empty only if the request type is EMAIL_SIGNIN or
                  // VERIFY_AND_CHANGE_EMAIL.
                  // New email should not be empty if the request type is
                  // VERIFY_AND_CHANGE_EMAIL.
                  // Multi-factor info could not be empty if the request type is
                  // REVERT_SECOND_FACTOR_ADDITION.
                  operation = response.requestType;

                  _assert(operation, authModular, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  _context147.t0 = operation;
                  _context147.next = _context147.t0 === "EMAIL_SIGNIN"
                  /* EMAIL_SIGNIN */
                  ? 9 : _context147.t0 === "VERIFY_AND_CHANGE_EMAIL"
                  /* VERIFY_AND_CHANGE_EMAIL */
                  ? 10 : _context147.t0 === "REVERT_SECOND_FACTOR_ADDITION"
                  /* REVERT_SECOND_FACTOR_ADDITION */
                  ? 12 : 13;
                  break;

                case 9:
                  return _context147.abrupt("break", 14);

                case 10:
                  _assert(response.newEmail, authModular, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  return _context147.abrupt("break", 14);

                case 12:
                  _assert(response.mfaInfo, authModular, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                case 13:
                  _assert(response.email, authModular, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                case 14:
                  // The multi-factor info for revert second factor addition
                  multiFactorInfo = null;

                  if (response.mfaInfo) {
                    multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);
                  }

                  return _context147.abrupt("return", {
                    data: {
                      email: (response.requestType === "VERIFY_AND_CHANGE_EMAIL"
                      /* VERIFY_AND_CHANGE_EMAIL */
                      ? response.newEmail : response.email) || null,
                      previousEmail: (response.requestType === "VERIFY_AND_CHANGE_EMAIL"
                      /* VERIFY_AND_CHANGE_EMAIL */
                      ? response.email : response.newEmail) || null,
                      multiFactorInfo: multiFactorInfo
                    },
                    operation: operation
                  });

                case 17:
                case "end":
                  return _context147.stop();
              }
            }
          }, _callee147);
        }));
        return _checkActionCode.apply(this, arguments);
      }

      function verifyPasswordResetCode(_x152, _x153) {
        return _verifyPasswordResetCode.apply(this, arguments);
      }
      /**
       * Creates a new user account associated with the specified email address and password.
       *
       * @remarks
       * On successful creation of the user account, this user will also be signed in to your application.
       *
       * User account creation can fail if the account already exists or the password is invalid.
       *
       * Note: The email address acts as a unique identifier for the user and enables an email-based
       * password reset. This function will create a new user account and set the initial user password.
       *
       * @param auth - The {@link Auth} instance.
       * @param email - The user's email address.
       * @param password - The user's chosen password.
       *
       * @public
       */


      function _verifyPasswordResetCode() {
        _verifyPasswordResetCode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee148(auth, code) {
          var _yield$checkActionCod, data;

          return regeneratorRuntime.wrap(function _callee148$(_context148) {
            while (1) {
              switch (_context148.prev = _context148.next) {
                case 0:
                  _context148.next = 2;
                  return checkActionCode((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth), code);

                case 2:
                  _yield$checkActionCod = _context148.sent;
                  data = _yield$checkActionCod.data;
                  return _context148.abrupt("return", data.email);

                case 5:
                case "end":
                  return _context148.stop();
              }
            }
          }, _callee148);
        }));
        return _verifyPasswordResetCode.apply(this, arguments);
      }

      function createUserWithEmailAndPassword(_x154, _x155, _x156) {
        return _createUserWithEmailAndPassword2.apply(this, arguments);
      }
      /**
       * Asynchronously signs in using an email and password.
       *
       * @remarks
       * Fails with an error if the email address and password do not match.
       *
       * Note: The user's password is NOT the password used to access the user's email account. The
       * email address serves as a unique identifier for the user, and the password is used to access
       * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.
       *
       * @param auth - The {@link Auth} instance.
       * @param email - The users email address.
       * @param password - The users password.
       *
       * @public
       */


      function _createUserWithEmailAndPassword2() {
        _createUserWithEmailAndPassword2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee149(auth, email, password) {
          var authInternal, response, userCredential;
          return regeneratorRuntime.wrap(function _callee149$(_context149) {
            while (1) {
              switch (_context149.prev = _context149.next) {
                case 0:
                  authInternal = _castAuth(auth);
                  _context149.next = 3;
                  return signUp(authInternal, {
                    returnSecureToken: true,
                    email: email,
                    password: password
                  });

                case 3:
                  response = _context149.sent;
                  _context149.next = 6;
                  return UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn"
                  /* SIGN_IN */
                  , response);

                case 6:
                  userCredential = _context149.sent;
                  _context149.next = 9;
                  return authInternal._updateCurrentUser(userCredential.user);

                case 9:
                  return _context149.abrupt("return", userCredential);

                case 10:
                case "end":
                  return _context149.stop();
              }
            }
          }, _callee149);
        }));
        return _createUserWithEmailAndPassword2.apply(this, arguments);
      }

      function signInWithEmailAndPassword(auth, email, password) {
        return signInWithCredential((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth), EmailAuthProvider.credential(email, password));
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Sends a sign-in email link to the user with the specified email.
       *
       * @remarks
       * The sign-in operation has to always be completed in the app unlike other out of band email
       * actions (password reset and email verifications). This is because, at the end of the flow,
       * the user is expected to be signed in and their Auth state persisted within the app.
       *
       * To complete sign in with the email link, call {@link signInWithEmailLink} with the email
       * address and the email link supplied in the email sent to the user.
       *
       * @example
       * ```javascript
       * const actionCodeSettings = {
       *   url: 'https://www.example.com/?email=user@example.com',
       *   iOS: {
       *      bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true
       * };
       * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);
       * // Obtain emailLink from the user.
       * if(isSignInWithEmailLink(auth, emailLink)) {
       *   await signInWithEmailLink('user@example.com', 'user@example.com', emailLink);
       * }
       * ```
       *
       * @param authInternal - The {@link Auth} instance.
       * @param email - The user's email address.
       * @param actionCodeSettings - The {@link ActionCodeSettings}.
       *
       * @public
       */


      function sendSignInLinkToEmail(_x157, _x158, _x159) {
        return _sendSignInLinkToEmail.apply(this, arguments);
      }
      /**
       * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.
       *
       * @param auth - The {@link Auth} instance.
       * @param emailLink - The link sent to the user's email address.
       *
       * @public
       */


      function _sendSignInLinkToEmail() {
        _sendSignInLinkToEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee150(auth, email, actionCodeSettings) {
          var authModular, request;
          return regeneratorRuntime.wrap(function _callee150$(_context150) {
            while (1) {
              switch (_context150.prev = _context150.next) {
                case 0:
                  authModular = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth);
                  request = {
                    requestType: "EMAIL_SIGNIN"
                    /* EMAIL_SIGNIN */
                    ,
                    email: email
                  };

                  _assert(actionCodeSettings.handleCodeInApp, authModular, "argument-error"
                  /* ARGUMENT_ERROR */
                  );

                  if (actionCodeSettings) {
                    _setActionCodeSettingsOnRequest(authModular, request, actionCodeSettings);
                  }

                  _context150.next = 6;
                  return sendSignInLinkToEmail$1(authModular, request);

                case 6:
                case "end":
                  return _context150.stop();
              }
            }
          }, _callee150);
        }));
        return _sendSignInLinkToEmail.apply(this, arguments);
      }

      function isSignInWithEmailLink(auth, emailLink) {
        var actionCodeUrl = ActionCodeURL.parseLink(emailLink);
        return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === "EMAIL_SIGNIN"
        /* EMAIL_SIGNIN */
        ;
      }
      /**
       * Asynchronously signs in using an email and sign-in email link.
       *
       * @remarks
       * If no link is passed, the link is inferred from the current URL.
       *
       * Fails with an error if the email address is invalid or OTP in email link expires.
       *
       * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.
       *
       * @example
       * ```javascript
       * const actionCodeSettings = {
       *   url: 'https://www.example.com/?email=user@example.com',
       *   iOS: {
       *      bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true
       * };
       * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);
       * // Obtain emailLink from the user.
       * if(isSignInWithEmailLink(auth, emailLink)) {
       *   await signInWithEmailLink('user@example.com', 'user@example.com', emailLink);
       * }
       * ```
       *
       * @param auth - The {@link Auth} instance.
       * @param email - The user's email address.
       * @param emailLink - The link sent to the user's email address.
       *
       * @public
       */


      function signInWithEmailLink(_x160, _x161, _x162) {
        return _signInWithEmailLink.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _signInWithEmailLink() {
        _signInWithEmailLink = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee151(auth, email, emailLink) {
          var authModular, credential;
          return regeneratorRuntime.wrap(function _callee151$(_context151) {
            while (1) {
              switch (_context151.prev = _context151.next) {
                case 0:
                  authModular = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth);
                  credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl()); // Check if the tenant ID in the email link matches the tenant ID on Auth
                  // instance.

                  _assert(credential._tenantId === (authModular.tenantId || null), authModular, "tenant-id-mismatch"
                  /* TENANT_ID_MISMATCH */
                  );

                  return _context151.abrupt("return", signInWithCredential(authModular, credential));

                case 4:
                case "end":
                  return _context151.stop();
              }
            }
          }, _callee151);
        }));
        return _signInWithEmailLink.apply(this, arguments);
      }

      function createAuthUri(_x163, _x164) {
        return _createAuthUri.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Gets the list of possible sign in methods for the given email address.
       *
       * @remarks
       * This is useful to differentiate methods of sign-in for the same provider, eg.
       * {@link EmailAuthProvider} which has 2 methods of sign-in,
       * {@link SignInMethod}.EMAIL_PASSWORD and
       * {@link SignInMethod}.EMAIL_LINK.
       *
       * @param auth - The {@link Auth} instance.
       * @param email - The user's email address.
       *
       * @public
       */


      function _createAuthUri() {
        _createAuthUri = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee152(auth, request) {
          return regeneratorRuntime.wrap(function _callee152$(_context152) {
            while (1) {
              switch (_context152.prev = _context152.next) {
                case 0:
                  return _context152.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:createAuthUri"
                  /* CREATE_AUTH_URI */
                  , _addTidIfNecessary(auth, request)));

                case 1:
                case "end":
                  return _context152.stop();
              }
            }
          }, _callee152);
        }));
        return _createAuthUri.apply(this, arguments);
      }

      function fetchSignInMethodsForEmail(_x165, _x166) {
        return _fetchSignInMethodsForEmail.apply(this, arguments);
      }
      /**
       * Sends a verification email to a user.
       *
       * @remarks
       * The verification process is completed by calling {@link applyActionCode}.
       *
       * @example
       * ```javascript
       * const actionCodeSettings = {
       *   url: 'https://www.example.com/?email=user@example.com',
       *   iOS: {
       *      bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true
       * };
       * await sendEmailVerification(user, actionCodeSettings);
       * // Obtain code from the user.
       * await applyActionCode(auth, code);
       * ```
       *
       * @param user - The user.
       * @param actionCodeSettings - The {@link ActionCodeSettings}.
       *
       * @public
       */


      function _fetchSignInMethodsForEmail() {
        _fetchSignInMethodsForEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee153(auth, email) {
          var continueUri, request, _yield$createAuthUri, signinMethods;

          return regeneratorRuntime.wrap(function _callee153$(_context153) {
            while (1) {
              switch (_context153.prev = _context153.next) {
                case 0:
                  // createAuthUri returns an error if continue URI is not http or https.
                  // For environments like Cordova, Chrome extensions, native frameworks, file
                  // systems, etc, use http://localhost as continue URL.
                  continueUri = _isHttpOrHttps() ? _getCurrentUrl() : 'http://localhost';
                  request = {
                    identifier: email,
                    continueUri: continueUri
                  };
                  _context153.next = 4;
                  return createAuthUri((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth), request);

                case 4:
                  _yield$createAuthUri = _context153.sent;
                  signinMethods = _yield$createAuthUri.signinMethods;
                  return _context153.abrupt("return", signinMethods || []);

                case 7:
                case "end":
                  return _context153.stop();
              }
            }
          }, _callee153);
        }));
        return _fetchSignInMethodsForEmail.apply(this, arguments);
      }

      function sendEmailVerification(_x167, _x168) {
        return _sendEmailVerification.apply(this, arguments);
      }
      /**
       * Sends a verification email to a new email address.
       *
       * @remarks
       * The user's email will be updated to the new one after being verified.
       *
       * If you have a custom email action handler, you can complete the verification process by calling
       * {@link applyActionCode}.
       *
       * @example
       * ```javascript
       * const actionCodeSettings = {
       *   url: 'https://www.example.com/?email=user@example.com',
       *   iOS: {
       *      bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true
       * };
       * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);
       * // Obtain code from the user.
       * await applyActionCode(auth, code);
       * ```
       *
       * @param user - The user.
       * @param newEmail - The new email address to be verified before update.
       * @param actionCodeSettings - The {@link ActionCodeSettings}.
       *
       * @public
       */


      function _sendEmailVerification() {
        _sendEmailVerification = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee154(user, actionCodeSettings) {
          var userInternal, idToken, request, _yield$sendEmailVerif, email;

          return regeneratorRuntime.wrap(function _callee154$(_context154) {
            while (1) {
              switch (_context154.prev = _context154.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);
                  _context154.next = 3;
                  return user.getIdToken();

                case 3:
                  idToken = _context154.sent;
                  request = {
                    requestType: "VERIFY_EMAIL"
                    /* VERIFY_EMAIL */
                    ,
                    idToken: idToken
                  };

                  if (actionCodeSettings) {
                    _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
                  }

                  _context154.next = 8;
                  return sendEmailVerification$1(userInternal.auth, request);

                case 8:
                  _yield$sendEmailVerif = _context154.sent;
                  email = _yield$sendEmailVerif.email;

                  if (!(email !== user.email)) {
                    _context154.next = 13;
                    break;
                  }

                  _context154.next = 13;
                  return user.reload();

                case 13:
                case "end":
                  return _context154.stop();
              }
            }
          }, _callee154);
        }));
        return _sendEmailVerification.apply(this, arguments);
      }

      function verifyBeforeUpdateEmail(_x169, _x170, _x171) {
        return _verifyBeforeUpdateEmail.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _verifyBeforeUpdateEmail() {
        _verifyBeforeUpdateEmail = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee155(user, newEmail, actionCodeSettings) {
          var userInternal, idToken, request, _yield$verifyAndChang, email;

          return regeneratorRuntime.wrap(function _callee155$(_context155) {
            while (1) {
              switch (_context155.prev = _context155.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);
                  _context155.next = 3;
                  return user.getIdToken();

                case 3:
                  idToken = _context155.sent;
                  request = {
                    requestType: "VERIFY_AND_CHANGE_EMAIL"
                    /* VERIFY_AND_CHANGE_EMAIL */
                    ,
                    idToken: idToken,
                    newEmail: newEmail
                  };

                  if (actionCodeSettings) {
                    _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
                  }

                  _context155.next = 8;
                  return verifyAndChangeEmail(userInternal.auth, request);

                case 8:
                  _yield$verifyAndChang = _context155.sent;
                  email = _yield$verifyAndChang.email;

                  if (!(email !== user.email)) {
                    _context155.next = 13;
                    break;
                  }

                  _context155.next = 13;
                  return user.reload();

                case 13:
                case "end":
                  return _context155.stop();
              }
            }
          }, _callee155);
        }));
        return _verifyBeforeUpdateEmail.apply(this, arguments);
      }

      function updateProfile$1(_x172, _x173) {
        return _updateProfile$.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Updates a user's profile data.
       *
       * @param user - The user.
       * @param profile - The profile's `displayName` and `photoURL` to update.
       *
       * @public
       */


      function _updateProfile$() {
        _updateProfile$ = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee156(auth, request) {
          return regeneratorRuntime.wrap(function _callee156$(_context156) {
            while (1) {
              switch (_context156.prev = _context156.next) {
                case 0:
                  return _context156.abrupt("return", _performApiRequest(auth, "POST"
                  /* POST */
                  , "/v1/accounts:update"
                  /* SET_ACCOUNT_INFO */
                  , request));

                case 1:
                case "end":
                  return _context156.stop();
              }
            }
          }, _callee156);
        }));
        return _updateProfile$.apply(this, arguments);
      }

      function updateProfile(_x174, _x175) {
        return _updateProfile.apply(this, arguments);
      }
      /**
       * Updates the user's email address.
       *
       * @remarks
       * An email will be sent to the original email address (if it was set) that allows to revoke the
       * email address change, in order to protect them from account hijacking.
       *
       * Important: this is a security sensitive operation that requires the user to have recently signed
       * in. If this requirement isn't met, ask the user to authenticate again and then call
       * {@link reauthenticateWithCredential}.
       *
       * @param user - The user.
       * @param newEmail - The new email address.
       *
       * @public
       */


      function _updateProfile() {
        _updateProfile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee157(user, _ref20) {
          var displayName, photoUrl, userInternal, idToken, profileRequest, response, passwordProvider;
          return regeneratorRuntime.wrap(function _callee157$(_context157) {
            while (1) {
              switch (_context157.prev = _context157.next) {
                case 0:
                  displayName = _ref20.displayName, photoUrl = _ref20.photoURL;

                  if (!(displayName === undefined && photoUrl === undefined)) {
                    _context157.next = 3;
                    break;
                  }

                  return _context157.abrupt("return");

                case 3:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);
                  _context157.next = 6;
                  return userInternal.getIdToken();

                case 6:
                  idToken = _context157.sent;
                  profileRequest = {
                    idToken: idToken,
                    displayName: displayName,
                    photoUrl: photoUrl,
                    returnSecureToken: true
                  };
                  _context157.next = 10;
                  return _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));

                case 10:
                  response = _context157.sent;
                  userInternal.displayName = response.displayName || null;
                  userInternal.photoURL = response.photoUrl || null; // Update the password provider as well

                  passwordProvider = userInternal.providerData.find(function (_ref38) {
                    var providerId = _ref38.providerId;
                    return providerId === "password";
                  }
                  /* PASSWORD */
                  );

                  if (passwordProvider) {
                    passwordProvider.displayName = userInternal.displayName;
                    passwordProvider.photoURL = userInternal.photoURL;
                  }

                  _context157.next = 17;
                  return userInternal._updateTokensIfNecessary(response);

                case 17:
                case "end":
                  return _context157.stop();
              }
            }
          }, _callee157);
        }));
        return _updateProfile.apply(this, arguments);
      }

      function updateEmail(user, newEmail) {
        return updateEmailOrPassword((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user), newEmail, null);
      }
      /**
       * Updates the user's password.
       *
       * @remarks
       * Important: this is a security sensitive operation that requires the user to have recently signed
       * in. If this requirement isn't met, ask the user to authenticate again and then call
       * {@link reauthenticateWithCredential}.
       *
       * @param user - The user.
       * @param newPassword - The new password.
       *
       * @public
       */


      function updatePassword(user, newPassword) {
        return updateEmailOrPassword((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user), null, newPassword);
      }

      function updateEmailOrPassword(_x176, _x177, _x178) {
        return _updateEmailOrPassword.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Parse the `AdditionalUserInfo` from the ID token response.
       *
       */


      function _updateEmailOrPassword() {
        _updateEmailOrPassword = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee158(user, email, password) {
          var auth, idToken, request, response;
          return regeneratorRuntime.wrap(function _callee158$(_context158) {
            while (1) {
              switch (_context158.prev = _context158.next) {
                case 0:
                  auth = user.auth;
                  _context158.next = 3;
                  return user.getIdToken();

                case 3:
                  idToken = _context158.sent;
                  request = {
                    idToken: idToken,
                    returnSecureToken: true
                  };

                  if (email) {
                    request.email = email;
                  }

                  if (password) {
                    request.password = password;
                  }

                  _context158.next = 9;
                  return _logoutIfInvalidated(user, updateEmailPassword(auth, request));

                case 9:
                  response = _context158.sent;
                  _context158.next = 12;
                  return user._updateTokensIfNecessary(response,
                  /* reload */
                  true);

                case 12:
                case "end":
                  return _context158.stop();
              }
            }
          }, _callee158);
        }));
        return _updateEmailOrPassword.apply(this, arguments);
      }

      function _fromIdTokenResponse(idTokenResponse) {
        var _a, _b;

        if (!idTokenResponse) {
          return null;
        }

        var providerId = idTokenResponse.providerId;
        var profile = idTokenResponse.rawUserInfo ? JSON.parse(idTokenResponse.rawUserInfo) : {};
        var isNewUser = idTokenResponse.isNewUser || idTokenResponse.kind === "identitytoolkit#SignupNewUserResponse"
        /* SignupNewUser */
        ;

        if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {
          var signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b['sign_in_provider'];

          if (signInProvider) {
            var filteredProviderId = signInProvider !== "anonymous"
            /* ANONYMOUS */
            && signInProvider !== "custom"
            /* CUSTOM */
            ? signInProvider : null; // Uses generic class in accordance with the legacy SDK.

            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);
          }
        }

        if (!providerId) {
          return null;
        }

        switch (providerId) {
          case "facebook.com"
          /* FACEBOOK */
          :
            return new FacebookAdditionalUserInfo(isNewUser, profile);

          case "github.com"
          /* GITHUB */
          :
            return new GithubAdditionalUserInfo(isNewUser, profile);

          case "google.com"
          /* GOOGLE */
          :
            return new GoogleAdditionalUserInfo(isNewUser, profile);

          case "twitter.com"
          /* TWITTER */
          :
            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);

          case "custom"
          /* CUSTOM */
          :
          case "anonymous"
          /* ANONYMOUS */
          :
            return new GenericAdditionalUserInfo(isNewUser, null);

          default:
            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);
        }
      }

      var GenericAdditionalUserInfo = function GenericAdditionalUserInfo(isNewUser, providerId) {
        var profile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, GenericAdditionalUserInfo);

        this.isNewUser = isNewUser;
        this.providerId = providerId;
        this.profile = profile;
      };

      var FederatedAdditionalUserInfoWithUsername = /*#__PURE__*/function (_GenericAdditionalUse) {
        _inherits(FederatedAdditionalUserInfoWithUsername, _GenericAdditionalUse);

        var _super14 = _createSuper(FederatedAdditionalUserInfoWithUsername);

        function FederatedAdditionalUserInfoWithUsername(isNewUser, providerId, profile, username) {
          var _this18;

          _classCallCheck(this, FederatedAdditionalUserInfoWithUsername);

          _this18 = _super14.call(this, isNewUser, providerId, profile);
          _this18.username = username;
          return _this18;
        }

        return FederatedAdditionalUserInfoWithUsername;
      }(GenericAdditionalUserInfo);

      var FacebookAdditionalUserInfo = /*#__PURE__*/function (_GenericAdditionalUse2) {
        _inherits(FacebookAdditionalUserInfo, _GenericAdditionalUse2);

        var _super15 = _createSuper(FacebookAdditionalUserInfo);

        function FacebookAdditionalUserInfo(isNewUser, profile) {
          _classCallCheck(this, FacebookAdditionalUserInfo);

          return _super15.call(this, isNewUser, "facebook.com"
          /* FACEBOOK */
          , profile);
        }

        return FacebookAdditionalUserInfo;
      }(GenericAdditionalUserInfo);

      var GithubAdditionalUserInfo = /*#__PURE__*/function (_FederatedAdditionalU) {
        _inherits(GithubAdditionalUserInfo, _FederatedAdditionalU);

        var _super16 = _createSuper(GithubAdditionalUserInfo);

        function GithubAdditionalUserInfo(isNewUser, profile) {
          _classCallCheck(this, GithubAdditionalUserInfo);

          return _super16.call(this, isNewUser, "github.com"
          /* GITHUB */
          , profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === 'string' ? profile === null || profile === void 0 ? void 0 : profile.login : null);
        }

        return GithubAdditionalUserInfo;
      }(FederatedAdditionalUserInfoWithUsername);

      var GoogleAdditionalUserInfo = /*#__PURE__*/function (_GenericAdditionalUse3) {
        _inherits(GoogleAdditionalUserInfo, _GenericAdditionalUse3);

        var _super17 = _createSuper(GoogleAdditionalUserInfo);

        function GoogleAdditionalUserInfo(isNewUser, profile) {
          _classCallCheck(this, GoogleAdditionalUserInfo);

          return _super17.call(this, isNewUser, "google.com"
          /* GOOGLE */
          , profile);
        }

        return GoogleAdditionalUserInfo;
      }(GenericAdditionalUserInfo);

      var TwitterAdditionalUserInfo = /*#__PURE__*/function (_FederatedAdditionalU2) {
        _inherits(TwitterAdditionalUserInfo, _FederatedAdditionalU2);

        var _super18 = _createSuper(TwitterAdditionalUserInfo);

        function TwitterAdditionalUserInfo(isNewUser, profile, screenName) {
          _classCallCheck(this, TwitterAdditionalUserInfo);

          return _super18.call(this, isNewUser, "twitter.com"
          /* TWITTER */
          , profile, screenName);
        }

        return TwitterAdditionalUserInfo;
      }(FederatedAdditionalUserInfoWithUsername);
      /**
       * Extracts provider specific {@link AdditionalUserInfo} for the given credential.
       *
       * @param userCredential - The user credential.
       *
       * @public
       */


      function getAdditionalUserInfo(userCredential) {
        var user = userCredential.user,
            _tokenResponse = userCredential._tokenResponse;

        if (user.isAnonymous && !_tokenResponse) {
          // Handle the special case where signInAnonymously() gets called twice.
          // No network call is made so there's nothing to actually fill this in
          return {
            providerId: null,
            isNewUser: false,
            profile: null
          };
        }

        return _fromIdTokenResponse(_tokenResponse);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      // Non-optional auth methods.

      /**
       * Changes the type of persistence on the {@link Auth} instance for the currently saved
       * `Auth` session and applies this type of persistence for future sign-in requests, including
       * sign-in with redirect requests.
       *
       * @remarks
       * This makes it easy for a user signing in to specify whether their session should be
       * remembered or not. It also makes it easier to never persist the `Auth` state for applications
       * that are shared by other users or have sensitive data.
       *
       * @example
       * ```javascript
       * setPersistence(auth, browserSessionPersistence);
       * ```
       *
       * @param auth - The {@link Auth} instance.
       * @param persistence - The {@link Persistence} to use.
       * @returns A `Promise` that resolves once the persistence change has completed
       *
       * @public
       */


      function setPersistence(auth, persistence) {
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth).setPersistence(persistence);
      }
      /**
       * Adds an observer for changes to the signed-in user's ID token, which includes sign-in,
       * sign-out, and token refresh events.
       *
       * @param auth - The {@link Auth} instance.
       * @param nextOrObserver - callback triggered on change.
       * @param error - callback triggered on error.
       * @param completed - callback triggered when observer is removed.
       *
       * @public
       */


      function onIdTokenChanged(auth, nextOrObserver, error, completed) {
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth).onIdTokenChanged(nextOrObserver, error, completed);
      }
      /**
       * Adds an observer for changes to the user's sign-in state.
       *
       * @remarks
       * To keep the old behavior, see {@link onIdTokenChanged}.
       *
       * @param auth - The {@link Auth} instance.
       * @param nextOrObserver - callback triggered on change.
       * @param error - callback triggered on error.
       * @param completed - callback triggered when observer is removed.
       *
       * @public
       */


      function onAuthStateChanged(auth, nextOrObserver, error, completed) {
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth).onAuthStateChanged(nextOrObserver, error, completed);
      }
      /**
       * Sets the current language to the default device/browser preference.
       *
       * @param auth - The {@link Auth} instance.
       *
       * @public
       */


      function useDeviceLanguage(auth) {
        (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth).useDeviceLanguage();
      }
      /**
       * Asynchronously sets the provided user as {@link Auth.currentUser} on the
       * {@link Auth} instance.
       *
       * @remarks
       * A new instance copy of the user provided will be made and set as currentUser.
       *
       * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners
       * like other sign in methods.
       *
       * The operation fails with an error if the user to be updated belongs to a different Firebase
       * project.
       *
       * @param auth - The {@link Auth} instance.
       * @param user - The new {@link User}.
       *
       * @public
       */


      function updateCurrentUser(auth, user) {
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth).updateCurrentUser(user);
      }
      /**
       * Signs out the current user.
       *
       * @param auth - The {@link Auth} instance.
       *
       * @public
       */


      function signOut(auth) {
        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth).signOut();
      }
      /**
       * Deletes and signs out the user.
       *
       * @remarks
       * Important: this is a security-sensitive operation that requires the user to have recently
       * signed in. If this requirement isn't met, ask the user to authenticate again and then call
       * {@link reauthenticateWithCredential}.
       *
       * @param user - The user.
       *
       * @public
       */


      function deleteUser(_x179) {
        return _deleteUser.apply(this, arguments);
      }

      function _deleteUser() {
        _deleteUser = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee159(user) {
          return regeneratorRuntime.wrap(function _callee159$(_context159) {
            while (1) {
              switch (_context159.prev = _context159.next) {
                case 0:
                  return _context159.abrupt("return", (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user)["delete"]());

                case 1:
                case "end":
                  return _context159.stop();
              }
            }
          }, _callee159);
        }));
        return _deleteUser.apply(this, arguments);
      }

      var MultiFactorSessionImpl = /*#__PURE__*/function () {
        function MultiFactorSessionImpl(type, credential) {
          _classCallCheck(this, MultiFactorSessionImpl);

          this.type = type;
          this.credential = credential;
        }

        _createClass(MultiFactorSessionImpl, [{
          key: "toJSON",
          value: function toJSON() {
            var key = this.type === "enroll"
            /* ENROLL */
            ? 'idToken' : 'pendingCredential';
            return {
              multiFactorSession: _defineProperty({}, key, this.credential)
            };
          }
        }], [{
          key: "_fromIdtoken",
          value: function _fromIdtoken(idToken) {
            return new MultiFactorSessionImpl("enroll"
            /* ENROLL */
            , idToken);
          }
        }, {
          key: "_fromMfaPendingCredential",
          value: function _fromMfaPendingCredential(mfaPendingCredential) {
            return new MultiFactorSessionImpl("signin"
            /* SIGN_IN */
            , mfaPendingCredential);
          }
        }, {
          key: "fromJSON",
          value: function fromJSON(obj) {
            var _a, _b;

            if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {
              if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {
                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);
              } else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {
                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);
              }
            }

            return null;
          }
        }]);

        return MultiFactorSessionImpl;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var MultiFactorResolverImpl = /*#__PURE__*/function () {
        function MultiFactorResolverImpl(session, hints, signInResolver) {
          _classCallCheck(this, MultiFactorResolverImpl);

          this.session = session;
          this.hints = hints;
          this.signInResolver = signInResolver;
        }
        /** @internal */


        _createClass(MultiFactorResolverImpl, [{
          key: "resolveSignIn",
          value: function () {
            var _resolveSignIn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee59(assertionExtern) {
              var assertion;
              return regeneratorRuntime.wrap(function _callee59$(_context59) {
                while (1) {
                  switch (_context59.prev = _context59.next) {
                    case 0:
                      assertion = assertionExtern;
                      return _context59.abrupt("return", this.signInResolver(assertion));

                    case 2:
                    case "end":
                      return _context59.stop();
                  }
                }
              }, _callee59, this);
            }));

            function resolveSignIn(_x180) {
              return _resolveSignIn.apply(this, arguments);
            }

            return resolveSignIn;
          }()
        }], [{
          key: "_fromError",
          value: function _fromError(authExtern, error) {
            var auth = _castAuth(authExtern);

            var serverResponse = error.customData._serverResponse;
            var hints = (serverResponse.mfaInfo || []).map(function (enrollment) {
              return MultiFactorInfoImpl._fromServerResponse(auth, enrollment);
            });

            _assert(serverResponse.mfaPendingCredential, auth, "internal-error"
            /* INTERNAL_ERROR */
            );

            var session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);

            return new MultiFactorResolverImpl(session, hints, /*#__PURE__*/function () {
              var _ref21 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee60(assertion) {
                var mfaResponse, idTokenResponse, userCredential;
                return regeneratorRuntime.wrap(function _callee60$(_context60) {
                  while (1) {
                    switch (_context60.prev = _context60.next) {
                      case 0:
                        _context60.next = 2;
                        return assertion._process(auth, session);

                      case 2:
                        mfaResponse = _context60.sent;
                        // Clear out the unneeded fields from the old login response
                        delete serverResponse.mfaInfo;
                        delete serverResponse.mfaPendingCredential; // Use in the new token & refresh token in the old response

                        idTokenResponse = Object.assign(Object.assign({}, serverResponse), {
                          idToken: mfaResponse.idToken,
                          refreshToken: mfaResponse.refreshToken
                        }); // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case

                        _context60.t0 = error.operationType;
                        _context60.next = _context60.t0 === "signIn"
                        /* SIGN_IN */
                        ? 9 : _context60.t0 === "reauthenticate"
                        /* REAUTHENTICATE */
                        ? 15 : 17;
                        break;

                      case 9:
                        _context60.next = 11;
                        return UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);

                      case 11:
                        userCredential = _context60.sent;
                        _context60.next = 14;
                        return auth._updateCurrentUser(userCredential.user);

                      case 14:
                        return _context60.abrupt("return", userCredential);

                      case 15:
                        _assert(error.user, auth, "internal-error"
                        /* INTERNAL_ERROR */
                        );

                        return _context60.abrupt("return", UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse));

                      case 17:
                        _fail(auth, "internal-error"
                        /* INTERNAL_ERROR */
                        );

                      case 18:
                      case "end":
                        return _context60.stop();
                    }
                  }
                }, _callee60);
              }));

              return function (_x181) {
                return _ref21.apply(this, arguments);
              };
            }());
          }
        }]);

        return MultiFactorResolverImpl;
      }();
      /**
       * Provides a {@link MultiFactorResolver} suitable for completion of a
       * multi-factor flow.
       *
       * @param auth - The {@link Auth} instance.
       * @param error - The {@link MultiFactorError} raised during a sign-in, or
       * reauthentication operation.
       *
       * @public
       */


      function getMultiFactorResolver(auth, error) {
        var _a;

        var authModular = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(auth);
        var errorInternal = error;

        _assert(error.customData.operationType, authModular, "argument-error"
        /* ARGUMENT_ERROR */
        );

        _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, "argument-error"
        /* ARGUMENT_ERROR */
        );

        return MultiFactorResolverImpl._fromError(authModular, errorInternal);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function startEnrollPhoneMfa(auth, request) {
        return _performApiRequest(auth, "POST"
        /* POST */
        , "/v2/accounts/mfaEnrollment:start"
        /* START_PHONE_MFA_ENROLLMENT */
        , _addTidIfNecessary(auth, request));
      }

      function finalizeEnrollPhoneMfa(auth, request) {
        return _performApiRequest(auth, "POST"
        /* POST */
        , "/v2/accounts/mfaEnrollment:finalize"
        /* FINALIZE_PHONE_MFA_ENROLLMENT */
        , _addTidIfNecessary(auth, request));
      }

      function withdrawMfa(auth, request) {
        return _performApiRequest(auth, "POST"
        /* POST */
        , "/v2/accounts/mfaEnrollment:withdraw"
        /* WITHDRAW_MFA */
        , _addTidIfNecessary(auth, request));
      }

      var MultiFactorUserImpl = /*#__PURE__*/function () {
        function MultiFactorUserImpl(user) {
          var _this19 = this;

          _classCallCheck(this, MultiFactorUserImpl);

          this.user = user;
          this.enrolledFactors = [];

          user._onReload(function (userInfo) {
            if (userInfo.mfaInfo) {
              _this19.enrolledFactors = userInfo.mfaInfo.map(function (enrollment) {
                return MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment);
              });
            }
          });
        }

        _createClass(MultiFactorUserImpl, [{
          key: "getSession",
          value: function () {
            var _getSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee61() {
              return regeneratorRuntime.wrap(function _callee61$(_context61) {
                while (1) {
                  switch (_context61.prev = _context61.next) {
                    case 0:
                      _context61.t0 = MultiFactorSessionImpl;
                      _context61.next = 3;
                      return this.user.getIdToken();

                    case 3:
                      _context61.t1 = _context61.sent;
                      return _context61.abrupt("return", _context61.t0._fromIdtoken.call(_context61.t0, _context61.t1));

                    case 5:
                    case "end":
                      return _context61.stop();
                  }
                }
              }, _callee61, this);
            }));

            function getSession() {
              return _getSession.apply(this, arguments);
            }

            return getSession;
          }()
        }, {
          key: "enroll",
          value: function () {
            var _enroll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee62(assertionExtern, displayName) {
              var assertion, session, finalizeMfaResponse;
              return regeneratorRuntime.wrap(function _callee62$(_context62) {
                while (1) {
                  switch (_context62.prev = _context62.next) {
                    case 0:
                      assertion = assertionExtern;
                      _context62.next = 3;
                      return this.getSession();

                    case 3:
                      session = _context62.sent;
                      _context62.next = 6;
                      return _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));

                    case 6:
                      finalizeMfaResponse = _context62.sent;
                      _context62.next = 9;
                      return this.user._updateTokensIfNecessary(finalizeMfaResponse);

                    case 9:
                      return _context62.abrupt("return", this.user.reload());

                    case 10:
                    case "end":
                      return _context62.stop();
                  }
                }
              }, _callee62, this);
            }));

            function enroll(_x182, _x183) {
              return _enroll.apply(this, arguments);
            }

            return enroll;
          }()
        }, {
          key: "unenroll",
          value: function () {
            var _unenroll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee63(infoOrUid) {
              var mfaEnrollmentId, idToken, idTokenResponse;
              return regeneratorRuntime.wrap(function _callee63$(_context63) {
                while (1) {
                  switch (_context63.prev = _context63.next) {
                    case 0:
                      mfaEnrollmentId = typeof infoOrUid === 'string' ? infoOrUid : infoOrUid.uid;
                      _context63.next = 3;
                      return this.user.getIdToken();

                    case 3:
                      idToken = _context63.sent;
                      _context63.next = 6;
                      return _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {
                        idToken: idToken,
                        mfaEnrollmentId: mfaEnrollmentId
                      }));

                    case 6:
                      idTokenResponse = _context63.sent;
                      // Remove the second factor from the user's list.
                      this.enrolledFactors = this.enrolledFactors.filter(function (_ref22) {
                        var uid = _ref22.uid;
                        return uid !== mfaEnrollmentId;
                      }); // Depending on whether the backend decided to revoke the user's session,
                      // the tokenResponse may be empty. If the tokens were not updated (and they
                      // are now invalid), reloading the user will discover this and invalidate
                      // the user's state accordingly.

                      _context63.next = 10;
                      return this.user._updateTokensIfNecessary(idTokenResponse);

                    case 10:
                      _context63.prev = 10;
                      _context63.next = 13;
                      return this.user.reload();

                    case 13:
                      _context63.next = 19;
                      break;

                    case 15:
                      _context63.prev = 15;
                      _context63.t0 = _context63["catch"](10);

                      if (!(_context63.t0.code !== "auth/".concat("user-token-expired"
                      /* TOKEN_EXPIRED */
                      ))) {
                        _context63.next = 19;
                        break;
                      }

                      throw _context63.t0;

                    case 19:
                    case "end":
                      return _context63.stop();
                  }
                }
              }, _callee63, this, [[10, 15]]);
            }));

            function unenroll(_x184) {
              return _unenroll.apply(this, arguments);
            }

            return unenroll;
          }()
        }], [{
          key: "_fromUser",
          value: function _fromUser(user) {
            return new MultiFactorUserImpl(user);
          }
        }]);

        return MultiFactorUserImpl;
      }();

      var multiFactorUserCache = new WeakMap();
      /**
       * The {@link MultiFactorUser} corresponding to the user.
       *
       * @remarks
       * This is used to access all multi-factor properties and operations related to the user.
       *
       * @param user - The user.
       *
       * @public
       */

      function multiFactor(user) {
        var userModular = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);

        if (!multiFactorUserCache.has(userModular)) {
          multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));
        }

        return multiFactorUserCache.get(userModular);
      }

      var STORAGE_AVAILABLE_KEY = '__sak';
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      // There are two different browser persistence types: local and session.
      // Both have the same implementation but use a different underlying storage
      // object.

      var BrowserPersistenceClass = /*#__PURE__*/function () {
        function BrowserPersistenceClass(storageRetriever, type) {
          _classCallCheck(this, BrowserPersistenceClass);

          this.storageRetriever = storageRetriever;
          this.type = type;
        }

        _createClass(BrowserPersistenceClass, [{
          key: "_isAvailable",
          value: function _isAvailable() {
            try {
              if (!this.storage) {
                return Promise.resolve(false);
              }

              this.storage.setItem(STORAGE_AVAILABLE_KEY, '1');
              this.storage.removeItem(STORAGE_AVAILABLE_KEY);
              return Promise.resolve(true);
            } catch (_a) {
              return Promise.resolve(false);
            }
          }
        }, {
          key: "_set",
          value: function _set(key, value) {
            this.storage.setItem(key, JSON.stringify(value));
            return Promise.resolve();
          }
        }, {
          key: "_get",
          value: function _get(key) {
            var json = this.storage.getItem(key);
            return Promise.resolve(json ? JSON.parse(json) : null);
          }
        }, {
          key: "_remove",
          value: function _remove(key) {
            this.storage.removeItem(key);
            return Promise.resolve();
          }
        }, {
          key: "storage",
          get: function get() {
            return this.storageRetriever();
          }
        }]);

        return BrowserPersistenceClass;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _iframeCannotSyncWebStorage() {
        var ua = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)();
        return _isSafari(ua) || _isIOS(ua);
      } // The polling period in case events are not supported


      var _POLLING_INTERVAL_MS$1 = 1000; // The IE 10 localStorage cross tab synchronization delay in milliseconds

      var IE10_LOCAL_STORAGE_SYNC_DELAY = 10;

      var BrowserLocalPersistence = /*#__PURE__*/function (_BrowserPersistenceCl) {
        _inherits(BrowserLocalPersistence, _BrowserPersistenceCl);

        var _super19 = _createSuper(BrowserLocalPersistence);

        function BrowserLocalPersistence() {
          var _this20;

          _classCallCheck(this, BrowserLocalPersistence);

          _this20 = _super19.call(this, function () {
            return window.localStorage;
          }, "LOCAL"
          /* LOCAL */
          );

          _this20.boundEventHandler = function (event, poll) {
            return _this20.onStorageEvent(event, poll);
          };

          _this20.listeners = {};
          _this20.localCache = {}; // setTimeout return value is platform specific
          // eslint-disable-next-line @typescript-eslint/no-explicit-any

          _this20.pollTimer = null; // Safari or iOS browser and embedded in an iframe.

          _this20.safariLocalStorageNotSynced = _iframeCannotSyncWebStorage() && _isIframe(); // Whether to use polling instead of depending on window events

          _this20.fallbackToPolling = _isMobileBrowser();
          _this20._shouldAllowMigration = true;
          return _this20;
        }

        _createClass(BrowserLocalPersistence, [{
          key: "forAllChangedKeys",
          value: function forAllChangedKeys(cb) {
            // Check all keys with listeners on them.
            for (var _i2 = 0, _Object$keys = Object.keys(this.listeners); _i2 < _Object$keys.length; _i2++) {
              var key = _Object$keys[_i2];
              // Get value from localStorage.
              var newValue = this.storage.getItem(key);
              var oldValue = this.localCache[key]; // If local map value does not match, trigger listener with storage event.
              // Differentiate this simulated event from the real storage event.

              if (newValue !== oldValue) {
                cb(key, oldValue, newValue);
              }
            }
          }
        }, {
          key: "onStorageEvent",
          value: function onStorageEvent(event) {
            var _this21 = this;

            var poll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            // Key would be null in some situations, like when localStorage is cleared
            if (!event.key) {
              this.forAllChangedKeys(function (key, _oldValue, newValue) {
                _this21.notifyListeners(key, newValue);
              });
              return;
            }

            var key = event.key; // Check the mechanism how this event was detected.
            // The first event will dictate the mechanism to be used.

            if (poll) {
              // Environment detects storage changes via polling.
              // Remove storage event listener to prevent possible event duplication.
              this.detachListener();
            } else {
              // Environment detects storage changes via storage event listener.
              // Remove polling listener to prevent possible event duplication.
              this.stopPolling();
            } // Safari embedded iframe. Storage event will trigger with the delta
            // changes but no changes will be applied to the iframe localStorage.


            if (this.safariLocalStorageNotSynced) {
              // Get current iframe page value.
              var _storedValue = this.storage.getItem(key); // Value not synchronized, synchronize manually.


              if (event.newValue !== _storedValue) {
                if (event.newValue !== null) {
                  // Value changed from current value.
                  this.storage.setItem(key, event.newValue);
                } else {
                  // Current value deleted.
                  this.storage.removeItem(key);
                }
              } else if (this.localCache[key] === event.newValue && !poll) {
                // Already detected and processed, do not trigger listeners again.
                return;
              }
            }

            var triggerListeners = function triggerListeners() {
              // Keep local map up to date in case storage event is triggered before
              // poll.
              var storedValue = _this21.storage.getItem(key);

              if (!poll && _this21.localCache[key] === storedValue) {
                // Real storage event which has already been detected, do nothing.
                // This seems to trigger in some IE browsers for some reason.
                return;
              }

              _this21.notifyListeners(key, storedValue);
            };

            var storedValue = this.storage.getItem(key);

            if (_isIE10() && storedValue !== event.newValue && event.newValue !== event.oldValue) {
              // IE 10 has this weird bug where a storage event would trigger with the
              // correct key, oldValue and newValue but localStorage.getItem(key) does
              // not yield the updated value until a few milliseconds. This ensures
              // this recovers from that situation.
              setTimeout(triggerListeners, IE10_LOCAL_STORAGE_SYNC_DELAY);
            } else {
              triggerListeners();
            }
          }
        }, {
          key: "notifyListeners",
          value: function notifyListeners(key, value) {
            this.localCache[key] = value;
            var listeners = this.listeners[key];

            if (listeners) {
              for (var _i3 = 0, _Array$from = Array.from(listeners); _i3 < _Array$from.length; _i3++) {
                var listener = _Array$from[_i3];
                listener(value ? JSON.parse(value) : value);
              }
            }
          }
        }, {
          key: "startPolling",
          value: function startPolling() {
            var _this22 = this;

            this.stopPolling();
            this.pollTimer = setInterval(function () {
              _this22.forAllChangedKeys(function (key, oldValue, newValue) {
                _this22.onStorageEvent(new StorageEvent('storage', {
                  key: key,
                  oldValue: oldValue,
                  newValue: newValue
                }),
                /* poll */
                true);
              });
            }, _POLLING_INTERVAL_MS$1);
          }
        }, {
          key: "stopPolling",
          value: function stopPolling() {
            if (this.pollTimer) {
              clearInterval(this.pollTimer);
              this.pollTimer = null;
            }
          }
        }, {
          key: "attachListener",
          value: function attachListener() {
            window.addEventListener('storage', this.boundEventHandler);
          }
        }, {
          key: "detachListener",
          value: function detachListener() {
            window.removeEventListener('storage', this.boundEventHandler);
          }
        }, {
          key: "_addListener",
          value: function _addListener(key, listener) {
            if (Object.keys(this.listeners).length === 0) {
              // Whether browser can detect storage event when it had already been pushed to the background.
              // This may happen in some mobile browsers. A localStorage change in the foreground window
              // will not be detected in the background window via the storage event.
              // This was detected in iOS 7.x mobile browsers
              if (this.fallbackToPolling) {
                this.startPolling();
              } else {
                this.attachListener();
              }
            }

            if (!this.listeners[key]) {
              this.listeners[key] = new Set(); // Populate the cache to avoid spuriously triggering on first poll.

              this.localCache[key] = this.storage.getItem(key);
            }

            this.listeners[key].add(listener);
          }
        }, {
          key: "_removeListener",
          value: function _removeListener(key, listener) {
            if (this.listeners[key]) {
              this.listeners[key]["delete"](listener);

              if (this.listeners[key].size === 0) {
                delete this.listeners[key];
              }
            }

            if (Object.keys(this.listeners).length === 0) {
              this.detachListener();
              this.stopPolling();
            }
          } // Update local cache on base operations:

        }, {
          key: "_set",
          value: function () {
            var _set3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee64(key, value) {
              return regeneratorRuntime.wrap(function _callee64$(_context64) {
                while (1) {
                  switch (_context64.prev = _context64.next) {
                    case 0:
                      _context64.next = 2;
                      return _get3(_getPrototypeOf(BrowserLocalPersistence.prototype), "_set", this).call(this, key, value);

                    case 2:
                      this.localCache[key] = JSON.stringify(value);

                    case 3:
                    case "end":
                      return _context64.stop();
                  }
                }
              }, _callee64, this);
            }));

            function _set(_x185, _x186) {
              return _set3.apply(this, arguments);
            }

            return _set;
          }()
        }, {
          key: "_get",
          value: function () {
            var _get4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee65(key) {
              var value;
              return regeneratorRuntime.wrap(function _callee65$(_context65) {
                while (1) {
                  switch (_context65.prev = _context65.next) {
                    case 0:
                      _context65.next = 2;
                      return _get3(_getPrototypeOf(BrowserLocalPersistence.prototype), "_get", this).call(this, key);

                    case 2:
                      value = _context65.sent;
                      this.localCache[key] = JSON.stringify(value);
                      return _context65.abrupt("return", value);

                    case 5:
                    case "end":
                      return _context65.stop();
                  }
                }
              }, _callee65, this);
            }));

            function _get(_x187) {
              return _get4.apply(this, arguments);
            }

            return _get;
          }()
        }, {
          key: "_remove",
          value: function () {
            var _remove3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee66(key) {
              return regeneratorRuntime.wrap(function _callee66$(_context66) {
                while (1) {
                  switch (_context66.prev = _context66.next) {
                    case 0:
                      _context66.next = 2;
                      return _get3(_getPrototypeOf(BrowserLocalPersistence.prototype), "_remove", this).call(this, key);

                    case 2:
                      delete this.localCache[key];

                    case 3:
                    case "end":
                      return _context66.stop();
                  }
                }
              }, _callee66, this);
            }));

            function _remove(_x188) {
              return _remove3.apply(this, arguments);
            }

            return _remove;
          }()
        }]);

        return BrowserLocalPersistence;
      }(BrowserPersistenceClass);

      BrowserLocalPersistence.type = 'LOCAL';
      /**
       * An implementation of {@link Persistence} of type `LOCAL` using `localStorage`
       * for the underlying storage.
       *
       * @public
       */

      var browserLocalPersistence = BrowserLocalPersistence;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      var BrowserSessionPersistence = /*#__PURE__*/function (_BrowserPersistenceCl2) {
        _inherits(BrowserSessionPersistence, _BrowserPersistenceCl2);

        var _super20 = _createSuper(BrowserSessionPersistence);

        function BrowserSessionPersistence() {
          _classCallCheck(this, BrowserSessionPersistence);

          return _super20.call(this, function () {
            return window.sessionStorage;
          }, "SESSION"
          /* SESSION */
          );
        }

        _createClass(BrowserSessionPersistence, [{
          key: "_addListener",
          value: function _addListener(_key, _listener) {
            // Listeners are not supported for session storage since it cannot be shared across windows
            return;
          }
        }, {
          key: "_removeListener",
          value: function _removeListener(_key, _listener) {
            // Listeners are not supported for session storage since it cannot be shared across windows
            return;
          }
        }]);

        return BrowserSessionPersistence;
      }(BrowserPersistenceClass);

      BrowserSessionPersistence.type = 'SESSION';
      /**
       * An implementation of {@link Persistence} of `SESSION` using `sessionStorage`
       * for the underlying storage.
       *
       * @public
       */

      var browserSessionPersistence = BrowserSessionPersistence;
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Shim for Promise.allSettled, note the slightly different format of `fulfilled` vs `status`.
       *
       * @param promises - Array of promises to wait on.
       */

      function _allSettled(promises) {
        return Promise.all(promises.map( /*#__PURE__*/function () {
          var _ref23 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee67(promise) {
            var value;
            return regeneratorRuntime.wrap(function _callee67$(_context67) {
              while (1) {
                switch (_context67.prev = _context67.next) {
                  case 0:
                    _context67.prev = 0;
                    _context67.next = 3;
                    return promise;

                  case 3:
                    value = _context67.sent;
                    return _context67.abrupt("return", {
                      fulfilled: true,
                      value: value
                    });

                  case 7:
                    _context67.prev = 7;
                    _context67.t0 = _context67["catch"](0);
                    return _context67.abrupt("return", {
                      fulfilled: false,
                      reason: _context67.t0
                    });

                  case 10:
                  case "end":
                    return _context67.stop();
                }
              }
            }, _callee67, null, [[0, 7]]);
          }));

          return function (_x189) {
            return _ref23.apply(this, arguments);
          };
        }()));
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Interface class for receiving messages.
       *
       */


      var Receiver = /*#__PURE__*/function () {
        function Receiver(eventTarget) {
          _classCallCheck(this, Receiver);

          this.eventTarget = eventTarget;
          this.handlersMap = {};
          this.boundEventHandler = this.handleEvent.bind(this);
        }
        /**
         * Obtain an instance of a Receiver for a given event target, if none exists it will be created.
         *
         * @param eventTarget - An event target (such as window or self) through which the underlying
         * messages will be received.
         */


        _createClass(Receiver, [{
          key: "isListeningto",
          value: function isListeningto(eventTarget) {
            return this.eventTarget === eventTarget;
          }
          /**
           * Fans out a MessageEvent to the appropriate listeners.
           *
           * @remarks
           * Sends an {@link Status.ACK} upon receipt and a {@link Status.DONE} once all handlers have
           * finished processing.
           *
           * @param event - The MessageEvent.
           *
           */

        }, {
          key: "handleEvent",
          value: function () {
            var _handleEvent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee69(event) {
              var messageEvent, _messageEvent$data, eventId, eventType, data, handlers, promises, response;

              return regeneratorRuntime.wrap(function _callee69$(_context69) {
                while (1) {
                  switch (_context69.prev = _context69.next) {
                    case 0:
                      messageEvent = event;
                      _messageEvent$data = messageEvent.data, eventId = _messageEvent$data.eventId, eventType = _messageEvent$data.eventType, data = _messageEvent$data.data;
                      handlers = this.handlersMap[eventType];

                      if (handlers === null || handlers === void 0 ? void 0 : handlers.size) {
                        _context69.next = 5;
                        break;
                      }

                      return _context69.abrupt("return");

                    case 5:
                      messageEvent.ports[0].postMessage({
                        status: "ack"
                        /* ACK */
                        ,
                        eventId: eventId,
                        eventType: eventType
                      });
                      promises = Array.from(handlers).map( /*#__PURE__*/function () {
                        var _ref24 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee68(handler) {
                          return regeneratorRuntime.wrap(function _callee68$(_context68) {
                            while (1) {
                              switch (_context68.prev = _context68.next) {
                                case 0:
                                  return _context68.abrupt("return", handler(messageEvent.origin, data));

                                case 1:
                                case "end":
                                  return _context68.stop();
                              }
                            }
                          }, _callee68);
                        }));

                        return function (_x191) {
                          return _ref24.apply(this, arguments);
                        };
                      }());
                      _context69.next = 9;
                      return _allSettled(promises);

                    case 9:
                      response = _context69.sent;
                      messageEvent.ports[0].postMessage({
                        status: "done"
                        /* DONE */
                        ,
                        eventId: eventId,
                        eventType: eventType,
                        response: response
                      });

                    case 11:
                    case "end":
                      return _context69.stop();
                  }
                }
              }, _callee69, this);
            }));

            function handleEvent(_x190) {
              return _handleEvent.apply(this, arguments);
            }

            return handleEvent;
          }()
          /**
           * Subscribe an event handler for a particular event.
           *
           * @param eventType - Event name to subscribe to.
           * @param eventHandler - The event handler which should receive the events.
           *
           */

        }, {
          key: "_subscribe",
          value: function _subscribe(eventType, eventHandler) {
            if (Object.keys(this.handlersMap).length === 0) {
              this.eventTarget.addEventListener('message', this.boundEventHandler);
            }

            if (!this.handlersMap[eventType]) {
              this.handlersMap[eventType] = new Set();
            }

            this.handlersMap[eventType].add(eventHandler);
          }
          /**
           * Unsubscribe an event handler from a particular event.
           *
           * @param eventType - Event name to unsubscribe from.
           * @param eventHandler - Optinoal event handler, if none provided, unsubscribe all handlers on this event.
           *
           */

        }, {
          key: "_unsubscribe",
          value: function _unsubscribe(eventType, eventHandler) {
            if (this.handlersMap[eventType] && eventHandler) {
              this.handlersMap[eventType]["delete"](eventHandler);
            }

            if (!eventHandler || this.handlersMap[eventType].size === 0) {
              delete this.handlersMap[eventType];
            }

            if (Object.keys(this.handlersMap).length === 0) {
              this.eventTarget.removeEventListener('message', this.boundEventHandler);
            }
          }
        }], [{
          key: "_getInstance",
          value: function _getInstance(eventTarget) {
            // The results are stored in an array since objects can't be keys for other
            // objects. In addition, setting a unique property on an event target as a
            // hash map key may not be allowed due to CORS restrictions.
            var existingInstance = this.receivers.find(function (receiver) {
              return receiver.isListeningto(eventTarget);
            });

            if (existingInstance) {
              return existingInstance;
            }

            var newInstance = new Receiver(eventTarget);
            this.receivers.push(newInstance);
            return newInstance;
          }
        }]);

        return Receiver;
      }();

      Receiver.receivers = [];
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      function _generateEventId() {
        var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
        var random = '';

        for (var i = 0; i < digits; i++) {
          random += Math.floor(Math.random() * 10);
        }

        return prefix + random;
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Interface for sending messages and waiting for a completion response.
       *
       */


      var Sender = /*#__PURE__*/function () {
        function Sender(target) {
          _classCallCheck(this, Sender);

          this.target = target;
          this.handlers = new Set();
        }
        /**
         * Unsubscribe the handler and remove it from our tracking Set.
         *
         * @param handler - The handler to unsubscribe.
         */


        _createClass(Sender, [{
          key: "removeMessageHandler",
          value: function removeMessageHandler(handler) {
            if (handler.messageChannel) {
              handler.messageChannel.port1.removeEventListener('message', handler.onMessage);
              handler.messageChannel.port1.close();
            }

            this.handlers["delete"](handler);
          }
          /**
           * Send a message to the Receiver located at {@link target}.
           *
           * @remarks
           * We'll first wait a bit for an ACK , if we get one we will wait significantly longer until the
           * receiver has had a chance to fully process the event.
           *
           * @param eventType - Type of event to send.
           * @param data - The payload of the event.
           * @param timeout - Timeout for waiting on an ACK from the receiver.
           *
           * @returns An array of settled promises from all the handlers that were listening on the receiver.
           */

        }, {
          key: "_send",
          value: function () {
            var _send2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee70(eventType, data) {
              var _this23 = this;

              var timeout,
                  messageChannel,
                  completionTimer,
                  handler,
                  _args70 = arguments;
              return regeneratorRuntime.wrap(function _callee70$(_context70) {
                while (1) {
                  switch (_context70.prev = _context70.next) {
                    case 0:
                      timeout = _args70.length > 2 && _args70[2] !== undefined ? _args70[2] : 50;
                      messageChannel = typeof MessageChannel !== 'undefined' ? new MessageChannel() : null;

                      if (messageChannel) {
                        _context70.next = 4;
                        break;
                      }

                      throw new Error("connection_unavailable"
                      /* CONNECTION_UNAVAILABLE */
                      );

                    case 4:
                      return _context70.abrupt("return", new Promise(function (resolve, reject) {
                        var eventId = _generateEventId('', 20);

                        messageChannel.port1.start();
                        var ackTimer = setTimeout(function () {
                          reject(new Error("unsupported_event"
                          /* UNSUPPORTED_EVENT */
                          ));
                        }, timeout);
                        handler = {
                          messageChannel: messageChannel,
                          onMessage: function onMessage(event) {
                            var messageEvent = event;

                            if (messageEvent.data.eventId !== eventId) {
                              return;
                            }

                            switch (messageEvent.data.status) {
                              case "ack"
                              /* ACK */
                              :
                                // The receiver should ACK first.
                                clearTimeout(ackTimer);
                                completionTimer = setTimeout(function () {
                                  reject(new Error("timeout"
                                  /* TIMEOUT */
                                  ));
                                }, 3000
                                /* COMPLETION */
                                );
                                break;

                              case "done"
                              /* DONE */
                              :
                                // Once the receiver's handlers are finished we will get the results.
                                clearTimeout(completionTimer);
                                resolve(messageEvent.data.response);
                                break;

                              default:
                                clearTimeout(ackTimer);
                                clearTimeout(completionTimer);
                                reject(new Error("invalid_response"
                                /* INVALID_RESPONSE */
                                ));
                                break;
                            }
                          }
                        };

                        _this23.handlers.add(handler);

                        messageChannel.port1.addEventListener('message', handler.onMessage);

                        _this23.target.postMessage({
                          eventType: eventType,
                          eventId: eventId,
                          data: data
                        }, [messageChannel.port2]);
                      })["finally"](function () {
                        if (handler) {
                          _this23.removeMessageHandler(handler);
                        }
                      }));

                    case 5:
                    case "end":
                      return _context70.stop();
                  }
                }
              }, _callee70);
            }));

            function _send(_x192, _x193) {
              return _send2.apply(this, arguments);
            }

            return _send;
          }()
        }]);

        return Sender;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Lazy accessor for window, since the compat layer won't tree shake this out,
       * we need to make sure not to mess with window unless we have to
       */


      function _window() {
        return window;
      }

      function _setWindowLocation(url) {
        _window().location.href = url;
      }
      /**
       * @license
       * Copyright 2020 Google LLC.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _isWorker() {
        return typeof _window()['WorkerGlobalScope'] !== 'undefined' && typeof _window()['importScripts'] === 'function';
      }

      function _getActiveServiceWorker() {
        return _getActiveServiceWorker2.apply(this, arguments);
      }

      function _getActiveServiceWorker2() {
        _getActiveServiceWorker2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee160() {
          var registration;
          return regeneratorRuntime.wrap(function _callee160$(_context160) {
            while (1) {
              switch (_context160.prev = _context160.next) {
                case 0:
                  if (navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker) {
                    _context160.next = 2;
                    break;
                  }

                  return _context160.abrupt("return", null);

                case 2:
                  _context160.prev = 2;
                  _context160.next = 5;
                  return navigator.serviceWorker.ready;

                case 5:
                  registration = _context160.sent;
                  return _context160.abrupt("return", registration.active);

                case 9:
                  _context160.prev = 9;
                  _context160.t0 = _context160["catch"](2);
                  return _context160.abrupt("return", null);

                case 12:
                case "end":
                  return _context160.stop();
              }
            }
          }, _callee160, null, [[2, 9]]);
        }));
        return _getActiveServiceWorker2.apply(this, arguments);
      }

      function _getServiceWorkerController() {
        var _a;

        return ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker) === null || _a === void 0 ? void 0 : _a.controller) || null;
      }

      function _getWorkerGlobalScope() {
        return _isWorker() ? self : null;
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var DB_NAME = 'firebaseLocalStorageDb';
      var DB_VERSION = 1;
      var DB_OBJECTSTORE_NAME = 'firebaseLocalStorage';
      var DB_DATA_KEYPATH = 'fbase_key';
      /**
       * Promise wrapper for IDBRequest
       *
       * Unfortunately we can't cleanly extend Promise<T> since promises are not callable in ES6
       *
       */

      var DBPromise = /*#__PURE__*/function () {
        function DBPromise(request) {
          _classCallCheck(this, DBPromise);

          this.request = request;
        }

        _createClass(DBPromise, [{
          key: "toPromise",
          value: function toPromise() {
            var _this24 = this;

            return new Promise(function (resolve, reject) {
              _this24.request.addEventListener('success', function () {
                resolve(_this24.request.result);
              });

              _this24.request.addEventListener('error', function () {
                reject(_this24.request.error);
              });
            });
          }
        }]);

        return DBPromise;
      }();

      function getObjectStore(db, isReadWrite) {
        return db.transaction([DB_OBJECTSTORE_NAME], isReadWrite ? 'readwrite' : 'readonly').objectStore(DB_OBJECTSTORE_NAME);
      }

      function _deleteDatabase() {
        var request = indexedDB.deleteDatabase(DB_NAME);
        return new DBPromise(request).toPromise();
      }

      function _openDatabase() {
        var request = indexedDB.open(DB_NAME, DB_VERSION);
        return new Promise(function (resolve, reject) {
          request.addEventListener('error', function () {
            reject(request.error);
          });
          request.addEventListener('upgradeneeded', function () {
            var db = request.result;

            try {
              db.createObjectStore(DB_OBJECTSTORE_NAME, {
                keyPath: DB_DATA_KEYPATH
              });
            } catch (e) {
              reject(e);
            }
          });
          request.addEventListener('success', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee71() {
            var db;
            return regeneratorRuntime.wrap(function _callee71$(_context71) {
              while (1) {
                switch (_context71.prev = _context71.next) {
                  case 0:
                    db = request.result; // Strange bug that occurs in Firefox when multiple tabs are opened at the
                    // same time. The only way to recover seems to be deleting the database
                    // and re-initializing it.
                    // https://github.com/firebase/firebase-js-sdk/issues/634

                    if (db.objectStoreNames.contains(DB_OBJECTSTORE_NAME)) {
                      _context71.next = 12;
                      break;
                    }

                    // Need to close the database or else you get a `blocked` event
                    db.close();
                    _context71.next = 5;
                    return _deleteDatabase();

                  case 5:
                    _context71.t0 = resolve;
                    _context71.next = 8;
                    return _openDatabase();

                  case 8:
                    _context71.t1 = _context71.sent;
                    (0, _context71.t0)(_context71.t1);
                    _context71.next = 13;
                    break;

                  case 12:
                    resolve(db);

                  case 13:
                  case "end":
                    return _context71.stop();
                }
              }
            }, _callee71);
          })));
        });
      }

      function _putObject(_x194, _x195, _x196) {
        return _putObject2.apply(this, arguments);
      }

      function _putObject2() {
        _putObject2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee161(db, key, value) {
          var _getObjectStore$put;

          var request;
          return regeneratorRuntime.wrap(function _callee161$(_context161) {
            while (1) {
              switch (_context161.prev = _context161.next) {
                case 0:
                  request = getObjectStore(db, true).put((_getObjectStore$put = {}, _defineProperty(_getObjectStore$put, DB_DATA_KEYPATH, key), _defineProperty(_getObjectStore$put, "value", value), _getObjectStore$put));
                  return _context161.abrupt("return", new DBPromise(request).toPromise());

                case 2:
                case "end":
                  return _context161.stop();
              }
            }
          }, _callee161);
        }));
        return _putObject2.apply(this, arguments);
      }

      function getObject(_x197, _x198) {
        return _getObject.apply(this, arguments);
      }

      function _getObject() {
        _getObject = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee162(db, key) {
          var request, data;
          return regeneratorRuntime.wrap(function _callee162$(_context162) {
            while (1) {
              switch (_context162.prev = _context162.next) {
                case 0:
                  request = getObjectStore(db, false).get(key);
                  _context162.next = 3;
                  return new DBPromise(request).toPromise();

                case 3:
                  data = _context162.sent;
                  return _context162.abrupt("return", data === undefined ? null : data.value);

                case 5:
                case "end":
                  return _context162.stop();
              }
            }
          }, _callee162);
        }));
        return _getObject.apply(this, arguments);
      }

      function _deleteObject(db, key) {
        var request = getObjectStore(db, true)["delete"](key);
        return new DBPromise(request).toPromise();
      }

      var _POLLING_INTERVAL_MS = 800;
      var _TRANSACTION_RETRY_COUNT = 3;

      var IndexedDBLocalPersistence = /*#__PURE__*/function () {
        function IndexedDBLocalPersistence() {
          _classCallCheck(this, IndexedDBLocalPersistence);

          this.type = "LOCAL"
          /* LOCAL */
          ;
          this._shouldAllowMigration = true;
          this.listeners = {};
          this.localCache = {}; // setTimeout return value is platform specific
          // eslint-disable-next-line @typescript-eslint/no-explicit-any

          this.pollTimer = null;
          this.pendingWrites = 0;
          this.receiver = null;
          this.sender = null;
          this.serviceWorkerReceiverAvailable = false;
          this.activeServiceWorker = null; // Fire & forget the service worker registration as it may never resolve

          this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(function () {}, function () {});
        }

        _createClass(IndexedDBLocalPersistence, [{
          key: "_openDb",
          value: function () {
            var _openDb2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee72() {
              return regeneratorRuntime.wrap(function _callee72$(_context72) {
                while (1) {
                  switch (_context72.prev = _context72.next) {
                    case 0:
                      if (!this.db) {
                        _context72.next = 2;
                        break;
                      }

                      return _context72.abrupt("return", this.db);

                    case 2:
                      _context72.next = 4;
                      return _openDatabase();

                    case 4:
                      this.db = _context72.sent;
                      return _context72.abrupt("return", this.db);

                    case 6:
                    case "end":
                      return _context72.stop();
                  }
                }
              }, _callee72, this);
            }));

            function _openDb() {
              return _openDb2.apply(this, arguments);
            }

            return _openDb;
          }()
        }, {
          key: "_withRetries",
          value: function () {
            var _withRetries2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee73(op) {
              var numAttempts, db;
              return regeneratorRuntime.wrap(function _callee73$(_context73) {
                while (1) {
                  switch (_context73.prev = _context73.next) {
                    case 0:
                      numAttempts = 0;

                    case 1:
                      if (!true) {
                        _context73.next = 18;
                        break;
                      }

                      _context73.prev = 2;
                      _context73.next = 5;
                      return this._openDb();

                    case 5:
                      db = _context73.sent;
                      _context73.next = 8;
                      return op(db);

                    case 8:
                      return _context73.abrupt("return", _context73.sent);

                    case 11:
                      _context73.prev = 11;
                      _context73.t0 = _context73["catch"](2);

                      if (!(numAttempts++ > _TRANSACTION_RETRY_COUNT)) {
                        _context73.next = 15;
                        break;
                      }

                      throw _context73.t0;

                    case 15:
                      if (this.db) {
                        this.db.close();
                        this.db = undefined;
                      } // TODO: consider adding exponential backoff


                    case 16:
                      _context73.next = 1;
                      break;

                    case 18:
                    case "end":
                      return _context73.stop();
                  }
                }
              }, _callee73, this, [[2, 11]]);
            }));

            function _withRetries(_x199) {
              return _withRetries2.apply(this, arguments);
            }

            return _withRetries;
          }()
          /**
           * IndexedDB events do not propagate from the main window to the worker context.  We rely on a
           * postMessage interface to send these events to the worker ourselves.
           */

        }, {
          key: "initializeServiceWorkerMessaging",
          value: function () {
            var _initializeServiceWorkerMessaging = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee74() {
              return regeneratorRuntime.wrap(function _callee74$(_context74) {
                while (1) {
                  switch (_context74.prev = _context74.next) {
                    case 0:
                      return _context74.abrupt("return", _isWorker() ? this.initializeReceiver() : this.initializeSender());

                    case 1:
                    case "end":
                      return _context74.stop();
                  }
                }
              }, _callee74, this);
            }));

            function initializeServiceWorkerMessaging() {
              return _initializeServiceWorkerMessaging.apply(this, arguments);
            }

            return initializeServiceWorkerMessaging;
          }()
          /**
           * As the worker we should listen to events from the main window.
           */

        }, {
          key: "initializeReceiver",
          value: function () {
            var _initializeReceiver = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee77() {
              var _this25 = this;

              return regeneratorRuntime.wrap(function _callee77$(_context77) {
                while (1) {
                  switch (_context77.prev = _context77.next) {
                    case 0:
                      this.receiver = Receiver._getInstance(_getWorkerGlobalScope()); // Refresh from persistence if we receive a KeyChanged message.

                      this.receiver._subscribe("keyChanged"
                      /* KEY_CHANGED */
                      , /*#__PURE__*/function () {
                        var _ref26 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee75(_origin, data) {
                          var keys;
                          return regeneratorRuntime.wrap(function _callee75$(_context75) {
                            while (1) {
                              switch (_context75.prev = _context75.next) {
                                case 0:
                                  _context75.next = 2;
                                  return _this25._poll();

                                case 2:
                                  keys = _context75.sent;
                                  return _context75.abrupt("return", {
                                    keyProcessed: keys.includes(data.key)
                                  });

                                case 4:
                                case "end":
                                  return _context75.stop();
                              }
                            }
                          }, _callee75);
                        }));

                        return function (_x200, _x201) {
                          return _ref26.apply(this, arguments);
                        };
                      }()); // Let the sender know that we are listening so they give us more timeout.


                      this.receiver._subscribe("ping"
                      /* PING */
                      , /*#__PURE__*/function () {
                        var _ref27 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee76(_origin, _data) {
                          return regeneratorRuntime.wrap(function _callee76$(_context76) {
                            while (1) {
                              switch (_context76.prev = _context76.next) {
                                case 0:
                                  return _context76.abrupt("return", ["keyChanged"
                                  /* KEY_CHANGED */
                                  ]);

                                case 1:
                                case "end":
                                  return _context76.stop();
                              }
                            }
                          }, _callee76);
                        }));

                        return function (_x202, _x203) {
                          return _ref27.apply(this, arguments);
                        };
                      }());

                    case 3:
                    case "end":
                      return _context77.stop();
                  }
                }
              }, _callee77, this);
            }));

            function initializeReceiver() {
              return _initializeReceiver.apply(this, arguments);
            }

            return initializeReceiver;
          }()
          /**
           * As the main window, we should let the worker know when keys change (set and remove).
           *
           * @remarks
           * {@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/ready | ServiceWorkerContainer.ready}
           * may not resolve.
           */

        }, {
          key: "initializeSender",
          value: function () {
            var _initializeSender = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee78() {
              var _a, _b, results;

              return regeneratorRuntime.wrap(function _callee78$(_context78) {
                while (1) {
                  switch (_context78.prev = _context78.next) {
                    case 0:
                      _context78.next = 2;
                      return _getActiveServiceWorker();

                    case 2:
                      this.activeServiceWorker = _context78.sent;

                      if (this.activeServiceWorker) {
                        _context78.next = 5;
                        break;
                      }

                      return _context78.abrupt("return");

                    case 5:
                      this.sender = new Sender(this.activeServiceWorker); // Ping the service worker to check what events they can handle.

                      _context78.next = 8;
                      return this.sender._send("ping"
                      /* PING */
                      , {}, 800
                      /* LONG_ACK */
                      );

                    case 8:
                      results = _context78.sent;

                      if (results) {
                        _context78.next = 11;
                        break;
                      }

                      return _context78.abrupt("return");

                    case 11:
                      if (((_a = results[0]) === null || _a === void 0 ? void 0 : _a.fulfilled) && ((_b = results[0]) === null || _b === void 0 ? void 0 : _b.value.includes("keyChanged"
                      /* KEY_CHANGED */
                      ))) {
                        this.serviceWorkerReceiverAvailable = true;
                      }

                    case 12:
                    case "end":
                      return _context78.stop();
                  }
                }
              }, _callee78, this);
            }));

            function initializeSender() {
              return _initializeSender.apply(this, arguments);
            }

            return initializeSender;
          }()
          /**
           * Let the worker know about a changed key, the exact key doesn't technically matter since the
           * worker will just trigger a full sync anyway.
           *
           * @remarks
           * For now, we only support one service worker per page.
           *
           * @param key - Storage key which changed.
           */

        }, {
          key: "notifyServiceWorker",
          value: function () {
            var _notifyServiceWorker = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee79(key) {
              return regeneratorRuntime.wrap(function _callee79$(_context79) {
                while (1) {
                  switch (_context79.prev = _context79.next) {
                    case 0:
                      if (!(!this.sender || !this.activeServiceWorker || _getServiceWorkerController() !== this.activeServiceWorker)) {
                        _context79.next = 2;
                        break;
                      }

                      return _context79.abrupt("return");

                    case 2:
                      _context79.prev = 2;
                      _context79.next = 5;
                      return this.sender._send("keyChanged"
                      /* KEY_CHANGED */
                      , {
                        key: key
                      }, // Use long timeout if receiver has previously responded to a ping from us.
                      this.serviceWorkerReceiverAvailable ? 800
                      /* LONG_ACK */
                      : 50
                      /* ACK */
                      );

                    case 5:
                      _context79.next = 9;
                      break;

                    case 7:
                      _context79.prev = 7;
                      _context79.t0 = _context79["catch"](2);

                    case 9:
                    case "end":
                      return _context79.stop();
                  }
                }
              }, _callee79, this, [[2, 7]]);
            }));

            function notifyServiceWorker(_x204) {
              return _notifyServiceWorker.apply(this, arguments);
            }

            return notifyServiceWorker;
          }()
        }, {
          key: "_isAvailable",
          value: function () {
            var _isAvailable3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee80() {
              var db;
              return regeneratorRuntime.wrap(function _callee80$(_context80) {
                while (1) {
                  switch (_context80.prev = _context80.next) {
                    case 0:
                      _context80.prev = 0;

                      if (indexedDB) {
                        _context80.next = 3;
                        break;
                      }

                      return _context80.abrupt("return", false);

                    case 3:
                      _context80.next = 5;
                      return _openDatabase();

                    case 5:
                      db = _context80.sent;
                      _context80.next = 8;
                      return _putObject(db, STORAGE_AVAILABLE_KEY, '1');

                    case 8:
                      _context80.next = 10;
                      return _deleteObject(db, STORAGE_AVAILABLE_KEY);

                    case 10:
                      return _context80.abrupt("return", true);

                    case 13:
                      _context80.prev = 13;
                      _context80.t0 = _context80["catch"](0);

                    case 15:
                      return _context80.abrupt("return", false);

                    case 16:
                    case "end":
                      return _context80.stop();
                  }
                }
              }, _callee80, null, [[0, 13]]);
            }));

            function _isAvailable() {
              return _isAvailable3.apply(this, arguments);
            }

            return _isAvailable;
          }()
        }, {
          key: "_withPendingWrite",
          value: function () {
            var _withPendingWrite2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee81(write) {
              return regeneratorRuntime.wrap(function _callee81$(_context81) {
                while (1) {
                  switch (_context81.prev = _context81.next) {
                    case 0:
                      this.pendingWrites++;
                      _context81.prev = 1;
                      _context81.next = 4;
                      return write();

                    case 4:
                      _context81.prev = 4;
                      this.pendingWrites--;
                      return _context81.finish(4);

                    case 7:
                    case "end":
                      return _context81.stop();
                  }
                }
              }, _callee81, this, [[1,, 4, 7]]);
            }));

            function _withPendingWrite(_x205) {
              return _withPendingWrite2.apply(this, arguments);
            }

            return _withPendingWrite;
          }()
        }, {
          key: "_set",
          value: function () {
            var _set4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee83(key, value) {
              var _this26 = this;

              return regeneratorRuntime.wrap(function _callee83$(_context83) {
                while (1) {
                  switch (_context83.prev = _context83.next) {
                    case 0:
                      return _context83.abrupt("return", this._withPendingWrite( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee82() {
                        return regeneratorRuntime.wrap(function _callee82$(_context82) {
                          while (1) {
                            switch (_context82.prev = _context82.next) {
                              case 0:
                                _context82.next = 2;
                                return _this26._withRetries(function (db) {
                                  return _putObject(db, key, value);
                                });

                              case 2:
                                _this26.localCache[key] = value;
                                return _context82.abrupt("return", _this26.notifyServiceWorker(key));

                              case 4:
                              case "end":
                                return _context82.stop();
                            }
                          }
                        }, _callee82);
                      }))));

                    case 1:
                    case "end":
                      return _context83.stop();
                  }
                }
              }, _callee83, this);
            }));

            function _set(_x206, _x207) {
              return _set4.apply(this, arguments);
            }

            return _set;
          }()
        }, {
          key: "_get",
          value: function () {
            var _get5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee84(key) {
              var obj;
              return regeneratorRuntime.wrap(function _callee84$(_context84) {
                while (1) {
                  switch (_context84.prev = _context84.next) {
                    case 0:
                      _context84.next = 2;
                      return this._withRetries(function (db) {
                        return getObject(db, key);
                      });

                    case 2:
                      obj = _context84.sent;
                      this.localCache[key] = obj;
                      return _context84.abrupt("return", obj);

                    case 5:
                    case "end":
                      return _context84.stop();
                  }
                }
              }, _callee84, this);
            }));

            function _get(_x208) {
              return _get5.apply(this, arguments);
            }

            return _get;
          }()
        }, {
          key: "_remove",
          value: function () {
            var _remove4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee86(key) {
              var _this27 = this;

              return regeneratorRuntime.wrap(function _callee86$(_context86) {
                while (1) {
                  switch (_context86.prev = _context86.next) {
                    case 0:
                      return _context86.abrupt("return", this._withPendingWrite( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee85() {
                        return regeneratorRuntime.wrap(function _callee85$(_context85) {
                          while (1) {
                            switch (_context85.prev = _context85.next) {
                              case 0:
                                _context85.next = 2;
                                return _this27._withRetries(function (db) {
                                  return _deleteObject(db, key);
                                });

                              case 2:
                                delete _this27.localCache[key];
                                return _context85.abrupt("return", _this27.notifyServiceWorker(key));

                              case 4:
                              case "end":
                                return _context85.stop();
                            }
                          }
                        }, _callee85);
                      }))));

                    case 1:
                    case "end":
                      return _context86.stop();
                  }
                }
              }, _callee86, this);
            }));

            function _remove(_x209) {
              return _remove4.apply(this, arguments);
            }

            return _remove;
          }()
        }, {
          key: "_poll",
          value: function () {
            var _poll2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee87() {
              var result, keys, keysInResult, _iterator2, _step2, _step2$value, key, value, _i4, _Object$keys2, localKey;

              return regeneratorRuntime.wrap(function _callee87$(_context87) {
                while (1) {
                  switch (_context87.prev = _context87.next) {
                    case 0:
                      _context87.next = 2;
                      return this._withRetries(function (db) {
                        var getAllRequest = getObjectStore(db, false).getAll();
                        return new DBPromise(getAllRequest).toPromise();
                      });

                    case 2:
                      result = _context87.sent;

                      if (result) {
                        _context87.next = 5;
                        break;
                      }

                      return _context87.abrupt("return", []);

                    case 5:
                      if (!(this.pendingWrites !== 0)) {
                        _context87.next = 7;
                        break;
                      }

                      return _context87.abrupt("return", []);

                    case 7:
                      keys = [];
                      keysInResult = new Set();
                      _iterator2 = _createForOfIteratorHelper(result);

                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                          _step2$value = _step2.value, key = _step2$value.fbase_key, value = _step2$value.value;
                          keysInResult.add(key);

                          if (JSON.stringify(this.localCache[key]) !== JSON.stringify(value)) {
                            this.notifyListeners(key, value);
                            keys.push(key);
                          }
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }

                      for (_i4 = 0, _Object$keys2 = Object.keys(this.localCache); _i4 < _Object$keys2.length; _i4++) {
                        localKey = _Object$keys2[_i4];

                        if (this.localCache[localKey] && !keysInResult.has(localKey)) {
                          // Deleted
                          this.notifyListeners(localKey, null);
                          keys.push(localKey);
                        }
                      }

                      return _context87.abrupt("return", keys);

                    case 13:
                    case "end":
                      return _context87.stop();
                  }
                }
              }, _callee87, this);
            }));

            function _poll() {
              return _poll2.apply(this, arguments);
            }

            return _poll;
          }()
        }, {
          key: "notifyListeners",
          value: function notifyListeners(key, newValue) {
            this.localCache[key] = newValue;
            var listeners = this.listeners[key];

            if (listeners) {
              for (var _i5 = 0, _Array$from2 = Array.from(listeners); _i5 < _Array$from2.length; _i5++) {
                var listener = _Array$from2[_i5];
                listener(newValue);
              }
            }
          }
        }, {
          key: "startPolling",
          value: function startPolling() {
            var _this28 = this;

            this.stopPolling();
            this.pollTimer = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee88() {
              return regeneratorRuntime.wrap(function _callee88$(_context88) {
                while (1) {
                  switch (_context88.prev = _context88.next) {
                    case 0:
                      return _context88.abrupt("return", _this28._poll());

                    case 1:
                    case "end":
                      return _context88.stop();
                  }
                }
              }, _callee88);
            })), _POLLING_INTERVAL_MS);
          }
        }, {
          key: "stopPolling",
          value: function stopPolling() {
            if (this.pollTimer) {
              clearInterval(this.pollTimer);
              this.pollTimer = null;
            }
          }
        }, {
          key: "_addListener",
          value: function _addListener(key, listener) {
            if (Object.keys(this.listeners).length === 0) {
              this.startPolling();
            }

            if (!this.listeners[key]) {
              this.listeners[key] = new Set(); // Populate the cache to avoid spuriously triggering on first poll.

              void this._get(key); // This can happen in the background async and we can return immediately.
            }

            this.listeners[key].add(listener);
          }
        }, {
          key: "_removeListener",
          value: function _removeListener(key, listener) {
            if (this.listeners[key]) {
              this.listeners[key]["delete"](listener);

              if (this.listeners[key].size === 0) {
                delete this.listeners[key];
              }
            }

            if (Object.keys(this.listeners).length === 0) {
              this.stopPolling();
            }
          }
        }]);

        return IndexedDBLocalPersistence;
      }();

      IndexedDBLocalPersistence.type = 'LOCAL';
      /**
       * An implementation of {@link Persistence} of type `LOCAL` using `indexedDB`
       * for the underlying storage.
       *
       * @public
       */

      var indexedDBLocalPersistence = IndexedDBLocalPersistence;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      function startSignInPhoneMfa(auth, request) {
        return _performApiRequest(auth, "POST"
        /* POST */
        , "/v2/accounts/mfaSignIn:start"
        /* START_PHONE_MFA_SIGN_IN */
        , _addTidIfNecessary(auth, request));
      }

      function finalizeSignInPhoneMfa(auth, request) {
        return _performApiRequest(auth, "POST"
        /* POST */
        , "/v2/accounts/mfaSignIn:finalize"
        /* FINALIZE_PHONE_MFA_SIGN_IN */
        , _addTidIfNecessary(auth, request));
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function getRecaptchaParams(_x210) {
        return _getRecaptchaParams.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _getRecaptchaParams() {
        _getRecaptchaParams = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee163(auth) {
          return regeneratorRuntime.wrap(function _callee163$(_context163) {
            while (1) {
              switch (_context163.prev = _context163.next) {
                case 0:
                  _context163.next = 2;
                  return _performApiRequest(auth, "GET"
                  /* GET */
                  , "/v1/recaptchaParams"
                  /* GET_RECAPTCHA_PARAM */
                  );

                case 2:
                  _context163.t0 = _context163.sent.recaptchaSiteKey;

                  if (_context163.t0) {
                    _context163.next = 5;
                    break;
                  }

                  _context163.t0 = '';

                case 5:
                  return _context163.abrupt("return", _context163.t0);

                case 6:
                case "end":
                  return _context163.stop();
              }
            }
          }, _callee163);
        }));
        return _getRecaptchaParams.apply(this, arguments);
      }

      function getScriptParentElement() {
        var _a, _b;

        return (_b = (_a = document.getElementsByTagName('head')) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : document;
      }

      function _loadJS(url) {
        // TODO: consider adding timeout support & cancellation
        return new Promise(function (resolve, reject) {
          var el = document.createElement('script');
          el.setAttribute('src', url);
          el.onload = resolve;

          el.onerror = function (e) {
            var error = _createError("internal-error"
            /* INTERNAL_ERROR */
            );

            error.customData = e;
            reject(error);
          };

          el.type = 'text/javascript';
          el.charset = 'UTF-8';
          getScriptParentElement().appendChild(el);
        });
      }

      function _generateCallbackName(prefix) {
        return "__".concat(prefix).concat(Math.floor(Math.random() * 1000000));
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var _SOLVE_TIME_MS = 500;
      var _EXPIRATION_TIME_MS = 60000;
      var _WIDGET_ID_START = 1000000000000;

      var MockReCaptcha = /*#__PURE__*/function () {
        function MockReCaptcha(auth) {
          _classCallCheck(this, MockReCaptcha);

          this.auth = auth;
          this.counter = _WIDGET_ID_START;
          this._widgets = new Map();
        }

        _createClass(MockReCaptcha, [{
          key: "render",
          value: function render(container, parameters) {
            var id = this.counter;

            this._widgets.set(id, new MockWidget(container, this.auth.name, parameters || {}));

            this.counter++;
            return id;
          }
        }, {
          key: "reset",
          value: function reset(optWidgetId) {
            var _a;

            var id = optWidgetId || _WIDGET_ID_START;
            void ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a["delete"]());

            this._widgets["delete"](id);
          }
        }, {
          key: "getResponse",
          value: function getResponse(optWidgetId) {
            var _a;

            var id = optWidgetId || _WIDGET_ID_START;
            return ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.getResponse()) || '';
          }
        }, {
          key: "execute",
          value: function () {
            var _execute = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee89(optWidgetId) {
              var _a, id;

              return regeneratorRuntime.wrap(function _callee89$(_context89) {
                while (1) {
                  switch (_context89.prev = _context89.next) {
                    case 0:
                      id = optWidgetId || _WIDGET_ID_START;
                      void ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.execute());
                      return _context89.abrupt("return", '');

                    case 3:
                    case "end":
                      return _context89.stop();
                  }
                }
              }, _callee89, this);
            }));

            function execute(_x211) {
              return _execute.apply(this, arguments);
            }

            return execute;
          }()
        }]);

        return MockReCaptcha;
      }();

      var MockWidget = /*#__PURE__*/function () {
        function MockWidget(containerOrId, appName, params) {
          var _this29 = this;

          _classCallCheck(this, MockWidget);

          this.params = params;
          this.timerId = null;
          this.deleted = false;
          this.responseToken = null;

          this.clickHandler = function () {
            _this29.execute();
          };

          var container = typeof containerOrId === 'string' ? document.getElementById(containerOrId) : containerOrId;

          _assert(container, "argument-error"
          /* ARGUMENT_ERROR */
          , {
            appName: appName
          });

          this.container = container;
          this.isVisible = this.params.size !== 'invisible';

          if (this.isVisible) {
            this.execute();
          } else {
            this.container.addEventListener('click', this.clickHandler);
          }
        }

        _createClass(MockWidget, [{
          key: "getResponse",
          value: function getResponse() {
            this.checkIfDeleted();
            return this.responseToken;
          }
        }, {
          key: "delete",
          value: function _delete() {
            this.checkIfDeleted();
            this.deleted = true;

            if (this.timerId) {
              clearTimeout(this.timerId);
              this.timerId = null;
            }

            this.container.removeEventListener('click', this.clickHandler);
          }
        }, {
          key: "execute",
          value: function execute() {
            var _this30 = this;

            this.checkIfDeleted();

            if (this.timerId) {
              return;
            }

            this.timerId = window.setTimeout(function () {
              _this30.responseToken = generateRandomAlphaNumericString(50);
              var _this30$params = _this30.params,
                  callback = _this30$params.callback,
                  expiredCallback = _this30$params['expired-callback'];

              if (callback) {
                try {
                  callback(_this30.responseToken);
                } catch (e) {}
              }

              _this30.timerId = window.setTimeout(function () {
                _this30.timerId = null;
                _this30.responseToken = null;

                if (expiredCallback) {
                  try {
                    expiredCallback();
                  } catch (e) {}
                }

                if (_this30.isVisible) {
                  _this30.execute();
                }
              }, _EXPIRATION_TIME_MS);
            }, _SOLVE_TIME_MS);
          }
        }, {
          key: "checkIfDeleted",
          value: function checkIfDeleted() {
            if (this.deleted) {
              throw new Error('reCAPTCHA mock was already deleted!');
            }
          }
        }]);

        return MockWidget;
      }();

      function generateRandomAlphaNumericString(len) {
        var chars = [];
        var allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

        for (var i = 0; i < len; i++) {
          chars.push(allowedChars.charAt(Math.floor(Math.random() * allowedChars.length)));
        }

        return chars.join('');
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      // ReCaptcha will load using the same callback, so the callback function needs
      // to be kept around


      var _JSLOAD_CALLBACK = _generateCallbackName('rcb');

      var NETWORK_TIMEOUT_DELAY = new Delay(30000, 60000);
      var RECAPTCHA_BASE = 'https://www.google.com/recaptcha/api.js?';
      /**
       * Loader for the GReCaptcha library. There should only ever be one of this.
       */

      var ReCaptchaLoaderImpl = /*#__PURE__*/function () {
        function ReCaptchaLoaderImpl() {
          _classCallCheck(this, ReCaptchaLoaderImpl);

          this.hostLanguage = '';
          this.counter = 0;
          this.librarySeparatelyLoaded = !!_window().grecaptcha;
        }

        _createClass(ReCaptchaLoaderImpl, [{
          key: "load",
          value: function load(auth) {
            var _this31 = this;

            var hl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

            _assert(isHostLanguageValid(hl), auth, "argument-error"
            /* ARGUMENT_ERROR */
            );

            if (this.shouldResolveImmediately(hl)) {
              return Promise.resolve(_window().grecaptcha);
            }

            return new Promise(function (resolve, reject) {
              var networkTimeout = _window().setTimeout(function () {
                reject(_createError(auth, "network-request-failed"
                /* NETWORK_REQUEST_FAILED */
                ));
              }, NETWORK_TIMEOUT_DELAY.get());

              _window()[_JSLOAD_CALLBACK] = function () {
                _window().clearTimeout(networkTimeout);

                delete _window()[_JSLOAD_CALLBACK];

                var recaptcha = _window().grecaptcha;

                if (!recaptcha) {
                  reject(_createError(auth, "internal-error"
                  /* INTERNAL_ERROR */
                  ));
                  return;
                } // Wrap the greptcha render function so that we know if the developer has
                // called it separately


                var render = recaptcha.render;

                recaptcha.render = function (container, params) {
                  var widgetId = render(container, params);
                  _this31.counter++;
                  return widgetId;
                };

                _this31.hostLanguage = hl;
                resolve(recaptcha);
              };

              var url = "".concat(RECAPTCHA_BASE, "?").concat((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystring)({
                onload: _JSLOAD_CALLBACK,
                render: 'explicit',
                hl: hl
              }));

              _loadJS(url)["catch"](function () {
                clearTimeout(networkTimeout);
                reject(_createError(auth, "internal-error"
                /* INTERNAL_ERROR */
                ));
              });
            });
          }
        }, {
          key: "clearedOneInstance",
          value: function clearedOneInstance() {
            this.counter--;
          }
        }, {
          key: "shouldResolveImmediately",
          value: function shouldResolveImmediately(hl) {
            // We can resolve immediately if:
            //   • grecaptcha is already defined AND (
            //     1. the requested language codes are the same OR
            //     2. there exists already a ReCaptcha on the page
            //     3. the library was already loaded by the app
            // In cases (2) and (3), we _can't_ reload as it would break the recaptchas
            // that are already in the page
            return !!_window().grecaptcha && (hl === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded);
          }
        }]);

        return ReCaptchaLoaderImpl;
      }();

      function isHostLanguageValid(hl) {
        return hl.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(hl);
      }

      var MockReCaptchaLoaderImpl = /*#__PURE__*/function () {
        function MockReCaptchaLoaderImpl() {
          _classCallCheck(this, MockReCaptchaLoaderImpl);
        }

        _createClass(MockReCaptchaLoaderImpl, [{
          key: "load",
          value: function () {
            var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee90(auth) {
              return regeneratorRuntime.wrap(function _callee90$(_context90) {
                while (1) {
                  switch (_context90.prev = _context90.next) {
                    case 0:
                      return _context90.abrupt("return", new MockReCaptcha(auth));

                    case 1:
                    case "end":
                      return _context90.stop();
                  }
                }
              }, _callee90);
            }));

            function load(_x212) {
              return _load.apply(this, arguments);
            }

            return load;
          }()
        }, {
          key: "clearedOneInstance",
          value: function clearedOneInstance() {}
        }]);

        return MockReCaptchaLoaderImpl;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var RECAPTCHA_VERIFIER_TYPE = 'recaptcha';
      var DEFAULT_PARAMS = {
        theme: 'light',
        type: 'image'
      };
      /**
       * An {@link https://www.google.com/recaptcha/ | reCAPTCHA}-based application verifier.
       *
       * @public
       */

      var RecaptchaVerifier = /*#__PURE__*/function () {
        /**
         *
         * @param containerOrId - The reCAPTCHA container parameter.
         *
         * @remarks
         * This has different meaning depending on whether the reCAPTCHA is hidden or visible. For a
         * visible reCAPTCHA the container must be empty. If a string is used, it has to correspond to
         * an element ID. The corresponding element must also must be in the DOM at the time of
         * initialization.
         *
         * @param parameters - The optional reCAPTCHA parameters.
         *
         * @remarks
         * Check the reCAPTCHA docs for a comprehensive list. All parameters are accepted except for
         * the sitekey. Firebase Auth backend provisions a reCAPTCHA for each project and will
         * configure this upon rendering. For an invisible reCAPTCHA, a size key must have the value
         * 'invisible'.
         *
         * @param authExtern - The corresponding Firebase {@link Auth} instance.
         *
         * @remarks
         * If none is provided, the default Firebase {@link Auth} instance is used. A Firebase {@link Auth} instance
         * must be initialized with an API key, otherwise an error will be thrown.
         */
        function RecaptchaVerifier(containerOrId) {
          var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.assign({}, DEFAULT_PARAMS);
          var authExtern = arguments.length > 2 ? arguments[2] : undefined;

          _classCallCheck(this, RecaptchaVerifier);

          this.parameters = parameters;
          /**
           * The application verifier type.
           *
           * @remarks
           * For a reCAPTCHA verifier, this is 'recaptcha'.
           */

          this.type = RECAPTCHA_VERIFIER_TYPE;
          this.destroyed = false;
          this.widgetId = null;
          this.tokenChangeListeners = new Set();
          this.renderPromise = null;
          this.recaptcha = null;
          this.auth = _castAuth(authExtern);
          this.isInvisible = this.parameters.size === 'invisible';

          _assert(typeof document !== 'undefined', this.auth, "operation-not-supported-in-this-environment"
          /* OPERATION_NOT_SUPPORTED */
          );

          var container = typeof containerOrId === 'string' ? document.getElementById(containerOrId) : containerOrId;

          _assert(container, this.auth, "argument-error"
          /* ARGUMENT_ERROR */
          );

          this.container = container;
          this.parameters.callback = this.makeTokenCallback(this.parameters.callback);
          this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new MockReCaptchaLoaderImpl() : new ReCaptchaLoaderImpl();
          this.validateStartingState(); // TODO: Figure out if sdk version is needed
        }
        /**
         * Waits for the user to solve the reCAPTCHA and resolves with the reCAPTCHA token.
         *
         * @returns A Promise for the reCAPTCHA token.
         */


        _createClass(RecaptchaVerifier, [{
          key: "verify",
          value: function () {
            var _verify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee91() {
              var _this32 = this;

              var id, recaptcha, response;
              return regeneratorRuntime.wrap(function _callee91$(_context91) {
                while (1) {
                  switch (_context91.prev = _context91.next) {
                    case 0:
                      this.assertNotDestroyed();
                      _context91.next = 3;
                      return this.render();

                    case 3:
                      id = _context91.sent;
                      recaptcha = this.getAssertedRecaptcha();
                      response = recaptcha.getResponse(id);

                      if (!response) {
                        _context91.next = 8;
                        break;
                      }

                      return _context91.abrupt("return", response);

                    case 8:
                      return _context91.abrupt("return", new Promise(function (resolve) {
                        var tokenChange = function tokenChange(token) {
                          if (!token) {
                            return; // Ignore token expirations.
                          }

                          _this32.tokenChangeListeners["delete"](tokenChange);

                          resolve(token);
                        };

                        _this32.tokenChangeListeners.add(tokenChange);

                        if (_this32.isInvisible) {
                          recaptcha.execute(id);
                        }
                      }));

                    case 9:
                    case "end":
                      return _context91.stop();
                  }
                }
              }, _callee91, this);
            }));

            function verify() {
              return _verify.apply(this, arguments);
            }

            return verify;
          }()
          /**
           * Renders the reCAPTCHA widget on the page.
           *
           * @returns A Promise that resolves with the reCAPTCHA widget ID.
           */

        }, {
          key: "render",
          value: function render() {
            var _this33 = this;

            try {
              this.assertNotDestroyed();
            } catch (e) {
              // This method returns a promise. Since it's not async (we want to return the
              // _same_ promise if rendering is still occurring), the API surface should
              // reject with the error rather than just throw
              return Promise.reject(e);
            }

            if (this.renderPromise) {
              return this.renderPromise;
            }

            this.renderPromise = this.makeRenderPromise()["catch"](function (e) {
              _this33.renderPromise = null;
              throw e;
            });
            return this.renderPromise;
          }
          /** @internal */

        }, {
          key: "_reset",
          value: function _reset() {
            this.assertNotDestroyed();

            if (this.widgetId !== null) {
              this.getAssertedRecaptcha().reset(this.widgetId);
            }
          }
          /**
           * Clears the reCAPTCHA widget from the page and destroys the instance.
           */

        }, {
          key: "clear",
          value: function clear() {
            var _this34 = this;

            this.assertNotDestroyed();
            this.destroyed = true;

            this._recaptchaLoader.clearedOneInstance();

            if (!this.isInvisible) {
              this.container.childNodes.forEach(function (node) {
                _this34.container.removeChild(node);
              });
            }
          }
        }, {
          key: "validateStartingState",
          value: function validateStartingState() {
            _assert(!this.parameters.sitekey, this.auth, "argument-error"
            /* ARGUMENT_ERROR */
            );

            _assert(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error"
            /* ARGUMENT_ERROR */
            );

            _assert(typeof document !== 'undefined', this.auth, "operation-not-supported-in-this-environment"
            /* OPERATION_NOT_SUPPORTED */
            );
          }
        }, {
          key: "makeTokenCallback",
          value: function makeTokenCallback(existing) {
            var _this35 = this;

            return function (token) {
              _this35.tokenChangeListeners.forEach(function (listener) {
                return listener(token);
              });

              if (typeof existing === 'function') {
                existing(token);
              } else if (typeof existing === 'string') {
                var globalFunc = _window()[existing];

                if (typeof globalFunc === 'function') {
                  globalFunc(token);
                }
              }
            };
          }
        }, {
          key: "assertNotDestroyed",
          value: function assertNotDestroyed() {
            _assert(!this.destroyed, this.auth, "internal-error"
            /* INTERNAL_ERROR */
            );
          }
        }, {
          key: "makeRenderPromise",
          value: function () {
            var _makeRenderPromise = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee92() {
              var container, guaranteedEmpty;
              return regeneratorRuntime.wrap(function _callee92$(_context92) {
                while (1) {
                  switch (_context92.prev = _context92.next) {
                    case 0:
                      _context92.next = 2;
                      return this.init();

                    case 2:
                      if (!this.widgetId) {
                        container = this.container;

                        if (!this.isInvisible) {
                          guaranteedEmpty = document.createElement('div');
                          container.appendChild(guaranteedEmpty);
                          container = guaranteedEmpty;
                        }

                        this.widgetId = this.getAssertedRecaptcha().render(container, this.parameters);
                      }

                      return _context92.abrupt("return", this.widgetId);

                    case 4:
                    case "end":
                      return _context92.stop();
                  }
                }
              }, _callee92, this);
            }));

            function makeRenderPromise() {
              return _makeRenderPromise.apply(this, arguments);
            }

            return makeRenderPromise;
          }()
        }, {
          key: "init",
          value: function () {
            var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee93() {
              var siteKey;
              return regeneratorRuntime.wrap(function _callee93$(_context93) {
                while (1) {
                  switch (_context93.prev = _context93.next) {
                    case 0:
                      _assert(_isHttpOrHttps() && !_isWorker(), this.auth, "internal-error"
                      /* INTERNAL_ERROR */
                      );

                      _context93.next = 3;
                      return domReady();

                    case 3:
                      _context93.next = 5;
                      return this._recaptchaLoader.load(this.auth, this.auth.languageCode || undefined);

                    case 5:
                      this.recaptcha = _context93.sent;
                      _context93.next = 8;
                      return getRecaptchaParams(this.auth);

                    case 8:
                      siteKey = _context93.sent;

                      _assert(siteKey, this.auth, "internal-error"
                      /* INTERNAL_ERROR */
                      );

                      this.parameters.sitekey = siteKey;

                    case 11:
                    case "end":
                      return _context93.stop();
                  }
                }
              }, _callee93, this);
            }));

            function init() {
              return _init.apply(this, arguments);
            }

            return init;
          }()
        }, {
          key: "getAssertedRecaptcha",
          value: function getAssertedRecaptcha() {
            _assert(this.recaptcha, this.auth, "internal-error"
            /* INTERNAL_ERROR */
            );

            return this.recaptcha;
          }
        }]);

        return RecaptchaVerifier;
      }();

      function domReady() {
        var resolver = null;
        return new Promise(function (resolve) {
          if (document.readyState === 'complete') {
            resolve();
            return;
          } // Document not ready, wait for load before resolving.
          // Save resolver, so we can remove listener in case it was externally
          // cancelled.


          resolver = function resolver() {
            return resolve();
          };

          window.addEventListener('load', resolver);
        })["catch"](function (e) {
          if (resolver) {
            window.removeEventListener('load', resolver);
          }

          throw e;
        });
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var ConfirmationResultImpl = /*#__PURE__*/function () {
        function ConfirmationResultImpl(verificationId, onConfirmation) {
          _classCallCheck(this, ConfirmationResultImpl);

          this.verificationId = verificationId;
          this.onConfirmation = onConfirmation;
        }

        _createClass(ConfirmationResultImpl, [{
          key: "confirm",
          value: function confirm(verificationCode) {
            var authCredential = PhoneAuthCredential._fromVerification(this.verificationId, verificationCode);

            return this.onConfirmation(authCredential);
          }
        }]);

        return ConfirmationResultImpl;
      }();
      /**
       * Asynchronously signs in using a phone number.
       *
       * @remarks
       * This method sends a code via SMS to the given
       * phone number, and returns a {@link ConfirmationResult}. After the user
       * provides the code sent to their phone, call {@link ConfirmationResult.confirm}
       * with the code to sign the user in.
       *
       * For abuse prevention, this method also requires a {@link ApplicationVerifier}.
       * This SDK includes a reCAPTCHA-based implementation, {@link RecaptchaVerifier}.
       * This function can work on other platforms that do not support the
       * {@link RecaptchaVerifier} (like React Native), but you need to use a
       * third-party {@link ApplicationVerifier} implementation.
       *
       * @example
       * ```javascript
       * // 'recaptcha-container' is the ID of an element in the DOM.
       * const applicationVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container');
       * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
       * // Obtain a verificationCode from the user.
       * const credential = await confirmationResult.confirm(verificationCode);
       * ```
       *
       * @param auth - The {@link Auth} instance.
       * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
       * @param appVerifier - The {@link ApplicationVerifier}.
       *
       * @public
       */


      function signInWithPhoneNumber(_x213, _x214, _x215) {
        return _signInWithPhoneNumber.apply(this, arguments);
      }
      /**
       * Links the user account with the given phone number.
       *
       * @param user - The user.
       * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
       * @param appVerifier - The {@link ApplicationVerifier}.
       *
       * @public
       */


      function _signInWithPhoneNumber() {
        _signInWithPhoneNumber = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee164(auth, phoneNumber, appVerifier) {
          var authInternal, verificationId;
          return regeneratorRuntime.wrap(function _callee164$(_context164) {
            while (1) {
              switch (_context164.prev = _context164.next) {
                case 0:
                  authInternal = _castAuth(auth);
                  _context164.next = 3;
                  return _verifyPhoneNumber(authInternal, phoneNumber, (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(appVerifier));

                case 3:
                  verificationId = _context164.sent;
                  return _context164.abrupt("return", new ConfirmationResultImpl(verificationId, function (cred) {
                    return signInWithCredential(authInternal, cred);
                  }));

                case 5:
                case "end":
                  return _context164.stop();
              }
            }
          }, _callee164);
        }));
        return _signInWithPhoneNumber.apply(this, arguments);
      }

      function linkWithPhoneNumber(_x216, _x217, _x218) {
        return _linkWithPhoneNumber2.apply(this, arguments);
      }
      /**
       * Re-authenticates a user using a fresh phone credential.
       *
       * @remarks Use before operations such as {@link updatePassword} that require tokens from recent sign-in attempts.
       *
       * @param user - The user.
       * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
       * @param appVerifier - The {@link ApplicationVerifier}.
       *
       * @public
       */


      function _linkWithPhoneNumber2() {
        _linkWithPhoneNumber2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee165(user, phoneNumber, appVerifier) {
          var userInternal, verificationId;
          return regeneratorRuntime.wrap(function _callee165$(_context165) {
            while (1) {
              switch (_context165.prev = _context165.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);
                  _context165.next = 3;
                  return _assertLinkedStatus(false, userInternal, "phone"
                  /* PHONE */
                  );

                case 3:
                  _context165.next = 5;
                  return _verifyPhoneNumber(userInternal.auth, phoneNumber, (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(appVerifier));

                case 5:
                  verificationId = _context165.sent;
                  return _context165.abrupt("return", new ConfirmationResultImpl(verificationId, function (cred) {
                    return linkWithCredential(userInternal, cred);
                  }));

                case 7:
                case "end":
                  return _context165.stop();
              }
            }
          }, _callee165);
        }));
        return _linkWithPhoneNumber2.apply(this, arguments);
      }

      function reauthenticateWithPhoneNumber(_x219, _x220, _x221) {
        return _reauthenticateWithPhoneNumber.apply(this, arguments);
      }
      /**
       * Returns a verification ID to be used in conjunction with the SMS code that is sent.
       *
       */


      function _reauthenticateWithPhoneNumber() {
        _reauthenticateWithPhoneNumber = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee166(user, phoneNumber, appVerifier) {
          var userInternal, verificationId;
          return regeneratorRuntime.wrap(function _callee166$(_context166) {
            while (1) {
              switch (_context166.prev = _context166.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);
                  _context166.next = 3;
                  return _verifyPhoneNumber(userInternal.auth, phoneNumber, (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(appVerifier));

                case 3:
                  verificationId = _context166.sent;
                  return _context166.abrupt("return", new ConfirmationResultImpl(verificationId, function (cred) {
                    return reauthenticateWithCredential(userInternal, cred);
                  }));

                case 5:
                case "end":
                  return _context166.stop();
              }
            }
          }, _callee166);
        }));
        return _reauthenticateWithPhoneNumber.apply(this, arguments);
      }

      function _verifyPhoneNumber(_x222, _x223, _x224) {
        return _verifyPhoneNumber2.apply(this, arguments);
      }
      /**
       * Updates the user's phone number.
       *
       * @example
       * ```
       * // 'recaptcha-container' is the ID of an element in the DOM.
       * const applicationVerifier = new RecaptchaVerifier('recaptcha-container');
       * const provider = new PhoneAuthProvider(auth);
       * const verificationId = await provider.verifyPhoneNumber('+16505550101', applicationVerifier);
       * // Obtain the verificationCode from the user.
       * const phoneCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
       * await updatePhoneNumber(user, phoneCredential);
       * ```
       *
       * @param user - The user.
       * @param credential - A credential authenticating the new phone number.
       *
       * @public
       */


      function _verifyPhoneNumber2() {
        _verifyPhoneNumber2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee167(auth, options, verifier) {
          var _a, recaptchaToken, phoneInfoOptions, session, response, mfaEnrollmentId, _response, _yield$sendPhoneVerif, sessionInfo;

          return regeneratorRuntime.wrap(function _callee167$(_context167) {
            while (1) {
              switch (_context167.prev = _context167.next) {
                case 0:
                  _context167.next = 2;
                  return verifier.verify();

                case 2:
                  recaptchaToken = _context167.sent;
                  _context167.prev = 3;

                  _assert(typeof recaptchaToken === 'string', auth, "argument-error"
                  /* ARGUMENT_ERROR */
                  );

                  _assert(verifier.type === RECAPTCHA_VERIFIER_TYPE, auth, "argument-error"
                  /* ARGUMENT_ERROR */
                  );

                  if (typeof options === 'string') {
                    phoneInfoOptions = {
                      phoneNumber: options
                    };
                  } else {
                    phoneInfoOptions = options;
                  }

                  if (!('session' in phoneInfoOptions)) {
                    _context167.next = 26;
                    break;
                  }

                  session = phoneInfoOptions.session;

                  if (!('phoneNumber' in phoneInfoOptions)) {
                    _context167.next = 17;
                    break;
                  }

                  _assert(session.type === "enroll"
                  /* ENROLL */
                  , auth, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  _context167.next = 13;
                  return startEnrollPhoneMfa(auth, {
                    idToken: session.credential,
                    phoneEnrollmentInfo: {
                      phoneNumber: phoneInfoOptions.phoneNumber,
                      recaptchaToken: recaptchaToken
                    }
                  });

                case 13:
                  response = _context167.sent;
                  return _context167.abrupt("return", response.phoneSessionInfo.sessionInfo);

                case 17:
                  _assert(session.type === "signin"
                  /* SIGN_IN */
                  , auth, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  mfaEnrollmentId = ((_a = phoneInfoOptions.multiFactorHint) === null || _a === void 0 ? void 0 : _a.uid) || phoneInfoOptions.multiFactorUid;

                  _assert(mfaEnrollmentId, auth, "missing-multi-factor-info"
                  /* MISSING_MFA_INFO */
                  );

                  _context167.next = 22;
                  return startSignInPhoneMfa(auth, {
                    mfaPendingCredential: session.credential,
                    mfaEnrollmentId: mfaEnrollmentId,
                    phoneSignInInfo: {
                      recaptchaToken: recaptchaToken
                    }
                  });

                case 22:
                  _response = _context167.sent;
                  return _context167.abrupt("return", _response.phoneResponseInfo.sessionInfo);

                case 24:
                  _context167.next = 31;
                  break;

                case 26:
                  _context167.next = 28;
                  return sendPhoneVerificationCode(auth, {
                    phoneNumber: phoneInfoOptions.phoneNumber,
                    recaptchaToken: recaptchaToken
                  });

                case 28:
                  _yield$sendPhoneVerif = _context167.sent;
                  sessionInfo = _yield$sendPhoneVerif.sessionInfo;
                  return _context167.abrupt("return", sessionInfo);

                case 31:
                  _context167.prev = 31;

                  verifier._reset();

                  return _context167.finish(31);

                case 34:
                case "end":
                  return _context167.stop();
              }
            }
          }, _callee167, null, [[3,, 31, 34]]);
        }));
        return _verifyPhoneNumber2.apply(this, arguments);
      }

      function updatePhoneNumber(_x225, _x226) {
        return _updatePhoneNumber.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Provider for generating an {@link PhoneAuthCredential}.
       *
       * @example
       * ```javascript
       * // 'recaptcha-container' is the ID of an element in the DOM.
       * const applicationVerifier = new RecaptchaVerifier('recaptcha-container');
       * const provider = new PhoneAuthProvider(auth);
       * const verificationId = await provider.verifyPhoneNumber('+16505550101', applicationVerifier);
       * // Obtain the verificationCode from the user.
       * const phoneCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
       * const userCredential = await signInWithCredential(auth, phoneCredential);
       * ```
       *
       * @public
       */


      function _updatePhoneNumber() {
        _updatePhoneNumber = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee168(user, credential) {
          return regeneratorRuntime.wrap(function _callee168$(_context168) {
            while (1) {
              switch (_context168.prev = _context168.next) {
                case 0:
                  _context168.next = 2;
                  return _link$1((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user), credential);

                case 2:
                case "end":
                  return _context168.stop();
              }
            }
          }, _callee168);
        }));
        return _updatePhoneNumber.apply(this, arguments);
      }

      var PhoneAuthProvider = /*#__PURE__*/function () {
        /**
         * @param auth - The Firebase {@link Auth} instance in which sign-ins should occur.
         *
         */
        function PhoneAuthProvider(auth) {
          _classCallCheck(this, PhoneAuthProvider);

          /** Always set to {@link ProviderId}.PHONE. */
          this.providerId = PhoneAuthProvider.PROVIDER_ID;
          this.auth = _castAuth(auth);
        }
        /**
         *
         * Starts a phone number authentication flow by sending a verification code to the given phone
         * number.
         *
         * @example
         * ```javascript
         * const provider = new PhoneAuthProvider(auth);
         * const verificationId = await provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
         * // Obtain verificationCode from the user.
         * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
         * const userCredential = await signInWithCredential(auth, authCredential);
         * ```
         *
         * @example
         * An alternative flow is provided using the `signInWithPhoneNumber` method.
         * ```javascript
         * const confirmationResult = signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
         * // Obtain verificationCode from the user.
         * const userCredential = confirmationResult.confirm(verificationCode);
         * ```
         *
         * @param phoneInfoOptions - The user's {@link PhoneInfoOptions}. The phone number should be in
         * E.164 format (e.g. +16505550101).
         * @param applicationVerifier - For abuse prevention, this method also requires a
         * {@link ApplicationVerifier}. This SDK includes a reCAPTCHA-based implementation,
         * {@link RecaptchaVerifier}.
         *
         * @returns A Promise for a verification ID that can be passed to
         * {@link PhoneAuthProvider.credential} to identify this flow..
         */


        _createClass(PhoneAuthProvider, [{
          key: "verifyPhoneNumber",
          value: function verifyPhoneNumber(phoneOptions, applicationVerifier) {
            return _verifyPhoneNumber(this.auth, phoneOptions, (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(applicationVerifier));
          }
          /**
           * Creates a phone auth credential, given the verification ID from
           * {@link PhoneAuthProvider.verifyPhoneNumber} and the code that was sent to the user's
           * mobile device.
           *
           * @example
           * ```javascript
           * const provider = new PhoneAuthProvider(auth);
           * const verificationId = provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
           * // Obtain verificationCode from the user.
           * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
           * const userCredential = signInWithCredential(auth, authCredential);
           * ```
           *
           * @example
           * An alternative flow is provided using the `signInWithPhoneNumber` method.
           * ```javascript
           * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
           * // Obtain verificationCode from the user.
           * const userCredential = await confirmationResult.confirm(verificationCode);
           * ```
           *
           * @param verificationId - The verification ID returned from {@link PhoneAuthProvider.verifyPhoneNumber}.
           * @param verificationCode - The verification code sent to the user's mobile device.
           *
           * @returns The auth provider credential.
           */

        }], [{
          key: "credential",
          value: function credential(verificationId, verificationCode) {
            return PhoneAuthCredential._fromVerification(verificationId, verificationCode);
          }
          /**
           * Generates an {@link AuthCredential} from a {@link UserCredential}.
           * @param userCredential - The user credential.
           */

        }, {
          key: "credentialFromResult",
          value: function credentialFromResult(userCredential) {
            var credential = userCredential;
            return PhoneAuthProvider.credentialFromTaggedObject(credential);
          }
          /**
           * Returns an {@link AuthCredential} when passed an error.
           *
           * @remarks
           *
           * This method works for errors like
           * `auth/account-exists-with-different-credentials`. This is useful for
           * recovering when attempting to set a user's phone number but the number
           * in question is already tied to another account. For example, the following
           * code tries to update the current user's phone number, and if that
           * fails, links the user with the account associated with that number:
           *
           * ```js
           * const provider = new PhoneAuthProvider(auth);
           * const verificationId = await provider.verifyPhoneNumber(number, verifier);
           * try {
           *   const code = ''; // Prompt the user for the verification code
           *   await updatePhoneNumber(
           *       auth.currentUser,
           *       PhoneAuthProvider.credential(verificationId, code));
           * } catch (e) {
           *   if (e.code === 'auth/account-exists-with-different-credential') {
           *     const cred = PhoneAuthProvider.credentialFromError(e);
           *     await linkWithCredential(auth.currentUser, cred);
           *   }
           * }
           *
           * // At this point, auth.currentUser.phoneNumber === number.
           * ```
           *
           * @param error - The error to generate a credential from.
           */

        }, {
          key: "credentialFromError",
          value: function credentialFromError(error) {
            return PhoneAuthProvider.credentialFromTaggedObject(error.customData || {});
          }
        }, {
          key: "credentialFromTaggedObject",
          value: function credentialFromTaggedObject(_ref31) {
            var tokenResponse = _ref31._tokenResponse;

            if (!tokenResponse) {
              return null;
            }

            var phoneNumber = tokenResponse.phoneNumber,
                temporaryProof = tokenResponse.temporaryProof;

            if (phoneNumber && temporaryProof) {
              return PhoneAuthCredential._fromTokenResponse(phoneNumber, temporaryProof);
            }

            return null;
          }
        }]);

        return PhoneAuthProvider;
      }();
      /** Always set to {@link ProviderId}.PHONE. */


      PhoneAuthProvider.PROVIDER_ID = "phone"
      /* PHONE */
      ;
      /** Always set to {@link SignInMethod}.PHONE. */

      PhoneAuthProvider.PHONE_SIGN_IN_METHOD = "phone"
      /* PHONE */
      ;
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Chooses a popup/redirect resolver to use. This prefers the override (which
       * is directly passed in), and falls back to the property set on the auth
       * object. If neither are available, this function errors w/ an argument error.
       */

      function _withDefaultResolver(auth, resolverOverride) {
        if (resolverOverride) {
          return _getInstance(resolverOverride);
        }

        _assert(auth._popupRedirectResolver, auth, "argument-error"
        /* ARGUMENT_ERROR */
        );

        return auth._popupRedirectResolver;
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var IdpCredential = /*#__PURE__*/function (_AuthCredential5) {
        _inherits(IdpCredential, _AuthCredential5);

        var _super21 = _createSuper(IdpCredential);

        function IdpCredential(params) {
          var _this36;

          _classCallCheck(this, IdpCredential);

          _this36 = _super21.call(this, "custom"
          /* CUSTOM */
          , "custom"
          /* CUSTOM */
          );
          _this36.params = params;
          return _this36;
        }

        _createClass(IdpCredential, [{
          key: "_getIdTokenResponse",
          value: function _getIdTokenResponse(auth) {
            return signInWithIdp(auth, this._buildIdpRequest());
          }
        }, {
          key: "_linkToIdToken",
          value: function _linkToIdToken(auth, idToken) {
            return signInWithIdp(auth, this._buildIdpRequest(idToken));
          }
        }, {
          key: "_getReauthenticationResolver",
          value: function _getReauthenticationResolver(auth) {
            return signInWithIdp(auth, this._buildIdpRequest());
          }
        }, {
          key: "_buildIdpRequest",
          value: function _buildIdpRequest(idToken) {
            var request = {
              requestUri: this.params.requestUri,
              sessionId: this.params.sessionId,
              postBody: this.params.postBody,
              tenantId: this.params.tenantId,
              pendingToken: this.params.pendingToken,
              returnSecureToken: true,
              returnIdpCredential: true
            };

            if (idToken) {
              request.idToken = idToken;
            }

            return request;
          }
        }]);

        return IdpCredential;
      }(AuthCredential);

      function _signIn(params) {
        return _signInWithCredential(params.auth, new IdpCredential(params), params.bypassAuthState);
      }

      function _reauth(params) {
        var auth = params.auth,
            user = params.user;

        _assert(user, auth, "internal-error"
        /* INTERNAL_ERROR */
        );

        return _reauthenticate(user, new IdpCredential(params), params.bypassAuthState);
      }

      function _link(_x227) {
        return _link2.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Popup event manager. Handles the popup's entire lifecycle; listens to auth
       * events
       */


      function _link2() {
        _link2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee169(params) {
          var auth, user;
          return regeneratorRuntime.wrap(function _callee169$(_context169) {
            while (1) {
              switch (_context169.prev = _context169.next) {
                case 0:
                  auth = params.auth, user = params.user;

                  _assert(user, auth, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  return _context169.abrupt("return", _link$1(user, new IdpCredential(params), params.bypassAuthState));

                case 3:
                case "end":
                  return _context169.stop();
              }
            }
          }, _callee169);
        }));
        return _link2.apply(this, arguments);
      }

      var AbstractPopupRedirectOperation = /*#__PURE__*/function () {
        function AbstractPopupRedirectOperation(auth, filter, resolver, user) {
          var bypassAuthState = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

          _classCallCheck(this, AbstractPopupRedirectOperation);

          this.auth = auth;
          this.resolver = resolver;
          this.user = user;
          this.bypassAuthState = bypassAuthState;
          this.pendingPromise = null;
          this.eventManager = null;
          this.filter = Array.isArray(filter) ? filter : [filter];
        }

        _createClass(AbstractPopupRedirectOperation, [{
          key: "execute",
          value: function execute() {
            var _this37 = this;

            return new Promise( /*#__PURE__*/function () {
              var _ref32 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee94(resolve, reject) {
                return regeneratorRuntime.wrap(function _callee94$(_context94) {
                  while (1) {
                    switch (_context94.prev = _context94.next) {
                      case 0:
                        _this37.pendingPromise = {
                          resolve: resolve,
                          reject: reject
                        };
                        _context94.prev = 1;
                        _context94.next = 4;
                        return _this37.resolver._initialize(_this37.auth);

                      case 4:
                        _this37.eventManager = _context94.sent;
                        _context94.next = 7;
                        return _this37.onExecution();

                      case 7:
                        _this37.eventManager.registerConsumer(_this37);

                        _context94.next = 13;
                        break;

                      case 10:
                        _context94.prev = 10;
                        _context94.t0 = _context94["catch"](1);

                        _this37.reject(_context94.t0);

                      case 13:
                      case "end":
                        return _context94.stop();
                    }
                  }
                }, _callee94, null, [[1, 10]]);
              }));

              return function (_x228, _x229) {
                return _ref32.apply(this, arguments);
              };
            }());
          }
        }, {
          key: "onAuthEvent",
          value: function () {
            var _onAuthEvent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee95(event) {
              var urlResponse, sessionId, postBody, tenantId, error, type, params;
              return regeneratorRuntime.wrap(function _callee95$(_context95) {
                while (1) {
                  switch (_context95.prev = _context95.next) {
                    case 0:
                      urlResponse = event.urlResponse, sessionId = event.sessionId, postBody = event.postBody, tenantId = event.tenantId, error = event.error, type = event.type;

                      if (!error) {
                        _context95.next = 4;
                        break;
                      }

                      this.reject(error);
                      return _context95.abrupt("return");

                    case 4:
                      params = {
                        auth: this.auth,
                        requestUri: urlResponse,
                        sessionId: sessionId,
                        tenantId: tenantId || undefined,
                        postBody: postBody || undefined,
                        user: this.user,
                        bypassAuthState: this.bypassAuthState
                      };
                      _context95.prev = 5;
                      _context95.t0 = this;
                      _context95.next = 9;
                      return this.getIdpTask(type)(params);

                    case 9:
                      _context95.t1 = _context95.sent;

                      _context95.t0.resolve.call(_context95.t0, _context95.t1);

                      _context95.next = 16;
                      break;

                    case 13:
                      _context95.prev = 13;
                      _context95.t2 = _context95["catch"](5);
                      this.reject(_context95.t2);

                    case 16:
                    case "end":
                      return _context95.stop();
                  }
                }
              }, _callee95, this, [[5, 13]]);
            }));

            function onAuthEvent(_x230) {
              return _onAuthEvent.apply(this, arguments);
            }

            return onAuthEvent;
          }()
        }, {
          key: "onError",
          value: function onError(error) {
            this.reject(error);
          }
        }, {
          key: "getIdpTask",
          value: function getIdpTask(type) {
            switch (type) {
              case "signInViaPopup"
              /* SIGN_IN_VIA_POPUP */
              :
              case "signInViaRedirect"
              /* SIGN_IN_VIA_REDIRECT */
              :
                return _signIn;

              case "linkViaPopup"
              /* LINK_VIA_POPUP */
              :
              case "linkViaRedirect"
              /* LINK_VIA_REDIRECT */
              :
                return _link;

              case "reauthViaPopup"
              /* REAUTH_VIA_POPUP */
              :
              case "reauthViaRedirect"
              /* REAUTH_VIA_REDIRECT */
              :
                return _reauth;

              default:
                _fail(this.auth, "internal-error"
                /* INTERNAL_ERROR */
                );

            }
          }
        }, {
          key: "resolve",
          value: function resolve(cred) {
            debugAssert(this.pendingPromise, 'Pending promise was never set');
            this.pendingPromise.resolve(cred);
            this.unregisterAndCleanUp();
          }
        }, {
          key: "reject",
          value: function reject(error) {
            debugAssert(this.pendingPromise, 'Pending promise was never set');
            this.pendingPromise.reject(error);
            this.unregisterAndCleanUp();
          }
        }, {
          key: "unregisterAndCleanUp",
          value: function unregisterAndCleanUp() {
            if (this.eventManager) {
              this.eventManager.unregisterConsumer(this);
            }

            this.pendingPromise = null;
            this.cleanUp();
          }
        }]);

        return AbstractPopupRedirectOperation;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var _POLL_WINDOW_CLOSE_TIMEOUT = new Delay(2000, 10000);
      /**
       * Authenticates a Firebase client using a popup-based OAuth authentication flow.
       *
       * @remarks
       * If succeeds, returns the signed in user along with the provider's credential. If sign in was
       * unsuccessful, returns an error object containing additional information about the error.
       *
       * @example
       * ```javascript
       * // Sign in using a popup.
       * const provider = new FacebookAuthProvider();
       * const result = await signInWithPopup(auth, provider);
       *
       * // The signed-in user info.
       * const user = result.user;
       * // This gives you a Facebook Access Token.
       * const credential = provider.credentialFromResult(auth, result);
       * const token = credential.accessToken;
       * ```
       *
       * @param auth - The {@link Auth} instance.
       * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
       * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
       * @param resolver - An instance of {@link PopupRedirectResolver}, optional
       * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
       *
       *
       * @public
       */


      function signInWithPopup(_x231, _x232, _x233) {
        return _signInWithPopup2.apply(this, arguments);
      }
      /**
       * Reauthenticates the current user with the specified {@link OAuthProvider} using a pop-up based
       * OAuth flow.
       *
       * @remarks
       * If the reauthentication is successful, the returned result will contain the user and the
       * provider's credential.
       *
       * @example
       * ```javascript
       * // Sign in using a popup.
       * const provider = new FacebookAuthProvider();
       * const result = await signInWithPopup(auth, provider);
       * // Reauthenticate using a popup.
       * await reauthenticateWithPopup(result.user, provider);
       * ```
       *
       * @param user - The user.
       * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
       * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
       * @param resolver - An instance of {@link PopupRedirectResolver}, optional
       * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
       *
       * @public
       */


      function _signInWithPopup2() {
        _signInWithPopup2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee170(auth, provider, resolver) {
          var authInternal, resolverInternal, action;
          return regeneratorRuntime.wrap(function _callee170$(_context170) {
            while (1) {
              switch (_context170.prev = _context170.next) {
                case 0:
                  authInternal = _castAuth(auth);

                  _assertInstanceOf(auth, provider, FederatedAuthProvider);

                  resolverInternal = _withDefaultResolver(authInternal, resolver);
                  action = new PopupOperation(authInternal, "signInViaPopup"
                  /* SIGN_IN_VIA_POPUP */
                  , provider, resolverInternal);
                  return _context170.abrupt("return", action.executeNotNull());

                case 5:
                case "end":
                  return _context170.stop();
              }
            }
          }, _callee170);
        }));
        return _signInWithPopup2.apply(this, arguments);
      }

      function reauthenticateWithPopup(_x234, _x235, _x236) {
        return _reauthenticateWithPopup.apply(this, arguments);
      }
      /**
       * Links the authenticated provider to the user account using a pop-up based OAuth flow.
       *
       * @remarks
       * If the linking is successful, the returned result will contain the user and the provider's credential.
       *
       *
       * @example
       * ```javascript
       * // Sign in using some other provider.
       * const result = await signInWithEmailAndPassword(auth, email, password);
       * // Link using a popup.
       * const provider = new FacebookAuthProvider();
       * await linkWithPopup(result.user, provider);
       * ```
       *
       * @param user - The user.
       * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
       * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
       * @param resolver - An instance of {@link PopupRedirectResolver}, optional
       * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
       *
       * @public
       */


      function _reauthenticateWithPopup() {
        _reauthenticateWithPopup = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee171(user, provider, resolver) {
          var userInternal, resolverInternal, action;
          return regeneratorRuntime.wrap(function _callee171$(_context171) {
            while (1) {
              switch (_context171.prev = _context171.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);

                  _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);

                  resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
                  action = new PopupOperation(userInternal.auth, "reauthViaPopup"
                  /* REAUTH_VIA_POPUP */
                  , provider, resolverInternal, userInternal);
                  return _context171.abrupt("return", action.executeNotNull());

                case 5:
                case "end":
                  return _context171.stop();
              }
            }
          }, _callee171);
        }));
        return _reauthenticateWithPopup.apply(this, arguments);
      }

      function linkWithPopup(_x237, _x238, _x239) {
        return _linkWithPopup2.apply(this, arguments);
      }
      /**
       * Popup event manager. Handles the popup's entire lifecycle; listens to auth
       * events
       *
       */


      function _linkWithPopup2() {
        _linkWithPopup2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee172(user, provider, resolver) {
          var userInternal, resolverInternal, action;
          return regeneratorRuntime.wrap(function _callee172$(_context172) {
            while (1) {
              switch (_context172.prev = _context172.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);

                  _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);

                  resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
                  action = new PopupOperation(userInternal.auth, "linkViaPopup"
                  /* LINK_VIA_POPUP */
                  , provider, resolverInternal, userInternal);
                  return _context172.abrupt("return", action.executeNotNull());

                case 5:
                case "end":
                  return _context172.stop();
              }
            }
          }, _callee172);
        }));
        return _linkWithPopup2.apply(this, arguments);
      }

      var PopupOperation = /*#__PURE__*/function (_AbstractPopupRedirec) {
        _inherits(PopupOperation, _AbstractPopupRedirec);

        var _super22 = _createSuper(PopupOperation);

        function PopupOperation(auth, filter, provider, resolver, user) {
          var _this38;

          _classCallCheck(this, PopupOperation);

          _this38 = _super22.call(this, auth, filter, resolver, user);
          _this38.provider = provider;
          _this38.authWindow = null;
          _this38.pollId = null;

          if (PopupOperation.currentPopupAction) {
            PopupOperation.currentPopupAction.cancel();
          }

          PopupOperation.currentPopupAction = _assertThisInitialized(_this38);
          return _this38;
        }

        _createClass(PopupOperation, [{
          key: "executeNotNull",
          value: function () {
            var _executeNotNull = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee96() {
              var result;
              return regeneratorRuntime.wrap(function _callee96$(_context96) {
                while (1) {
                  switch (_context96.prev = _context96.next) {
                    case 0:
                      _context96.next = 2;
                      return this.execute();

                    case 2:
                      result = _context96.sent;

                      _assert(result, this.auth, "internal-error"
                      /* INTERNAL_ERROR */
                      );

                      return _context96.abrupt("return", result);

                    case 5:
                    case "end":
                      return _context96.stop();
                  }
                }
              }, _callee96, this);
            }));

            function executeNotNull() {
              return _executeNotNull.apply(this, arguments);
            }

            return executeNotNull;
          }()
        }, {
          key: "onExecution",
          value: function () {
            var _onExecution = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee97() {
              var _this39 = this;

              var eventId;
              return regeneratorRuntime.wrap(function _callee97$(_context97) {
                while (1) {
                  switch (_context97.prev = _context97.next) {
                    case 0:
                      debugAssert(this.filter.length === 1, 'Popup operations only handle one event');
                      eventId = _generateEventId();
                      _context97.next = 4;
                      return this.resolver._openPopup(this.auth, this.provider, this.filter[0], // There's always one, see constructor
                      eventId);

                    case 4:
                      this.authWindow = _context97.sent;
                      this.authWindow.associatedEvent = eventId; // Check for web storage support and origin validation _after_ the popup is
                      // loaded. These operations are slow (~1 second or so) Rather than
                      // waiting on them before opening the window, optimistically open the popup
                      // and check for storage support at the same time. If storage support is
                      // not available, this will cause the whole thing to reject properly. It
                      // will also close the popup, but since the promise has already rejected,
                      // the popup closed by user poll will reject into the void.

                      this.resolver._originValidation(this.auth)["catch"](function (e) {
                        _this39.reject(e);
                      });

                      this.resolver._isIframeWebStorageSupported(this.auth, function (isSupported) {
                        if (!isSupported) {
                          _this39.reject(_createError(_this39.auth, "web-storage-unsupported"
                          /* WEB_STORAGE_UNSUPPORTED */
                          ));
                        }
                      }); // Handle user closure. Notice this does *not* use await


                      this.pollUserCancellation();

                    case 9:
                    case "end":
                      return _context97.stop();
                  }
                }
              }, _callee97, this);
            }));

            function onExecution() {
              return _onExecution.apply(this, arguments);
            }

            return onExecution;
          }()
        }, {
          key: "eventId",
          get: function get() {
            var _a;

            return ((_a = this.authWindow) === null || _a === void 0 ? void 0 : _a.associatedEvent) || null;
          }
        }, {
          key: "cancel",
          value: function cancel() {
            this.reject(_createError(this.auth, "cancelled-popup-request"
            /* EXPIRED_POPUP_REQUEST */
            ));
          }
        }, {
          key: "cleanUp",
          value: function cleanUp() {
            if (this.authWindow) {
              this.authWindow.close();
            }

            if (this.pollId) {
              window.clearTimeout(this.pollId);
            }

            this.authWindow = null;
            this.pollId = null;
            PopupOperation.currentPopupAction = null;
          }
        }, {
          key: "pollUserCancellation",
          value: function pollUserCancellation() {
            var _this40 = this;

            var poll = function poll() {
              var _a, _b;

              if ((_b = (_a = _this40.authWindow) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.closed) {
                // Make sure that there is sufficient time for whatever action to
                // complete. The window could have closed but the sign in network
                // call could still be in flight.
                _this40.pollId = window.setTimeout(function () {
                  _this40.pollId = null;

                  _this40.reject(_createError(_this40.auth, "popup-closed-by-user"
                  /* POPUP_CLOSED_BY_USER */
                  ));
                }, 2000
                /* AUTH_EVENT */
                );
                return;
              }

              _this40.pollId = window.setTimeout(poll, _POLL_WINDOW_CLOSE_TIMEOUT.get());
            };

            poll();
          }
        }]);

        return PopupOperation;
      }(AbstractPopupRedirectOperation); // Only one popup is ever shown at once. The lifecycle of the current popup
      // can be managed / cancelled by the constructor.


      PopupOperation.currentPopupAction = null;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      var PENDING_REDIRECT_KEY = 'pendingRedirect'; // We only get one redirect outcome for any one auth, so just store it
      // in here.

      var redirectOutcomeMap = new Map();

      var RedirectAction = /*#__PURE__*/function (_AbstractPopupRedirec2) {
        _inherits(RedirectAction, _AbstractPopupRedirec2);

        var _super23 = _createSuper(RedirectAction);

        function RedirectAction(auth, resolver) {
          var _this41;

          var bypassAuthState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          _classCallCheck(this, RedirectAction);

          _this41 = _super23.call(this, auth, ["signInViaRedirect"
          /* SIGN_IN_VIA_REDIRECT */
          , "linkViaRedirect"
          /* LINK_VIA_REDIRECT */
          , "reauthViaRedirect"
          /* REAUTH_VIA_REDIRECT */
          , "unknown"
          /* UNKNOWN */
          ], resolver, undefined, bypassAuthState);
          _this41.eventId = null;
          return _this41;
        }
        /**
         * Override the execute function; if we already have a redirect result, then
         * just return it.
         */


        _createClass(RedirectAction, [{
          key: "execute",
          value: function () {
            var _execute2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee98() {
              var readyOutcome, hasPendingRedirect, result;
              return regeneratorRuntime.wrap(function _callee98$(_context98) {
                while (1) {
                  switch (_context98.prev = _context98.next) {
                    case 0:
                      readyOutcome = redirectOutcomeMap.get(this.auth._key());

                      if (readyOutcome) {
                        _context98.next = 21;
                        break;
                      }

                      _context98.prev = 2;
                      _context98.next = 5;
                      return _getAndClearPendingRedirectStatus(this.resolver, this.auth);

                    case 5:
                      hasPendingRedirect = _context98.sent;

                      if (!hasPendingRedirect) {
                        _context98.next = 12;
                        break;
                      }

                      _context98.next = 9;
                      return _get3(_getPrototypeOf(RedirectAction.prototype), "execute", this).call(this);

                    case 9:
                      _context98.t0 = _context98.sent;
                      _context98.next = 13;
                      break;

                    case 12:
                      _context98.t0 = null;

                    case 13:
                      result = _context98.t0;

                      readyOutcome = function readyOutcome() {
                        return Promise.resolve(result);
                      };

                      _context98.next = 20;
                      break;

                    case 17:
                      _context98.prev = 17;
                      _context98.t1 = _context98["catch"](2);

                      readyOutcome = function readyOutcome() {
                        return Promise.reject(_context98.t1);
                      };

                    case 20:
                      redirectOutcomeMap.set(this.auth._key(), readyOutcome);

                    case 21:
                      // If we're not bypassing auth state, the ready outcome should be set to
                      // null.
                      if (!this.bypassAuthState) {
                        redirectOutcomeMap.set(this.auth._key(), function () {
                          return Promise.resolve(null);
                        });
                      }

                      return _context98.abrupt("return", readyOutcome());

                    case 23:
                    case "end":
                      return _context98.stop();
                  }
                }
              }, _callee98, this, [[2, 17]]);
            }));

            function execute() {
              return _execute2.apply(this, arguments);
            }

            return execute;
          }()
        }, {
          key: "onAuthEvent",
          value: function () {
            var _onAuthEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee99(event) {
              var user;
              return regeneratorRuntime.wrap(function _callee99$(_context99) {
                while (1) {
                  switch (_context99.prev = _context99.next) {
                    case 0:
                      if (!(event.type === "signInViaRedirect"
                      /* SIGN_IN_VIA_REDIRECT */
                      )) {
                        _context99.next = 4;
                        break;
                      }

                      return _context99.abrupt("return", _get3(_getPrototypeOf(RedirectAction.prototype), "onAuthEvent", this).call(this, event));

                    case 4:
                      if (!(event.type === "unknown"
                      /* UNKNOWN */
                      )) {
                        _context99.next = 7;
                        break;
                      }

                      // This is a sentinel value indicating there's no pending redirect
                      this.resolve(null);
                      return _context99.abrupt("return");

                    case 7:
                      if (!event.eventId) {
                        _context99.next = 17;
                        break;
                      }

                      _context99.next = 10;
                      return this.auth._redirectUserForId(event.eventId);

                    case 10:
                      user = _context99.sent;

                      if (!user) {
                        _context99.next = 16;
                        break;
                      }

                      this.user = user;
                      return _context99.abrupt("return", _get3(_getPrototypeOf(RedirectAction.prototype), "onAuthEvent", this).call(this, event));

                    case 16:
                      this.resolve(null);

                    case 17:
                    case "end":
                      return _context99.stop();
                  }
                }
              }, _callee99, this);
            }));

            function onAuthEvent(_x240) {
              return _onAuthEvent2.apply(this, arguments);
            }

            return onAuthEvent;
          }()
        }, {
          key: "onExecution",
          value: function () {
            var _onExecution2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee100() {
              return regeneratorRuntime.wrap(function _callee100$(_context100) {
                while (1) {
                  switch (_context100.prev = _context100.next) {
                    case 0:
                    case "end":
                      return _context100.stop();
                  }
                }
              }, _callee100);
            }));

            function onExecution() {
              return _onExecution2.apply(this, arguments);
            }

            return onExecution;
          }()
        }, {
          key: "cleanUp",
          value: function cleanUp() {}
        }]);

        return RedirectAction;
      }(AbstractPopupRedirectOperation);

      function _getAndClearPendingRedirectStatus(_x241, _x242) {
        return _getAndClearPendingRedirectStatus2.apply(this, arguments);
      }

      function _getAndClearPendingRedirectStatus2() {
        _getAndClearPendingRedirectStatus2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee173(resolver, auth) {
          var key, persistence, hasPendingRedirect;
          return regeneratorRuntime.wrap(function _callee173$(_context173) {
            while (1) {
              switch (_context173.prev = _context173.next) {
                case 0:
                  key = pendingRedirectKey(auth);
                  persistence = resolverPersistence(resolver);
                  _context173.next = 4;
                  return persistence._isAvailable();

                case 4:
                  if (_context173.sent) {
                    _context173.next = 6;
                    break;
                  }

                  return _context173.abrupt("return", false);

                case 6:
                  _context173.next = 8;
                  return persistence._get(key);

                case 8:
                  _context173.t0 = _context173.sent;
                  hasPendingRedirect = _context173.t0 === 'true';
                  _context173.next = 12;
                  return persistence._remove(key);

                case 12:
                  return _context173.abrupt("return", hasPendingRedirect);

                case 13:
                case "end":
                  return _context173.stop();
              }
            }
          }, _callee173);
        }));
        return _getAndClearPendingRedirectStatus2.apply(this, arguments);
      }

      function _setPendingRedirectStatus(_x243, _x244) {
        return _setPendingRedirectStatus2.apply(this, arguments);
      }

      function _setPendingRedirectStatus2() {
        _setPendingRedirectStatus2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee174(resolver, auth) {
          return regeneratorRuntime.wrap(function _callee174$(_context174) {
            while (1) {
              switch (_context174.prev = _context174.next) {
                case 0:
                  return _context174.abrupt("return", resolverPersistence(resolver)._set(pendingRedirectKey(auth), 'true'));

                case 1:
                case "end":
                  return _context174.stop();
              }
            }
          }, _callee174);
        }));
        return _setPendingRedirectStatus2.apply(this, arguments);
      }

      function _clearRedirectOutcomes() {
        redirectOutcomeMap.clear();
      }

      function resolverPersistence(resolver) {
        return _getInstance(resolver._redirectPersistence);
      }

      function pendingRedirectKey(auth) {
        return _persistenceKeyName(PENDING_REDIRECT_KEY, auth.config.apiKey, auth.name);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Authenticates a Firebase client using a full-page redirect flow.
       *
       * @remarks
       * To handle the results and errors for this operation, refer to {@link getRedirectResult}.
       *
       * @example
       * ```javascript
       * // Sign in using a redirect.
       * const provider = new FacebookAuthProvider();
       * // You can add additional scopes to the provider:
       * provider.addScope('user_birthday');
       * // Start a sign in process for an unauthenticated user.
       * await signInWithRedirect(auth, provider);
       * // This will trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * if (result) {
       *   // This is the signed-in user
       *   const user = result.user;
       *   // This gives you a Facebook Access Token.
       *   const credential = provider.credentialFromResult(auth, result);
       *   const token = credential.accessToken;
       * }
       * // As this API can be used for sign-in, linking and reauthentication,
       * // check the operationType to determine what triggered this redirect
       * // operation.
       * const operationType = result.operationType;
       * ```
       *
       * @param auth - The {@link Auth} instance.
       * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
       * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
       * @param resolver - An instance of {@link PopupRedirectResolver}, optional
       * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
       *
       * @public
       */


      function signInWithRedirect(auth, provider, resolver) {
        return _signInWithRedirect(auth, provider, resolver);
      }

      function _signInWithRedirect(_x245, _x246, _x247) {
        return _signInWithRedirect3.apply(this, arguments);
      }
      /**
       * Reauthenticates the current user with the specified {@link OAuthProvider} using a full-page redirect flow.
       *
       * @example
       * ```javascript
       * // Sign in using a redirect.
       * const provider = new FacebookAuthProvider();
       * const result = await signInWithRedirect(auth, provider);
       * // This will trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * // Link using a redirect.
       * await linkWithRedirect(result.user, provider);
       * // This will again trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * ```
       *
       * @param user - The user.
       * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
       * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
       * @param resolver - An instance of {@link PopupRedirectResolver}, optional
       * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
       *
       * @public
       */


      function _signInWithRedirect3() {
        _signInWithRedirect3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee175(auth, provider, resolver) {
          var authInternal, resolverInternal;
          return regeneratorRuntime.wrap(function _callee175$(_context175) {
            while (1) {
              switch (_context175.prev = _context175.next) {
                case 0:
                  authInternal = _castAuth(auth);

                  _assertInstanceOf(auth, provider, FederatedAuthProvider);

                  resolverInternal = _withDefaultResolver(authInternal, resolver);
                  _context175.next = 5;
                  return _setPendingRedirectStatus(resolverInternal, authInternal);

                case 5:
                  return _context175.abrupt("return", resolverInternal._openRedirect(authInternal, provider, "signInViaRedirect"
                  /* SIGN_IN_VIA_REDIRECT */
                  ));

                case 6:
                case "end":
                  return _context175.stop();
              }
            }
          }, _callee175);
        }));
        return _signInWithRedirect3.apply(this, arguments);
      }

      function reauthenticateWithRedirect(user, provider, resolver) {
        return _reauthenticateWithRedirect(user, provider, resolver);
      }

      function _reauthenticateWithRedirect(_x248, _x249, _x250) {
        return _reauthenticateWithRedirect3.apply(this, arguments);
      }
      /**
       * Links the {@link OAuthProvider} to the user account using a full-page redirect flow.
       *
       * @example
       * ```javascript
       * // Sign in using some other provider.
       * const result = await signInWithEmailAndPassword(auth, email, password);
       * // Link using a redirect.
       * const provider = new FacebookAuthProvider();
       * await linkWithRedirect(result.user, provider);
       * // This will trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * ```
       *
       * @param user - The user.
       * @param provider - The provider to authenticate. The provider has to be an {@link OAuthProvider}.
       * Non-OAuth providers like {@link EmailAuthProvider} will throw an error.
       * @param resolver - An instance of {@link PopupRedirectResolver}, optional
       * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
       *
       *
       * @public
       */


      function _reauthenticateWithRedirect3() {
        _reauthenticateWithRedirect3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee176(user, provider, resolver) {
          var userInternal, resolverInternal, eventId;
          return regeneratorRuntime.wrap(function _callee176$(_context176) {
            while (1) {
              switch (_context176.prev = _context176.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);

                  _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider); // Allow the resolver to error before persisting the redirect user


                  resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
                  _context176.next = 5;
                  return _setPendingRedirectStatus(resolverInternal, userInternal.auth);

                case 5:
                  _context176.next = 7;
                  return prepareUserForRedirect(userInternal);

                case 7:
                  eventId = _context176.sent;
                  return _context176.abrupt("return", resolverInternal._openRedirect(userInternal.auth, provider, "reauthViaRedirect"
                  /* REAUTH_VIA_REDIRECT */
                  , eventId));

                case 9:
                case "end":
                  return _context176.stop();
              }
            }
          }, _callee176);
        }));
        return _reauthenticateWithRedirect3.apply(this, arguments);
      }

      function linkWithRedirect(user, provider, resolver) {
        return _linkWithRedirect(user, provider, resolver);
      }

      function _linkWithRedirect(_x251, _x252, _x253) {
        return _linkWithRedirect3.apply(this, arguments);
      }
      /**
       * Returns a {@link UserCredential} from the redirect-based sign-in flow.
       *
       * @remarks
       * If sign-in succeeded, returns the signed in user. If sign-in was unsuccessful, fails with an
       * error. If no redirect operation was called, returns a {@link UserCredential}
       * with a null `user`.
       *
       * @example
       * ```javascript
       * // Sign in using a redirect.
       * const provider = new FacebookAuthProvider();
       * // You can add additional scopes to the provider:
       * provider.addScope('user_birthday');
       * // Start a sign in process for an unauthenticated user.
       * await signInWithRedirect(auth, provider);
       * // This will trigger a full page redirect away from your app
       *
       * // After returning from the redirect when your app initializes you can obtain the result
       * const result = await getRedirectResult(auth);
       * if (result) {
       *   // This is the signed-in user
       *   const user = result.user;
       *   // This gives you a Facebook Access Token.
       *   const credential = provider.credentialFromResult(auth, result);
       *   const token = credential.accessToken;
       * }
       * // As this API can be used for sign-in, linking and reauthentication,
       * // check the operationType to determine what triggered this redirect
       * // operation.
       * const operationType = result.operationType;
       * ```
       *
       * @param auth - The {@link Auth} instance.
       * @param resolver - An instance of {@link PopupRedirectResolver}, optional
       * if already supplied to {@link initializeAuth} or provided by {@link getAuth}.
       *
       * @public
       */


      function _linkWithRedirect3() {
        _linkWithRedirect3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee177(user, provider, resolver) {
          var userInternal, resolverInternal, eventId;
          return regeneratorRuntime.wrap(function _callee177$(_context177) {
            while (1) {
              switch (_context177.prev = _context177.next) {
                case 0:
                  userInternal = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getModularInstance)(user);

                  _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider); // Allow the resolver to error before persisting the redirect user


                  resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
                  _context177.next = 5;
                  return _assertLinkedStatus(false, userInternal, provider.providerId);

                case 5:
                  _context177.next = 7;
                  return _setPendingRedirectStatus(resolverInternal, userInternal.auth);

                case 7:
                  _context177.next = 9;
                  return prepareUserForRedirect(userInternal);

                case 9:
                  eventId = _context177.sent;
                  return _context177.abrupt("return", resolverInternal._openRedirect(userInternal.auth, provider, "linkViaRedirect"
                  /* LINK_VIA_REDIRECT */
                  , eventId));

                case 11:
                case "end":
                  return _context177.stop();
              }
            }
          }, _callee177);
        }));
        return _linkWithRedirect3.apply(this, arguments);
      }

      function getRedirectResult(_x254, _x255) {
        return _getRedirectResult3.apply(this, arguments);
      }

      function _getRedirectResult3() {
        _getRedirectResult3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee178(auth, resolver) {
          return regeneratorRuntime.wrap(function _callee178$(_context178) {
            while (1) {
              switch (_context178.prev = _context178.next) {
                case 0:
                  _context178.next = 2;
                  return _castAuth(auth)._initializationPromise;

                case 2:
                  return _context178.abrupt("return", _getRedirectResult(auth, resolver, false));

                case 3:
                case "end":
                  return _context178.stop();
              }
            }
          }, _callee178);
        }));
        return _getRedirectResult3.apply(this, arguments);
      }

      function _getRedirectResult(_x256, _x257) {
        return _getRedirectResult4.apply(this, arguments);
      }

      function _getRedirectResult4() {
        _getRedirectResult4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee179(auth, resolverExtern) {
          var bypassAuthState,
              authInternal,
              resolver,
              action,
              result,
              _args179 = arguments;
          return regeneratorRuntime.wrap(function _callee179$(_context179) {
            while (1) {
              switch (_context179.prev = _context179.next) {
                case 0:
                  bypassAuthState = _args179.length > 2 && _args179[2] !== undefined ? _args179[2] : false;
                  authInternal = _castAuth(auth);
                  resolver = _withDefaultResolver(authInternal, resolverExtern);
                  action = new RedirectAction(authInternal, resolver, bypassAuthState);
                  _context179.next = 6;
                  return action.execute();

                case 6:
                  result = _context179.sent;

                  if (!(result && !bypassAuthState)) {
                    _context179.next = 13;
                    break;
                  }

                  delete result.user._redirectEventId;
                  _context179.next = 11;
                  return authInternal._persistUserIfCurrent(result.user);

                case 11:
                  _context179.next = 13;
                  return authInternal._setRedirectUser(null, resolverExtern);

                case 13:
                  return _context179.abrupt("return", result);

                case 14:
                case "end":
                  return _context179.stop();
              }
            }
          }, _callee179);
        }));
        return _getRedirectResult4.apply(this, arguments);
      }

      function prepareUserForRedirect(_x258) {
        return _prepareUserForRedirect.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      // The amount of time to store the UIDs of seen events; this is
      // set to 10 min by default


      function _prepareUserForRedirect() {
        _prepareUserForRedirect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee180(user) {
          var eventId;
          return regeneratorRuntime.wrap(function _callee180$(_context180) {
            while (1) {
              switch (_context180.prev = _context180.next) {
                case 0:
                  eventId = _generateEventId("".concat(user.uid, ":::"));
                  user._redirectEventId = eventId;
                  _context180.next = 4;
                  return user.auth._setRedirectUser(user);

                case 4:
                  _context180.next = 6;
                  return user.auth._persistUserIfCurrent(user);

                case 6:
                  return _context180.abrupt("return", eventId);

                case 7:
                case "end":
                  return _context180.stop();
              }
            }
          }, _callee180);
        }));
        return _prepareUserForRedirect.apply(this, arguments);
      }

      var EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1000;

      var AuthEventManager = /*#__PURE__*/function () {
        function AuthEventManager(auth) {
          _classCallCheck(this, AuthEventManager);

          this.auth = auth;
          this.cachedEventUids = new Set();
          this.consumers = new Set();
          this.queuedRedirectEvent = null;
          this.hasHandledPotentialRedirect = false;
          this.lastProcessedEventTime = Date.now();
        }

        _createClass(AuthEventManager, [{
          key: "registerConsumer",
          value: function registerConsumer(authEventConsumer) {
            this.consumers.add(authEventConsumer);

            if (this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, authEventConsumer)) {
              this.sendToConsumer(this.queuedRedirectEvent, authEventConsumer);
              this.saveEventToCache(this.queuedRedirectEvent);
              this.queuedRedirectEvent = null;
            }
          }
        }, {
          key: "unregisterConsumer",
          value: function unregisterConsumer(authEventConsumer) {
            this.consumers["delete"](authEventConsumer);
          }
        }, {
          key: "onEvent",
          value: function onEvent(event) {
            var _this42 = this;

            // Check if the event has already been handled
            if (this.hasEventBeenHandled(event)) {
              return false;
            }

            var handled = false;
            this.consumers.forEach(function (consumer) {
              if (_this42.isEventForConsumer(event, consumer)) {
                handled = true;

                _this42.sendToConsumer(event, consumer);

                _this42.saveEventToCache(event);
              }
            });

            if (this.hasHandledPotentialRedirect || !isRedirectEvent(event)) {
              // If we've already seen a redirect before, or this is a popup event,
              // bail now
              return handled;
            }

            this.hasHandledPotentialRedirect = true; // If the redirect wasn't handled, hang on to it

            if (!handled) {
              this.queuedRedirectEvent = event;
              handled = true;
            }

            return handled;
          }
        }, {
          key: "sendToConsumer",
          value: function sendToConsumer(event, consumer) {
            var _a;

            if (event.error && !isNullRedirectEvent(event)) {
              var code = ((_a = event.error.code) === null || _a === void 0 ? void 0 : _a.split('auth/')[1]) || "internal-error"
              /* INTERNAL_ERROR */
              ;
              consumer.onError(_createError(this.auth, code));
            } else {
              consumer.onAuthEvent(event);
            }
          }
        }, {
          key: "isEventForConsumer",
          value: function isEventForConsumer(event, consumer) {
            var eventIdMatches = consumer.eventId === null || !!event.eventId && event.eventId === consumer.eventId;
            return consumer.filter.includes(event.type) && eventIdMatches;
          }
        }, {
          key: "hasEventBeenHandled",
          value: function hasEventBeenHandled(event) {
            if (Date.now() - this.lastProcessedEventTime >= EVENT_DUPLICATION_CACHE_DURATION_MS) {
              this.cachedEventUids.clear();
            }

            return this.cachedEventUids.has(eventUid(event));
          }
        }, {
          key: "saveEventToCache",
          value: function saveEventToCache(event) {
            this.cachedEventUids.add(eventUid(event));
            this.lastProcessedEventTime = Date.now();
          }
        }]);

        return AuthEventManager;
      }();

      function eventUid(e) {
        return [e.type, e.eventId, e.sessionId, e.tenantId].filter(function (v) {
          return v;
        }).join('-');
      }

      function isNullRedirectEvent(_ref33) {
        var type = _ref33.type,
            error = _ref33.error;
        return type === "unknown"
        /* UNKNOWN */
        && (error === null || error === void 0 ? void 0 : error.code) === "auth/".concat("no-auth-event"
        /* NO_AUTH_EVENT */
        );
      }

      function isRedirectEvent(event) {
        switch (event.type) {
          case "signInViaRedirect"
          /* SIGN_IN_VIA_REDIRECT */
          :
          case "linkViaRedirect"
          /* LINK_VIA_REDIRECT */
          :
          case "reauthViaRedirect"
          /* REAUTH_VIA_REDIRECT */
          :
            return true;

          case "unknown"
          /* UNKNOWN */
          :
            return isNullRedirectEvent(event);

          default:
            return false;
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _getProjectConfig(_x259) {
        return _getProjectConfig2.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _getProjectConfig2() {
        _getProjectConfig2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee181(auth) {
          var request,
              _args181 = arguments;
          return regeneratorRuntime.wrap(function _callee181$(_context181) {
            while (1) {
              switch (_context181.prev = _context181.next) {
                case 0:
                  request = _args181.length > 1 && _args181[1] !== undefined ? _args181[1] : {};
                  return _context181.abrupt("return", _performApiRequest(auth, "GET"
                  /* GET */
                  , "/v1/projects"
                  /* GET_PROJECT_CONFIG */
                  , request));

                case 2:
                case "end":
                  return _context181.stop();
              }
            }
          }, _callee181);
        }));
        return _getProjectConfig2.apply(this, arguments);
      }

      var IP_ADDRESS_REGEX = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      var HTTP_REGEX = /^https?/;

      function _validateOrigin(_x260) {
        return _validateOrigin2.apply(this, arguments);
      }

      function _validateOrigin2() {
        _validateOrigin2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee182(auth) {
          var _yield$_getProjectCon, authorizedDomains, _iterator3, _step3, domain;

          return regeneratorRuntime.wrap(function _callee182$(_context182) {
            while (1) {
              switch (_context182.prev = _context182.next) {
                case 0:
                  if (!auth.config.emulator) {
                    _context182.next = 2;
                    break;
                  }

                  return _context182.abrupt("return");

                case 2:
                  _context182.next = 4;
                  return _getProjectConfig(auth);

                case 4:
                  _yield$_getProjectCon = _context182.sent;
                  authorizedDomains = _yield$_getProjectCon.authorizedDomains;
                  _iterator3 = _createForOfIteratorHelper(authorizedDomains);
                  _context182.prev = 7;

                  _iterator3.s();

                case 9:
                  if ((_step3 = _iterator3.n()).done) {
                    _context182.next = 20;
                    break;
                  }

                  domain = _step3.value;
                  _context182.prev = 11;

                  if (!matchDomain(domain)) {
                    _context182.next = 14;
                    break;
                  }

                  return _context182.abrupt("return");

                case 14:
                  _context182.next = 18;
                  break;

                case 16:
                  _context182.prev = 16;
                  _context182.t0 = _context182["catch"](11);

                case 18:
                  _context182.next = 9;
                  break;

                case 20:
                  _context182.next = 25;
                  break;

                case 22:
                  _context182.prev = 22;
                  _context182.t1 = _context182["catch"](7);

                  _iterator3.e(_context182.t1);

                case 25:
                  _context182.prev = 25;

                  _iterator3.f();

                  return _context182.finish(25);

                case 28:
                  // In the old SDK, this error also provides helpful messages.
                  _fail(auth, "unauthorized-domain"
                  /* INVALID_ORIGIN */
                  );

                case 29:
                case "end":
                  return _context182.stop();
              }
            }
          }, _callee182, null, [[7, 22, 25, 28], [11, 16]]);
        }));
        return _validateOrigin2.apply(this, arguments);
      }

      function matchDomain(expected) {
        var currentUrl = _getCurrentUrl();

        var _URL = new URL(currentUrl),
            protocol = _URL.protocol,
            hostname = _URL.hostname;

        if (expected.startsWith('chrome-extension://')) {
          var ceUrl = new URL(expected);

          if (ceUrl.hostname === '' && hostname === '') {
            // For some reason we're not parsing chrome URLs properly
            return protocol === 'chrome-extension:' && expected.replace('chrome-extension://', '') === currentUrl.replace('chrome-extension://', '');
          }

          return protocol === 'chrome-extension:' && ceUrl.hostname === hostname;
        }

        if (!HTTP_REGEX.test(protocol)) {
          return false;
        }

        if (IP_ADDRESS_REGEX.test(expected)) {
          // The domain has to be exactly equal to the pattern, as an IP domain will
          // only contain the IP, no extra character.
          return hostname === expected;
        } // Dots in pattern should be escaped.


        var escapedDomainPattern = expected.replace(/\./g, '\\.'); // Non ip address domains.
        // domain.com = *.domain.com OR domain.com

        var re = new RegExp('^(.+\\.' + escapedDomainPattern + '|' + escapedDomainPattern + ')$', 'i');
        return re.test(hostname);
      }
      /**
       * @license
       * Copyright 2020 Google LLC.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var NETWORK_TIMEOUT = new Delay(30000, 60000);
      /**
       * Reset unlaoded GApi modules. If gapi.load fails due to a network error,
       * it will stop working after a retrial. This is a hack to fix this issue.
       */

      function resetUnloadedGapiModules() {
        // Clear last failed gapi.load state to force next gapi.load to first
        // load the failed gapi.iframes module.
        // Get gapix.beacon context.
        var beacon = _window().___jsl; // Get current hint.


        if (beacon === null || beacon === void 0 ? void 0 : beacon.H) {
          // Get gapi hint.
          for (var _i6 = 0, _Object$keys3 = Object.keys(beacon.H); _i6 < _Object$keys3.length; _i6++) {
            var hint = _Object$keys3[_i6];
            // Requested modules.
            beacon.H[hint].r = beacon.H[hint].r || []; // Loaded modules.

            beacon.H[hint].L = beacon.H[hint].L || []; // Set requested modules to a copy of the loaded modules.

            beacon.H[hint].r = _toConsumableArray(beacon.H[hint].L); // Clear pending callbacks.

            if (beacon.CP) {
              for (var i = 0; i < beacon.CP.length; i++) {
                // Remove all failed pending callbacks.
                beacon.CP[i] = null;
              }
            }
          }
        }
      }

      function loadGapi(auth) {
        return new Promise(function (resolve, reject) {
          var _a, _b, _c; // Function to run when gapi.load is ready.


          function loadGapiIframe() {
            // The developer may have tried to previously run gapi.load and failed.
            // Run this to fix that.
            resetUnloadedGapiModules();
            gapi.load('gapi.iframes', {
              callback: function callback() {
                resolve(gapi.iframes.getContext());
              },
              ontimeout: function ontimeout() {
                // The above reset may be sufficient, but having this reset after
                // failure ensures that if the developer calls gapi.load after the
                // connection is re-established and before another attempt to embed
                // the iframe, it would work and would not be broken because of our
                // failed attempt.
                // Timeout when gapi.iframes.Iframe not loaded.
                resetUnloadedGapiModules();
                reject(_createError(auth, "network-request-failed"
                /* NETWORK_REQUEST_FAILED */
                ));
              },
              timeout: NETWORK_TIMEOUT.get()
            });
          }

          if ((_b = (_a = _window().gapi) === null || _a === void 0 ? void 0 : _a.iframes) === null || _b === void 0 ? void 0 : _b.Iframe) {
            // If gapi.iframes.Iframe available, resolve.
            resolve(gapi.iframes.getContext());
          } else if (!!((_c = _window().gapi) === null || _c === void 0 ? void 0 : _c.load)) {
            // Gapi loader ready, load gapi.iframes.
            loadGapiIframe();
          } else {
            // Create a new iframe callback when this is called so as not to overwrite
            // any previous defined callback. This happens if this method is called
            // multiple times in parallel and could result in the later callback
            // overwriting the previous one. This would end up with a iframe
            // timeout.
            var cbName = _generateCallbackName('iframefcb'); // GApi loader not available, dynamically load platform.js.


            _window()[cbName] = function () {
              // GApi loader should be ready.
              if (!!gapi.load) {
                loadGapiIframe();
              } else {
                // Gapi loader failed, throw error.
                reject(_createError(auth, "network-request-failed"
                /* NETWORK_REQUEST_FAILED */
                ));
              }
            }; // Load GApi loader.


            return _loadJS("https://apis.google.com/js/api.js?onload=".concat(cbName));
          }
        })["catch"](function (error) {
          // Reset cached promise to allow for retrial.
          cachedGApiLoader = null;
          throw error;
        });
      }

      var cachedGApiLoader = null;

      function _loadGapi(auth) {
        cachedGApiLoader = cachedGApiLoader || loadGapi(auth);
        return cachedGApiLoader;
      }
      /**
       * @license
       * Copyright 2020 Google LLC.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var PING_TIMEOUT = new Delay(5000, 15000);
      var IFRAME_PATH = '__/auth/iframe';
      var EMULATED_IFRAME_PATH = 'emulator/auth/iframe';
      var IFRAME_ATTRIBUTES = {
        style: {
          position: 'absolute',
          top: '-100px',
          width: '1px',
          height: '1px'
        },
        'aria-hidden': 'true'
      }; // Map from apiHost to endpoint ID for passing into iframe. In current SDK, apiHost can be set to
      // anything (not from a list of endpoints with IDs as in legacy), so this is the closest we can get.

      var EID_FROM_APIHOST = new Map([["identitytoolkit.googleapis.com"
      /* API_HOST */
      , 'p'], ['staging-identitytoolkit.sandbox.googleapis.com', 's'], ['test-identitytoolkit.sandbox.googleapis.com', 't'] // test
      ]);

      function getIframeUrl(auth) {
        var config = auth.config;

        _assert(config.authDomain, auth, "auth-domain-config-required"
        /* MISSING_AUTH_DOMAIN */
        );

        var url = config.emulator ? _emulatorUrl(config, EMULATED_IFRAME_PATH) : "https://".concat(auth.config.authDomain, "/").concat(IFRAME_PATH);
        var params = {
          apiKey: config.apiKey,
          appName: auth.name,
          v: _firebase_app__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION
        };
        var eid = EID_FROM_APIHOST.get(auth.config.apiHost);

        if (eid) {
          params.eid = eid;
        }

        var frameworks = auth._getFrameworks();

        if (frameworks.length) {
          params.fw = frameworks.join(',');
        }

        return "".concat(url, "?").concat((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystring)(params).slice(1));
      }

      function _openIframe(_x261) {
        return _openIframe2.apply(this, arguments);
      }
      /**
       * @license
       * Copyright 2020 Google LLC.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _openIframe2() {
        _openIframe2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee184(auth) {
          var context, gapi;
          return regeneratorRuntime.wrap(function _callee184$(_context184) {
            while (1) {
              switch (_context184.prev = _context184.next) {
                case 0:
                  _context184.next = 2;
                  return _loadGapi(auth);

                case 2:
                  context = _context184.sent;
                  gapi = _window().gapi;

                  _assert(gapi, auth, "internal-error"
                  /* INTERNAL_ERROR */
                  );

                  return _context184.abrupt("return", context.open({
                    where: document.body,
                    url: getIframeUrl(auth),
                    messageHandlersFilter: gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
                    attributes: IFRAME_ATTRIBUTES,
                    dontclear: true
                  }, function (iframe) {
                    return new Promise( /*#__PURE__*/function () {
                      var _ref39 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee183(resolve, reject) {
                        var networkError, networkErrorTimer, clearTimerAndResolve;
                        return regeneratorRuntime.wrap(function _callee183$(_context183) {
                          while (1) {
                            switch (_context183.prev = _context183.next) {
                              case 0:
                                clearTimerAndResolve = function _clearTimerAndResolve() {
                                  _window().clearTimeout(networkErrorTimer);

                                  resolve(iframe);
                                };

                                _context183.next = 3;
                                return iframe.restyle({
                                  // Prevent iframe from closing on mouse out.
                                  setHideOnLeave: false
                                });

                              case 3:
                                networkError = _createError(auth, "network-request-failed"
                                /* NETWORK_REQUEST_FAILED */
                                ); // Confirm iframe is correctly loaded.
                                // To fallback on failure, set a timeout.

                                // Confirm iframe is correctly loaded.
                                // To fallback on failure, set a timeout.
                                networkErrorTimer = _window().setTimeout(function () {
                                  reject(networkError);
                                }, PING_TIMEOUT.get()); // Clear timer and resolve pending iframe ready promise.

                                // This returns an IThenable. However the reject part does not call
                                // when the iframe is not loaded.
                                iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve, function () {
                                  reject(networkError);
                                });

                              case 6:
                              case "end":
                                return _context183.stop();
                            }
                          }
                        }, _callee183);
                      }));

                      return function (_x272, _x273) {
                        return _ref39.apply(this, arguments);
                      };
                    }());
                  }));

                case 6:
                case "end":
                  return _context184.stop();
              }
            }
          }, _callee184);
        }));
        return _openIframe2.apply(this, arguments);
      }

      var BASE_POPUP_OPTIONS = {
        location: 'yes',
        resizable: 'yes',
        statusbar: 'yes',
        toolbar: 'no'
      };
      var DEFAULT_WIDTH = 500;
      var DEFAULT_HEIGHT = 600;
      var TARGET_BLANK = '_blank';
      var FIREFOX_EMPTY_URL = 'http://localhost';

      var AuthPopup = /*#__PURE__*/function () {
        function AuthPopup(window) {
          _classCallCheck(this, AuthPopup);

          this.window = window;
          this.associatedEvent = null;
        }

        _createClass(AuthPopup, [{
          key: "close",
          value: function close() {
            if (this.window) {
              try {
                this.window.close();
              } catch (e) {}
            }
          }
        }]);

        return AuthPopup;
      }();

      function _open(auth, url, name) {
        var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_WIDTH;
        var height = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_HEIGHT;
        var top = Math.max((window.screen.availHeight - height) / 2, 0).toString();
        var left = Math.max((window.screen.availWidth - width) / 2, 0).toString();
        var target = '';
        var options = Object.assign(Object.assign({}, BASE_POPUP_OPTIONS), {
          width: width.toString(),
          height: height.toString(),
          top: top,
          left: left
        }); // Chrome iOS 7 and 8 is returning an undefined popup win when target is
        // specified, even though the popup is not necessarily blocked.

        var ua = (0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.getUA)().toLowerCase();

        if (name) {
          target = _isChromeIOS(ua) ? TARGET_BLANK : name;
        }

        if (_isFirefox(ua)) {
          // Firefox complains when invalid URLs are popped out. Hacky way to bypass.
          url = url || FIREFOX_EMPTY_URL; // Firefox disables by default scrolling on popup windows, which can create
          // issues when the user has many Google accounts, for instance.

          options.scrollbars = 'yes';
        }

        var optionsString = Object.entries(options).reduce(function (accum, _ref34) {
          var _ref35 = _slicedToArray(_ref34, 2),
              key = _ref35[0],
              value = _ref35[1];

          return "".concat(accum).concat(key, "=").concat(value, ",");
        }, '');

        if (_isIOSStandalone(ua) && target !== '_self') {
          openAsNewWindowIOS(url || '', target);
          return new AuthPopup(null);
        } // about:blank getting sanitized causing browsers like IE/Edge to display
        // brief error message before redirecting to handler.


        var newWin = window.open(url || '', target, optionsString);

        _assert(newWin, auth, "popup-blocked"
        /* POPUP_BLOCKED */
        ); // Flaky on IE edge, encapsulate with a try and catch.


        try {
          newWin.focus();
        } catch (e) {}

        return new AuthPopup(newWin);
      }

      function openAsNewWindowIOS(url, target) {
        var el = document.createElement('a');
        el.href = url;
        el.target = target;
        var click = document.createEvent('MouseEvent');
        click.initMouseEvent('click', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null);
        el.dispatchEvent(click);
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * URL for Authentication widget which will initiate the OAuth handshake
       *
       * @internal
       */


      var WIDGET_PATH = '__/auth/handler';
      /**
       * URL for emulated environment
       *
       * @internal
       */

      var EMULATOR_WIDGET_PATH = 'emulator/auth/handler';

      function _getRedirectUrl(auth, provider, authType, redirectUrl, eventId, additionalParams) {
        _assert(auth.config.authDomain, auth, "auth-domain-config-required"
        /* MISSING_AUTH_DOMAIN */
        );

        _assert(auth.config.apiKey, auth, "invalid-api-key"
        /* INVALID_API_KEY */
        );

        var params = {
          apiKey: auth.config.apiKey,
          appName: auth.name,
          authType: authType,
          redirectUrl: redirectUrl,
          v: _firebase_app__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION,
          eventId: eventId
        };

        if (provider instanceof FederatedAuthProvider) {
          provider.setDefaultLanguage(auth.languageCode);
          params.providerId = provider.providerId || '';

          if (!(0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(provider.getCustomParameters())) {
            params.customParameters = JSON.stringify(provider.getCustomParameters());
          } // TODO set additionalParams from the provider as well?


          for (var _i7 = 0, _Object$entries = Object.entries(additionalParams || {}); _i7 < _Object$entries.length; _i7++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i7], 2),
                key = _Object$entries$_i[0],
                value = _Object$entries$_i[1];

            params[key] = value;
          }
        }

        if (provider instanceof BaseOAuthProvider) {
          var scopes = provider.getScopes().filter(function (scope) {
            return scope !== '';
          });

          if (scopes.length > 0) {
            params.scopes = scopes.join(',');
          }
        }

        if (auth.tenantId) {
          params.tid = auth.tenantId;
        } // TODO: maybe set eid as endipointId
        // TODO: maybe set fw as Frameworks.join(",")


        var paramsDict = params;

        for (var _i8 = 0, _Object$keys4 = Object.keys(paramsDict); _i8 < _Object$keys4.length; _i8++) {
          var _key7 = _Object$keys4[_i8];

          if (paramsDict[_key7] === undefined) {
            delete paramsDict[_key7];
          }
        }

        return "".concat(getHandlerBase(auth), "?").concat((0, _firebase_util__WEBPACK_IMPORTED_MODULE_0__.querystring)(paramsDict).slice(1));
      }

      function getHandlerBase(_ref36) {
        var config = _ref36.config;

        if (!config.emulator) {
          return "https://".concat(config.authDomain, "/").concat(WIDGET_PATH);
        }

        return _emulatorUrl(config, EMULATOR_WIDGET_PATH);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * The special web storage event
       *
       */


      var WEB_STORAGE_SUPPORT_KEY = 'webStorageSupport';

      var BrowserPopupRedirectResolver = /*#__PURE__*/function () {
        function BrowserPopupRedirectResolver() {
          _classCallCheck(this, BrowserPopupRedirectResolver);

          this.eventManagers = {};
          this.iframes = {};
          this.originValidationPromises = {};
          this._redirectPersistence = browserSessionPersistence;
          this._completeRedirectFn = _getRedirectResult;
        } // Wrapping in async even though we don't await anywhere in order
        // to make sure errors are raised as promise rejections


        _createClass(BrowserPopupRedirectResolver, [{
          key: "_openPopup",
          value: function () {
            var _openPopup3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee101(auth, provider, authType, eventId) {
              var _a, url;

              return regeneratorRuntime.wrap(function _callee101$(_context101) {
                while (1) {
                  switch (_context101.prev = _context101.next) {
                    case 0:
                      debugAssert((_a = this.eventManagers[auth._key()]) === null || _a === void 0 ? void 0 : _a.manager, '_initialize() not called before _openPopup()');
                      url = _getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId);
                      return _context101.abrupt("return", _open(auth, url, _generateEventId()));

                    case 3:
                    case "end":
                      return _context101.stop();
                  }
                }
              }, _callee101, this);
            }));

            function _openPopup(_x262, _x263, _x264, _x265) {
              return _openPopup3.apply(this, arguments);
            }

            return _openPopup;
          }()
        }, {
          key: "_openRedirect",
          value: function () {
            var _openRedirect3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee102(auth, provider, authType, eventId) {
              return regeneratorRuntime.wrap(function _callee102$(_context102) {
                while (1) {
                  switch (_context102.prev = _context102.next) {
                    case 0:
                      _context102.next = 2;
                      return this._originValidation(auth);

                    case 2:
                      _setWindowLocation(_getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId));

                      return _context102.abrupt("return", new Promise(function () {}));

                    case 4:
                    case "end":
                      return _context102.stop();
                  }
                }
              }, _callee102, this);
            }));

            function _openRedirect(_x266, _x267, _x268, _x269) {
              return _openRedirect3.apply(this, arguments);
            }

            return _openRedirect;
          }()
        }, {
          key: "_initialize",
          value: function _initialize(auth) {
            var key = auth._key();

            if (this.eventManagers[key]) {
              var _this$eventManagers$k = this.eventManagers[key],
                  manager = _this$eventManagers$k.manager,
                  _promise = _this$eventManagers$k.promise;

              if (manager) {
                return Promise.resolve(manager);
              } else {
                debugAssert(_promise, 'If manager is not set, promise should be');
                return _promise;
              }
            }

            var promise = this.initAndGetManager(auth);
            this.eventManagers[key] = {
              promise: promise
            };
            return promise;
          }
        }, {
          key: "initAndGetManager",
          value: function () {
            var _initAndGetManager = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee103(auth) {
              var iframe, manager;
              return regeneratorRuntime.wrap(function _callee103$(_context103) {
                while (1) {
                  switch (_context103.prev = _context103.next) {
                    case 0:
                      _context103.next = 2;
                      return _openIframe(auth);

                    case 2:
                      iframe = _context103.sent;
                      manager = new AuthEventManager(auth);
                      iframe.register('authEvent', function (iframeEvent) {
                        _assert(iframeEvent === null || iframeEvent === void 0 ? void 0 : iframeEvent.authEvent, auth, "invalid-auth-event"
                        /* INVALID_AUTH_EVENT */
                        ); // TODO: Consider splitting redirect and popup events earlier on


                        var handled = manager.onEvent(iframeEvent.authEvent);
                        return {
                          status: handled ? "ACK"
                          /* ACK */
                          : "ERROR"
                          /* ERROR */

                        };
                      }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
                      this.eventManagers[auth._key()] = {
                        manager: manager
                      };
                      this.iframes[auth._key()] = iframe;
                      return _context103.abrupt("return", manager);

                    case 8:
                    case "end":
                      return _context103.stop();
                  }
                }
              }, _callee103, this);
            }));

            function initAndGetManager(_x270) {
              return _initAndGetManager.apply(this, arguments);
            }

            return initAndGetManager;
          }()
        }, {
          key: "_isIframeWebStorageSupported",
          value: function _isIframeWebStorageSupported(auth, cb) {
            var iframe = this.iframes[auth._key()];

            iframe.send(WEB_STORAGE_SUPPORT_KEY, {
              type: WEB_STORAGE_SUPPORT_KEY
            }, function (result) {
              var _a;

              var isSupported = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a[WEB_STORAGE_SUPPORT_KEY];

              if (isSupported !== undefined) {
                cb(!!isSupported);
              }

              _fail(auth, "internal-error"
              /* INTERNAL_ERROR */
              );
            }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
          }
        }, {
          key: "_originValidation",
          value: function _originValidation(auth) {
            var key = auth._key();

            if (!this.originValidationPromises[key]) {
              this.originValidationPromises[key] = _validateOrigin(auth);
            }

            return this.originValidationPromises[key];
          }
        }, {
          key: "_shouldInitProactively",
          get: function get() {
            // Mobile browsers and Safari need to optimistically initialize
            return _isMobileBrowser() || _isSafari() || _isIOS();
          }
        }]);

        return BrowserPopupRedirectResolver;
      }();
      /**
       * An implementation of {@link PopupRedirectResolver} suitable for browser
       * based applications.
       *
       * @public
       */


      var browserPopupRedirectResolver = BrowserPopupRedirectResolver;

      var MultiFactorAssertionImpl = /*#__PURE__*/function () {
        function MultiFactorAssertionImpl(factorId) {
          _classCallCheck(this, MultiFactorAssertionImpl);

          this.factorId = factorId;
        }

        _createClass(MultiFactorAssertionImpl, [{
          key: "_process",
          value: function _process(auth, session, displayName) {
            switch (session.type) {
              case "enroll"
              /* ENROLL */
              :
                return this._finalizeEnroll(auth, session.credential, displayName);

              case "signin"
              /* SIGN_IN */
              :
                return this._finalizeSignIn(auth, session.credential);

              default:
                return debugFail('unexpected MultiFactorSessionType');
            }
          }
        }]);

        return MultiFactorAssertionImpl;
      }();
      /**
       * {@inheritdoc PhoneMultiFactorAssertion}
       *
       * @public
       */


      var PhoneMultiFactorAssertionImpl = /*#__PURE__*/function (_MultiFactorAssertion) {
        _inherits(PhoneMultiFactorAssertionImpl, _MultiFactorAssertion);

        var _super24 = _createSuper(PhoneMultiFactorAssertionImpl);

        function PhoneMultiFactorAssertionImpl(credential) {
          var _this43;

          _classCallCheck(this, PhoneMultiFactorAssertionImpl);

          _this43 = _super24.call(this, "phone"
          /* PHONE */
          );
          _this43.credential = credential;
          return _this43;
        }
        /** @internal */


        _createClass(PhoneMultiFactorAssertionImpl, [{
          key: "_finalizeEnroll",
          value:
          /** @internal */
          function _finalizeEnroll(auth, idToken, displayName) {
            return finalizeEnrollPhoneMfa(auth, {
              idToken: idToken,
              displayName: displayName,
              phoneVerificationInfo: this.credential._makeVerificationRequest()
            });
          }
          /** @internal */

        }, {
          key: "_finalizeSignIn",
          value: function _finalizeSignIn(auth, mfaPendingCredential) {
            return finalizeSignInPhoneMfa(auth, {
              mfaPendingCredential: mfaPendingCredential,
              phoneVerificationInfo: this.credential._makeVerificationRequest()
            });
          }
        }], [{
          key: "_fromCredential",
          value: function _fromCredential(credential) {
            return new PhoneMultiFactorAssertionImpl(credential);
          }
        }]);

        return PhoneMultiFactorAssertionImpl;
      }(MultiFactorAssertionImpl);
      /**
       * Provider for generating a {@link PhoneMultiFactorAssertion}.
       *
       * @public
       */


      var PhoneMultiFactorGenerator = /*#__PURE__*/function () {
        function PhoneMultiFactorGenerator() {
          _classCallCheck(this, PhoneMultiFactorGenerator);
        }
        /**
         * Provides a {@link PhoneMultiFactorAssertion} to confirm ownership of the phone second factor.
         *
         * @param phoneAuthCredential - A credential provided by {@link PhoneAuthProvider.credential}.
         * @returns A {@link PhoneMultiFactorAssertion} which can be used with
         * {@link MultiFactorResolver.resolveSignIn}
         */


        _createClass(PhoneMultiFactorGenerator, null, [{
          key: "assertion",
          value: function assertion(credential) {
            return PhoneMultiFactorAssertionImpl._fromCredential(credential);
          }
        }]);

        return PhoneMultiFactorGenerator;
      }();
      /**
       * The identifier of the phone second factor: `phone`.
       */


      PhoneMultiFactorGenerator.FACTOR_ID = 'phone';
      var name = "@firebase/auth";
      var version = "0.19.1";
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      var AuthInterop = /*#__PURE__*/function () {
        function AuthInterop(auth) {
          _classCallCheck(this, AuthInterop);

          this.auth = auth;
          this.internalListeners = new Map();
        }

        _createClass(AuthInterop, [{
          key: "getUid",
          value: function getUid() {
            var _a;

            this.assertAuthConfigured();
            return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;
          }
        }, {
          key: "getToken",
          value: function () {
            var _getToken2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee104(forceRefresh) {
              var accessToken;
              return regeneratorRuntime.wrap(function _callee104$(_context104) {
                while (1) {
                  switch (_context104.prev = _context104.next) {
                    case 0:
                      this.assertAuthConfigured();
                      _context104.next = 3;
                      return this.auth._initializationPromise;

                    case 3:
                      if (this.auth.currentUser) {
                        _context104.next = 5;
                        break;
                      }

                      return _context104.abrupt("return", null);

                    case 5:
                      _context104.next = 7;
                      return this.auth.currentUser.getIdToken(forceRefresh);

                    case 7:
                      accessToken = _context104.sent;
                      return _context104.abrupt("return", {
                        accessToken: accessToken
                      });

                    case 9:
                    case "end":
                      return _context104.stop();
                  }
                }
              }, _callee104, this);
            }));

            function getToken(_x271) {
              return _getToken2.apply(this, arguments);
            }

            return getToken;
          }()
        }, {
          key: "addAuthTokenListener",
          value: function addAuthTokenListener(listener) {
            this.assertAuthConfigured();

            if (this.internalListeners.has(listener)) {
              return;
            }

            var unsubscribe = this.auth.onIdTokenChanged(function (user) {
              var _a;

              listener(((_a = user) === null || _a === void 0 ? void 0 : _a.stsTokenManager.accessToken) || null);
            });
            this.internalListeners.set(listener, unsubscribe);
            this.updateProactiveRefresh();
          }
        }, {
          key: "removeAuthTokenListener",
          value: function removeAuthTokenListener(listener) {
            this.assertAuthConfigured();
            var unsubscribe = this.internalListeners.get(listener);

            if (!unsubscribe) {
              return;
            }

            this.internalListeners["delete"](listener);
            unsubscribe();
            this.updateProactiveRefresh();
          }
        }, {
          key: "assertAuthConfigured",
          value: function assertAuthConfigured() {
            _assert(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth"
            /* DEPENDENT_SDK_INIT_BEFORE_AUTH */
            );
          }
        }, {
          key: "updateProactiveRefresh",
          value: function updateProactiveRefresh() {
            if (this.internalListeners.size > 0) {
              this.auth._startProactiveRefresh();
            } else {
              this.auth._stopProactiveRefresh();
            }
          }
        }]);

        return AuthInterop;
      }();
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function getVersionForPlatform(clientPlatform) {
        switch (clientPlatform) {
          case "Node"
          /* NODE */
          :
            return 'node';

          case "ReactNative"
          /* REACT_NATIVE */
          :
            return 'rn';

          case "Worker"
          /* WORKER */
          :
            return 'webworker';

          case "Cordova"
          /* CORDOVA */
          :
            return 'cordova';

          default:
            return undefined;
        }
      }
      /** @internal */


      function registerAuth(clientPlatform) {
        (0, _firebase_app__WEBPACK_IMPORTED_MODULE_1__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_3__.Component("auth"
        /* AUTH */
        , function (container, _ref37) {
          var deps = _ref37.options;
          var app = container.getProvider('app').getImmediate();
          var _app$options = app.options,
              apiKey = _app$options.apiKey,
              authDomain = _app$options.authDomain;
          return function (app) {
            _assert(apiKey && !apiKey.includes(':'), "invalid-api-key"
            /* INVALID_API_KEY */
            , {
              appName: app.name
            }); // Auth domain is optional if IdP sign in isn't being used


            _assert(!(authDomain === null || authDomain === void 0 ? void 0 : authDomain.includes(':')), "argument-error"
            /* ARGUMENT_ERROR */
            , {
              appName: app.name
            });

            var config = {
              apiKey: apiKey,
              authDomain: authDomain,
              clientPlatform: clientPlatform,
              apiHost: "identitytoolkit.googleapis.com"
              /* API_HOST */
              ,
              tokenApiHost: "securetoken.googleapis.com"
              /* TOKEN_API_HOST */
              ,
              apiScheme: "https"
              /* API_SCHEME */
              ,
              sdkClientVersion: _getClientVersion(clientPlatform)
            };
            var authInstance = new AuthImpl(app, config);

            _initializeAuthInstance(authInstance, deps);

            return authInstance;
          }(app);
        }, "PUBLIC"
        /* PUBLIC */
        )
        /**
         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()
         * For why we do this, See go/firebase-next-auth-init
         */
        .setInstantiationMode("EXPLICIT"
        /* EXPLICIT */
        )
        /**
         * Because all firebase products that depend on auth depend on auth-internal directly,
         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.
         */
        .setInstanceCreatedCallback(function (container, _instanceIdentifier, _instance) {
          var authInternalProvider = container.getProvider("auth-internal"
          /* AUTH_INTERNAL */
          );
          authInternalProvider.initialize();
        }));
        (0, _firebase_app__WEBPACK_IMPORTED_MODULE_1__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_3__.Component("auth-internal"
        /* AUTH_INTERNAL */
        , function (container) {
          var auth = _castAuth(container.getProvider("auth"
          /* AUTH */
          ).getImmediate());

          return function (auth) {
            return new AuthInterop(auth);
          }(auth);
        }, "PRIVATE"
        /* PRIVATE */
        ).setInstantiationMode("EXPLICIT"
        /* EXPLICIT */
        ));
        (0, _firebase_app__WEBPACK_IMPORTED_MODULE_1__.registerVersion)(name, version, getVersionForPlatform(clientPlatform)); // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation

        (0, _firebase_app__WEBPACK_IMPORTED_MODULE_1__.registerVersion)(name, version, 'esm2017');
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * Returns the Auth instance associated with the provided {@link @firebase/app#FirebaseApp}.
       * If no instance exists, initializes an Auth instance with platform-specific default dependencies.
       *
       * @param app - The Firebase App.
       *
       * @public
       */


      function getAuth() {
        var app = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _firebase_app__WEBPACK_IMPORTED_MODULE_1__.getApp)();
        var provider = (0, _firebase_app__WEBPACK_IMPORTED_MODULE_1__._getProvider)(app, 'auth');

        if (provider.isInitialized()) {
          return provider.getImmediate();
        }

        return initializeAuth(app, {
          popupRedirectResolver: browserPopupRedirectResolver,
          persistence: [indexedDBLocalPersistence, browserLocalPersistence, browserSessionPersistence]
        });
      }

      registerAuth("Browser"
      /* BROWSER */
      ); //# sourceMappingURL=index-91e5512e.js.map

      /***/
    },

    /***/
    97904:
    /*!**************************************************************!*\
      !*** ./node_modules/@firebase/auth/dist/esm2017/internal.js ***!
      \**************************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "ActionCodeOperation": function ActionCodeOperation() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.A
          );
        },

        /* harmony export */
        "ActionCodeURL": function ActionCodeURL() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ac
          );
        },

        /* harmony export */
        "AuthCredential": function AuthCredential() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.G
          );
        },

        /* harmony export */
        "AuthErrorCodes": function AuthErrorCodes() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.C
          );
        },

        /* harmony export */
        "AuthImpl": function AuthImpl() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aE
          );
        },

        /* harmony export */
        "AuthPopup": function AuthPopup() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aH
          );
        },

        /* harmony export */
        "EmailAuthCredential": function EmailAuthCredential() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.H
          );
        },

        /* harmony export */
        "EmailAuthProvider": function EmailAuthProvider() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.L
          );
        },

        /* harmony export */
        "FacebookAuthProvider": function FacebookAuthProvider() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.M
          );
        },

        /* harmony export */
        "FactorId": function FactorId() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.F
          );
        },

        /* harmony export */
        "FetchProvider": function FetchProvider() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aI
          );
        },

        /* harmony export */
        "GithubAuthProvider": function GithubAuthProvider() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.Q
          );
        },

        /* harmony export */
        "GoogleAuthProvider": function GoogleAuthProvider() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.N
          );
        },

        /* harmony export */
        "OAuthCredential": function OAuthCredential() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.I
          );
        },

        /* harmony export */
        "OAuthProvider": function OAuthProvider() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.T
          );
        },

        /* harmony export */
        "OperationType": function OperationType() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.O
          );
        },

        /* harmony export */
        "PhoneAuthCredential": function PhoneAuthCredential() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.J
          );
        },

        /* harmony export */
        "PhoneAuthProvider": function PhoneAuthProvider() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.P
          );
        },

        /* harmony export */
        "PhoneMultiFactorGenerator": function PhoneMultiFactorGenerator() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.m
          );
        },

        /* harmony export */
        "ProviderId": function ProviderId() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.o
          );
        },

        /* harmony export */
        "RecaptchaVerifier": function RecaptchaVerifier() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.R
          );
        },

        /* harmony export */
        "SAMLAuthCredential": function SAMLAuthCredential() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aJ
          );
        },

        /* harmony export */
        "SAMLAuthProvider": function SAMLAuthProvider() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.U
          );
        },

        /* harmony export */
        "SignInMethod": function SignInMethod() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.S
          );
        },

        /* harmony export */
        "TwitterAuthProvider": function TwitterAuthProvider() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.V
          );
        },

        /* harmony export */
        "UserImpl": function UserImpl() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aD
          );
        },

        /* harmony export */
        "_assert": function _assert() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aw
          );
        },

        /* harmony export */
        "_castAuth": function _castAuth() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aC
          );
        },

        /* harmony export */
        "_fail": function _fail() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.as
          );
        },

        /* harmony export */
        "_generateEventId": function _generateEventId() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aG
          );
        },

        /* harmony export */
        "_getClientVersion": function _getClientVersion() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aF
          );
        },

        /* harmony export */
        "_getInstance": function _getInstance() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ax
          );
        },

        /* harmony export */
        "_getRedirectResult": function _getRedirectResult() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aA
          );
        },

        /* harmony export */
        "_persistenceKeyName": function _persistenceKeyName() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ay
          );
        },

        /* harmony export */
        "applyActionCode": function applyActionCode() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a1
          );
        },

        /* harmony export */
        "browserLocalPersistence": function browserLocalPersistence() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.b
          );
        },

        /* harmony export */
        "browserPopupRedirectResolver": function browserPopupRedirectResolver() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.k
          );
        },

        /* harmony export */
        "browserSessionPersistence": function browserSessionPersistence() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a
          );
        },

        /* harmony export */
        "checkActionCode": function checkActionCode() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a2
          );
        },

        /* harmony export */
        "confirmPasswordReset": function confirmPasswordReset() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a0
          );
        },

        /* harmony export */
        "connectAuthEmulator": function connectAuthEmulator() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.E
          );
        },

        /* harmony export */
        "createUserWithEmailAndPassword": function createUserWithEmailAndPassword() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a4
          );
        },

        /* harmony export */
        "debugErrorMap": function debugErrorMap() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.z
          );
        },

        /* harmony export */
        "deleteUser": function deleteUser() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.y
          );
        },

        /* harmony export */
        "fetchSignInMethodsForEmail": function fetchSignInMethodsForEmail() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a9
          );
        },

        /* harmony export */
        "getAdditionalUserInfo": function getAdditionalUserInfo() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ak
          );
        },

        /* harmony export */
        "getAuth": function getAuth() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.n
          );
        },

        /* harmony export */
        "getIdToken": function getIdToken() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ah
          );
        },

        /* harmony export */
        "getIdTokenResult": function getIdTokenResult() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ai
          );
        },

        /* harmony export */
        "getMultiFactorResolver": function getMultiFactorResolver() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.am
          );
        },

        /* harmony export */
        "getRedirectResult": function getRedirectResult() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.j
          );
        },

        /* harmony export */
        "inMemoryPersistence": function inMemoryPersistence() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.K
          );
        },

        /* harmony export */
        "indexedDBLocalPersistence": function indexedDBLocalPersistence() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.i
          );
        },

        /* harmony export */
        "initializeAuth": function initializeAuth() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.D
          );
        },

        /* harmony export */
        "isSignInWithEmailLink": function isSignInWithEmailLink() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a7
          );
        },

        /* harmony export */
        "linkWithCredential": function linkWithCredential() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.Y
          );
        },

        /* harmony export */
        "linkWithPhoneNumber": function linkWithPhoneNumber() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.l
          );
        },

        /* harmony export */
        "linkWithPopup": function linkWithPopup() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.d
          );
        },

        /* harmony export */
        "linkWithRedirect": function linkWithRedirect() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.g
          );
        },

        /* harmony export */
        "multiFactor": function multiFactor() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.an
          );
        },

        /* harmony export */
        "onAuthStateChanged": function onAuthStateChanged() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.t
          );
        },

        /* harmony export */
        "onIdTokenChanged": function onIdTokenChanged() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.q
          );
        },

        /* harmony export */
        "parseActionCodeURL": function parseActionCodeURL() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ad
          );
        },

        /* harmony export */
        "prodErrorMap": function prodErrorMap() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.B
          );
        },

        /* harmony export */
        "reauthenticateWithCredential": function reauthenticateWithCredential() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.Z
          );
        },

        /* harmony export */
        "reauthenticateWithPhoneNumber": function reauthenticateWithPhoneNumber() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.r
          );
        },

        /* harmony export */
        "reauthenticateWithPopup": function reauthenticateWithPopup() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.e
          );
        },

        /* harmony export */
        "reauthenticateWithRedirect": function reauthenticateWithRedirect() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.h
          );
        },

        /* harmony export */
        "reload": function reload() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.al
          );
        },

        /* harmony export */
        "sendEmailVerification": function sendEmailVerification() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aa
          );
        },

        /* harmony export */
        "sendPasswordResetEmail": function sendPasswordResetEmail() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.$
          );
        },

        /* harmony export */
        "sendSignInLinkToEmail": function sendSignInLinkToEmail() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a6
          );
        },

        /* harmony export */
        "setPersistence": function setPersistence() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.p
          );
        },

        /* harmony export */
        "signInAnonymously": function signInAnonymously() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.W
          );
        },

        /* harmony export */
        "signInWithCredential": function signInWithCredential() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.X
          );
        },

        /* harmony export */
        "signInWithCustomToken": function signInWithCustomToken() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__._
          );
        },

        /* harmony export */
        "signInWithEmailAndPassword": function signInWithEmailAndPassword() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a5
          );
        },

        /* harmony export */
        "signInWithEmailLink": function signInWithEmailLink() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a8
          );
        },

        /* harmony export */
        "signInWithPhoneNumber": function signInWithPhoneNumber() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.s
          );
        },

        /* harmony export */
        "signInWithPopup": function signInWithPopup() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.c
          );
        },

        /* harmony export */
        "signInWithRedirect": function signInWithRedirect() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.f
          );
        },

        /* harmony export */
        "signOut": function signOut() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.x
          );
        },

        /* harmony export */
        "unlink": function unlink() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aj
          );
        },

        /* harmony export */
        "updateCurrentUser": function updateCurrentUser() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.w
          );
        },

        /* harmony export */
        "updateEmail": function updateEmail() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.af
          );
        },

        /* harmony export */
        "updatePassword": function updatePassword() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ag
          );
        },

        /* harmony export */
        "updatePhoneNumber": function updatePhoneNumber() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.u
          );
        },

        /* harmony export */
        "updateProfile": function updateProfile() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ae
          );
        },

        /* harmony export */
        "useDeviceLanguage": function useDeviceLanguage() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.v
          );
        },

        /* harmony export */
        "verifyBeforeUpdateEmail": function verifyBeforeUpdateEmail() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ab
          );
        },

        /* harmony export */
        "verifyPasswordResetCode": function verifyPasswordResetCode() {
          return (
            /* reexport safe */
            _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a3
          );
        },

        /* harmony export */
        "addFrameworkForLogging": function addFrameworkForLogging() {
          return (
            /* binding */
            _addFrameworkForLogging
          );
        },

        /* harmony export */
        "cordovaPopupRedirectResolver": function cordovaPopupRedirectResolver() {
          return (
            /* binding */
            _cordovaPopupRedirectResolver
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./index-91e5512e.js */
      26269);
      /* harmony import */


      var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @firebase/util */
      29870);
      /* harmony import */


      var _firebase_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @firebase/app */
      95871);
      /* harmony import */


      var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @firebase/logger */
      24560);
      /* harmony import */


      var _firebase_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @firebase/component */
      29171);
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      function _cordovaWindow() {
        return window;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * How long to wait after the app comes back into focus before concluding that
       * the user closed the sign in tab.
       */


      var REDIRECT_TIMEOUT_MS = 2000;
      /**
       * Generates the URL for the OAuth handler.
       */

      function _generateHandlerUrl(_x274, _x275, _x276) {
        return _generateHandlerUrl2.apply(this, arguments);
      }
      /**
       * Validates that this app is valid for this project configuration
       */


      function _generateHandlerUrl2() {
        _generateHandlerUrl2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee191(auth, event, provider) {
          var _a, _cordovaWindow4, BuildInfo, sessionDigest, additionalParams;

          return regeneratorRuntime.wrap(function _callee191$(_context191) {
            while (1) {
              switch (_context191.prev = _context191.next) {
                case 0:
                  // Get the cordova plugins
                  _cordovaWindow4 = _cordovaWindow(), BuildInfo = _cordovaWindow4.BuildInfo;
                  (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ap)(event.sessionId, 'AuthEvent did not contain a session ID');
                  _context191.next = 4;
                  return computeSha256(event.sessionId);

                case 4:
                  sessionDigest = _context191.sent;
                  additionalParams = {};

                  if ((0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aq)()) {
                    // iOS app identifier
                    additionalParams['ibi'] = BuildInfo.packageName;
                  } else if ((0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ar)()) {
                    // Android app identifier
                    additionalParams['apn'] = BuildInfo.packageName;
                  } else {
                    (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.as)(auth, "operation-not-supported-in-this-environment"
                    /* OPERATION_NOT_SUPPORTED */
                    );
                  } // Add the display name if available


                  if (BuildInfo.displayName) {
                    additionalParams['appDisplayName'] = BuildInfo.displayName;
                  } // Attached the hashed session ID


                  additionalParams['sessionId'] = sessionDigest;
                  return _context191.abrupt("return", (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.at)(auth, provider, event.type, undefined, (_a = event.eventId) !== null && _a !== void 0 ? _a : undefined, additionalParams));

                case 10:
                case "end":
                  return _context191.stop();
              }
            }
          }, _callee191);
        }));
        return _generateHandlerUrl2.apply(this, arguments);
      }

      function _validateOrigin(_x277) {
        return _validateOrigin3.apply(this, arguments);
      }

      function _validateOrigin3() {
        _validateOrigin3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee192(auth) {
          var _cordovaWindow5, BuildInfo, request;

          return regeneratorRuntime.wrap(function _callee192$(_context192) {
            while (1) {
              switch (_context192.prev = _context192.next) {
                case 0:
                  _cordovaWindow5 = _cordovaWindow(), BuildInfo = _cordovaWindow5.BuildInfo;
                  request = {};

                  if ((0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aq)()) {
                    request.iosBundleId = BuildInfo.packageName;
                  } else if ((0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ar)()) {
                    request.androidPackageName = BuildInfo.packageName;
                  } else {
                    (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.as)(auth, "operation-not-supported-in-this-environment"
                    /* OPERATION_NOT_SUPPORTED */
                    );
                  } // Will fail automatically if package name is not authorized


                  _context192.next = 5;
                  return (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.au)(auth, request);

                case 5:
                case "end":
                  return _context192.stop();
              }
            }
          }, _callee192);
        }));
        return _validateOrigin3.apply(this, arguments);
      }

      function _performRedirect(handlerUrl) {
        // Get the cordova plugins
        var _cordovaWindow2 = _cordovaWindow(),
            cordova = _cordovaWindow2.cordova;

        return new Promise(function (resolve) {
          cordova.plugins.browsertab.isAvailable(function (browserTabIsAvailable) {
            var iabRef = null;

            if (browserTabIsAvailable) {
              cordova.plugins.browsertab.openUrl(handlerUrl);
            } else {
              // TODO: Return the inappbrowser ref that's returned from the open call
              iabRef = cordova.InAppBrowser.open(handlerUrl, (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ao)() ? '_blank' : '_system', 'location=yes');
            }

            resolve(iabRef);
          });
        });
      }
      /**
       * This function waits for app activity to be seen before resolving. It does
       * this by attaching listeners to various dom events. Once the app is determined
       * to be visible, this promise resolves. AFTER that resolution, the listeners
       * are detached and any browser tabs left open will be closed.
       */


      function _waitForAppResume(_x278, _x279, _x280) {
        return _waitForAppResume2.apply(this, arguments);
      }
      /**
       * Checks the configuration of the Cordova environment. This has no side effect
       * if the configuration is correct; otherwise it throws an error with the
       * missing plugin.
       */


      function _waitForAppResume2() {
        _waitForAppResume2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee193(auth, eventListener, iabRef) {
          var _cordovaWindow6, cordova, cleanup;

          return regeneratorRuntime.wrap(function _callee193$(_context193) {
            while (1) {
              switch (_context193.prev = _context193.next) {
                case 0:
                  // Get the cordova plugins
                  _cordovaWindow6 = _cordovaWindow(), cordova = _cordovaWindow6.cordova;

                  cleanup = function cleanup() {};

                  _context193.prev = 2;
                  _context193.next = 5;
                  return new Promise(function (resolve, reject) {
                    var onCloseTimer = null; // DEFINE ALL THE CALLBACKS =====

                    // DEFINE ALL THE CALLBACKS =====
                    function authEventSeen() {
                      var _a; // Auth event was detected. Resolve this promise and close the extra
                      // window if it's still open.


                      // Auth event was detected. Resolve this promise and close the extra
                      // window if it's still open.
                      resolve();
                      var closeBrowserTab = (_a = cordova.plugins.browsertab) === null || _a === void 0 ? void 0 : _a.close;

                      if (typeof closeBrowserTab === 'function') {
                        closeBrowserTab();
                      } // Close inappbrowser emebedded webview in iOS7 and 8 case if still
                      // open.


                      // Close inappbrowser emebedded webview in iOS7 and 8 case if still
                      // open.
                      if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === 'function') {
                        iabRef.close();
                      }
                    }

                    function resumed() {
                      if (onCloseTimer) {
                        // This code already ran; do not rerun.
                        return;
                      }

                      onCloseTimer = window.setTimeout(function () {
                        // Wait two seeconds after resume then reject.
                        reject((0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.av)(auth, "redirect-cancelled-by-user"
                        /* REDIRECT_CANCELLED_BY_USER */
                        ));
                      }, REDIRECT_TIMEOUT_MS);
                    }

                    function visibilityChanged() {
                      if ((document === null || document === void 0 ? void 0 : document.visibilityState) === 'visible') {
                        resumed();
                      }
                    } // ATTACH ALL THE LISTENERS =====
                    // Listen for the auth event


                    // ATTACH ALL THE LISTENERS =====
                    // Listen for the auth event
                    eventListener.addPassiveListener(authEventSeen); // Listen for resume and visibility events

                    // Listen for resume and visibility events
                    document.addEventListener('resume', resumed, false);

                    if ((0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ar)()) {
                      document.addEventListener('visibilitychange', visibilityChanged, false);
                    } // SETUP THE CLEANUP FUNCTION =====


                    // SETUP THE CLEANUP FUNCTION =====
                    cleanup = function cleanup() {
                      eventListener.removePassiveListener(authEventSeen);
                      document.removeEventListener('resume', resumed, false);
                      document.removeEventListener('visibilitychange', visibilityChanged, false);

                      if (onCloseTimer) {
                        window.clearTimeout(onCloseTimer);
                      }
                    };
                  });

                case 5:
                  _context193.prev = 5;
                  cleanup();
                  return _context193.finish(5);

                case 8:
                case "end":
                  return _context193.stop();
              }
            }
          }, _callee193, null, [[2,, 5, 8]]);
        }));
        return _waitForAppResume2.apply(this, arguments);
      }

      function _checkCordovaConfiguration(auth) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;

        var win = _cordovaWindow(); // Check all dependencies installed.
        // https://github.com/nordnet/cordova-universal-links-plugin
        // Note that cordova-universal-links-plugin has been abandoned.
        // A fork with latest fixes is available at:
        // https://www.npmjs.com/package/cordova-universal-links-plugin-fix


        (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_a = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a === void 0 ? void 0 : _a.subscribe) === 'function', auth, "invalid-cordova-configuration"
        /* INVALID_CORDOVA_CONFIGURATION */
        , {
          missingPlugin: 'cordova-universal-links-plugin-fix'
        }); // https://www.npmjs.com/package/cordova-plugin-buildinfo

        (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== 'undefined', auth, "invalid-cordova-configuration"
        /* INVALID_CORDOVA_CONFIGURATION */
        , {
          missingPlugin: 'cordova-plugin-buildInfo'
        }); // https://github.com/google/cordova-plugin-browsertab

        (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_e = (_d = (_c = win === null || win === void 0 ? void 0 : win.cordova) === null || _c === void 0 ? void 0 : _c.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e === void 0 ? void 0 : _e.openUrl) === 'function', auth, "invalid-cordova-configuration"
        /* INVALID_CORDOVA_CONFIGURATION */
        , {
          missingPlugin: 'cordova-plugin-browsertab'
        });
        (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_h = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h === void 0 ? void 0 : _h.isAvailable) === 'function', auth, "invalid-cordova-configuration"
        /* INVALID_CORDOVA_CONFIGURATION */
        , {
          missingPlugin: 'cordova-plugin-browsertab'
        }); // https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/

        (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === 'function', auth, "invalid-cordova-configuration"
        /* INVALID_CORDOVA_CONFIGURATION */
        , {
          missingPlugin: 'cordova-plugin-inappbrowser'
        });
      }
      /**
       * Computes the SHA-256 of a session ID. The SubtleCrypto interface is only
       * available in "secure" contexts, which covers Cordova (which is served on a file
       * protocol).
       */


      function computeSha256(_x281) {
        return _computeSha.apply(this, arguments);
      }

      function _computeSha() {
        _computeSha = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee194(sessionId) {
          var bytes, buf, arr;
          return regeneratorRuntime.wrap(function _callee194$(_context194) {
            while (1) {
              switch (_context194.prev = _context194.next) {
                case 0:
                  bytes = stringToArrayBuffer(sessionId); // TODO: For IE11 crypto has a different name and this operation comes back
                  //       as an object, not a promise. This is the old proposed standard that
                  //       is used by IE11:
                  // https://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/#cryptooperation-interface

                  _context194.next = 3;
                  return crypto.subtle.digest('SHA-256', bytes);

                case 3:
                  buf = _context194.sent;
                  arr = Array.from(new Uint8Array(buf));
                  return _context194.abrupt("return", arr.map(function (num) {
                    return num.toString(16).padStart(2, '0');
                  }).join(''));

                case 6:
                case "end":
                  return _context194.stop();
              }
            }
          }, _callee194);
        }));
        return _computeSha.apply(this, arguments);
      }

      function stringToArrayBuffer(str) {
        // This function is only meant to deal with an ASCII charset and makes
        // certain simplifying assumptions.
        (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ap)(/[0-9a-zA-Z]+/.test(str), 'Can only convert alpha-numeric strings');

        if (typeof TextEncoder !== 'undefined') {
          return new TextEncoder().encode(str);
        }

        var buff = new ArrayBuffer(str.length);
        var view = new Uint8Array(buff);

        for (var i = 0; i < str.length; i++) {
          view[i] = str.charCodeAt(i);
        }

        return view;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */


      var SESSION_ID_LENGTH = 20;
      /** Custom AuthEventManager that adds passive listeners to events */

      var CordovaAuthEventManager = /*#__PURE__*/function (_index_91e5512e_js__W) {
        _inherits(CordovaAuthEventManager, _index_91e5512e_js__W);

        var _super25 = _createSuper(CordovaAuthEventManager);

        function CordovaAuthEventManager() {
          var _this44;

          _classCallCheck(this, CordovaAuthEventManager);

          _this44 = _super25.apply(this, arguments);
          _this44.passiveListeners = new Set();
          _this44.initPromise = new Promise(function (resolve) {
            _this44.resolveInialized = resolve;
          });
          return _this44;
        }

        _createClass(CordovaAuthEventManager, [{
          key: "addPassiveListener",
          value: function addPassiveListener(cb) {
            this.passiveListeners.add(cb);
          }
        }, {
          key: "removePassiveListener",
          value: function removePassiveListener(cb) {
            this.passiveListeners["delete"](cb);
          } // In a Cordova environment, this manager can live through multiple redirect
          // operations

        }, {
          key: "resetRedirect",
          value: function resetRedirect() {
            this.queuedRedirectEvent = null;
            this.hasHandledPotentialRedirect = false;
          }
          /** Override the onEvent method */

        }, {
          key: "onEvent",
          value: function onEvent(event) {
            this.resolveInialized();
            this.passiveListeners.forEach(function (cb) {
              return cb(event);
            });
            return _get3(_getPrototypeOf(CordovaAuthEventManager.prototype), "onEvent", this).call(this, event);
          }
        }, {
          key: "initialized",
          value: function () {
            var _initialized = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee185() {
              return regeneratorRuntime.wrap(function _callee185$(_context185) {
                while (1) {
                  switch (_context185.prev = _context185.next) {
                    case 0:
                      _context185.next = 2;
                      return this.initPromise;

                    case 2:
                    case "end":
                      return _context185.stop();
                  }
                }
              }, _callee185, this);
            }));

            function initialized() {
              return _initialized.apply(this, arguments);
            }

            return initialized;
          }()
        }]);

        return CordovaAuthEventManager;
      }(_index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.az);
      /**
       * Generates a (partial) {@link AuthEvent}.
       */


      function _generateNewEvent(auth, type) {
        var eventId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        return {
          type: type,
          eventId: eventId,
          urlResponse: null,
          sessionId: generateSessionId(),
          postBody: null,
          tenantId: auth.tenantId,
          error: (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.av)(auth, "no-auth-event"
          /* NO_AUTH_EVENT */
          )
        };
      }

      function _savePartialEvent(auth, event) {
        return storage()._set(persistenceKey(auth), event);
      }

      function _getAndRemoveEvent(_x282) {
        return _getAndRemoveEvent2.apply(this, arguments);
      }

      function _getAndRemoveEvent2() {
        _getAndRemoveEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee195(auth) {
          var event;
          return regeneratorRuntime.wrap(function _callee195$(_context195) {
            while (1) {
              switch (_context195.prev = _context195.next) {
                case 0:
                  _context195.next = 2;
                  return storage()._get(persistenceKey(auth));

                case 2:
                  event = _context195.sent;

                  if (!event) {
                    _context195.next = 6;
                    break;
                  }

                  _context195.next = 6;
                  return storage()._remove(persistenceKey(auth));

                case 6:
                  return _context195.abrupt("return", event);

                case 7:
                case "end":
                  return _context195.stop();
              }
            }
          }, _callee195);
        }));
        return _getAndRemoveEvent2.apply(this, arguments);
      }

      function _eventFromPartialAndUrl(partialEvent, url) {
        var _a, _b; // Parse the deep link within the dynamic link URL.


        var callbackUrl = _getDeepLinkFromCallback(url); // Confirm it is actually a callback URL.
        // Currently the universal link will be of this format:
        // https://<AUTH_DOMAIN>/__/auth/callback<OAUTH_RESPONSE>
        // This is a fake URL but is not intended to take the user anywhere
        // and just redirect to the app.


        if (callbackUrl.includes('/__/auth/callback')) {
          // Check if there is an error in the URL.
          // This mechanism is also used to pass errors back to the app:
          // https://<AUTH_DOMAIN>/__/auth/callback?firebaseError=<STRINGIFIED_ERROR>
          var params = searchParamsOrEmpty(callbackUrl); // Get the error object corresponding to the stringified error if found.

          var errorObject = params['firebaseError'] ? parseJsonOrNull(decodeURIComponent(params['firebaseError'])) : null;
          var code = (_b = (_a = errorObject === null || errorObject === void 0 ? void 0 : errorObject['code']) === null || _a === void 0 ? void 0 : _a.split('auth/')) === null || _b === void 0 ? void 0 : _b[1];
          var error = code ? (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.av)(code) : null;

          if (error) {
            return {
              type: partialEvent.type,
              eventId: partialEvent.eventId,
              tenantId: partialEvent.tenantId,
              error: error,
              urlResponse: null,
              sessionId: null,
              postBody: null
            };
          } else {
            return {
              type: partialEvent.type,
              eventId: partialEvent.eventId,
              tenantId: partialEvent.tenantId,
              sessionId: partialEvent.sessionId,
              urlResponse: callbackUrl,
              postBody: null
            };
          }
        }

        return null;
      }

      function generateSessionId() {
        var chars = [];
        var allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

        for (var i = 0; i < SESSION_ID_LENGTH; i++) {
          var idx = Math.floor(Math.random() * allowedChars.length);
          chars.push(allowedChars.charAt(idx));
        }

        return chars.join('');
      }

      function storage() {
        return (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ax)(_index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.b);
      }

      function persistenceKey(auth) {
        return (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.ay)("authEvent"
        /* AUTH_EVENT */
        , auth.config.apiKey, auth.name);
      }

      function parseJsonOrNull(json) {
        try {
          return JSON.parse(json);
        } catch (e) {
          return null;
        }
      } // Exported for testing


      function _getDeepLinkFromCallback(url) {
        var params = searchParamsOrEmpty(url);
        var link = params['link'] ? decodeURIComponent(params['link']) : undefined; // Double link case (automatic redirect)

        var doubleDeepLink = searchParamsOrEmpty(link)['link']; // iOS custom scheme links.

        var iOSDeepLink = params['deep_link_id'] ? decodeURIComponent(params['deep_link_id']) : undefined;
        var iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)['link'];
        return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
      }
      /**
       * Optimistically tries to get search params from a string, or else returns an
       * empty search params object.
       */


      function searchParamsOrEmpty(url) {
        if (!(url === null || url === void 0 ? void 0 : url.includes('?'))) {
          return {};
        }

        var _url$split = url.split('?'),
            _url$split2 = _toArray(_url$split),
            _ = _url$split2[0],
            rest = _url$split2.slice(1);

        return (0, _firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)(rest.join('?'));
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /**
       * How long to wait for the initial auth event before concluding no
       * redirect pending
       */


      var INITIAL_EVENT_TIMEOUT_MS = 500;

      var CordovaPopupRedirectResolver = /*#__PURE__*/function () {
        function CordovaPopupRedirectResolver() {
          _classCallCheck(this, CordovaPopupRedirectResolver);

          this._redirectPersistence = _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.a;
          this._shouldInitProactively = true; // This is lightweight for Cordova

          this.eventManagers = new Map();
          this.originValidationPromises = {};
          this._completeRedirectFn = _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aA;
        }

        _createClass(CordovaPopupRedirectResolver, [{
          key: "_initialize",
          value: function () {
            var _initialize3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee186(auth) {
              var key, manager;
              return regeneratorRuntime.wrap(function _callee186$(_context186) {
                while (1) {
                  switch (_context186.prev = _context186.next) {
                    case 0:
                      key = auth._key();
                      manager = this.eventManagers.get(key);

                      if (!manager) {
                        manager = new CordovaAuthEventManager(auth);
                        this.eventManagers.set(key, manager);
                        this.attachCallbackListeners(auth, manager);
                      }

                      return _context186.abrupt("return", manager);

                    case 4:
                    case "end":
                      return _context186.stop();
                  }
                }
              }, _callee186, this);
            }));

            function _initialize(_x283) {
              return _initialize3.apply(this, arguments);
            }

            return _initialize;
          }()
        }, {
          key: "_openPopup",
          value: function _openPopup(auth) {
            (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.as)(auth, "operation-not-supported-in-this-environment"
            /* OPERATION_NOT_SUPPORTED */
            );
          }
        }, {
          key: "_openRedirect",
          value: function () {
            var _openRedirect4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee187(auth, provider, authType, eventId) {
              var manager, event, url, iabRef;
              return regeneratorRuntime.wrap(function _callee187$(_context187) {
                while (1) {
                  switch (_context187.prev = _context187.next) {
                    case 0:
                      _checkCordovaConfiguration(auth);

                      _context187.next = 3;
                      return this._initialize(auth);

                    case 3:
                      manager = _context187.sent;
                      _context187.next = 6;
                      return manager.initialized();

                    case 6:
                      // Reset the persisted redirect states. This does not matter on Web where
                      // the redirect always blows away application state entirely. On Cordova,
                      // the app maintains control flow through the redirect.
                      manager.resetRedirect();
                      (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aB)();
                      _context187.next = 10;
                      return this._originValidation(auth);

                    case 10:
                      event = _generateNewEvent(auth, authType, eventId);
                      _context187.next = 13;
                      return _savePartialEvent(auth, event);

                    case 13:
                      _context187.next = 15;
                      return _generateHandlerUrl(auth, event, provider);

                    case 15:
                      url = _context187.sent;
                      _context187.next = 18;
                      return _performRedirect(url);

                    case 18:
                      iabRef = _context187.sent;
                      return _context187.abrupt("return", _waitForAppResume(auth, manager, iabRef));

                    case 20:
                    case "end":
                      return _context187.stop();
                  }
                }
              }, _callee187, this);
            }));

            function _openRedirect(_x284, _x285, _x286, _x287) {
              return _openRedirect4.apply(this, arguments);
            }

            return _openRedirect;
          }()
        }, {
          key: "_isIframeWebStorageSupported",
          value: function _isIframeWebStorageSupported(_auth, _cb) {
            throw new Error('Method not implemented.');
          }
        }, {
          key: "_originValidation",
          value: function _originValidation(auth) {
            var key = auth._key();

            if (!this.originValidationPromises[key]) {
              this.originValidationPromises[key] = _validateOrigin(auth);
            }

            return this.originValidationPromises[key];
          }
        }, {
          key: "attachCallbackListeners",
          value: function attachCallbackListeners(auth, manager) {
            // Get the global plugins
            var _cordovaWindow3 = _cordovaWindow(),
                universalLinks = _cordovaWindow3.universalLinks,
                handleOpenURL = _cordovaWindow3.handleOpenURL,
                BuildInfo = _cordovaWindow3.BuildInfo;

            var noEventTimeout = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee188() {
              return regeneratorRuntime.wrap(function _callee188$(_context188) {
                while (1) {
                  switch (_context188.prev = _context188.next) {
                    case 0:
                      _context188.next = 2;
                      return _getAndRemoveEvent(auth);

                    case 2:
                      manager.onEvent(generateNoEvent());

                    case 3:
                    case "end":
                      return _context188.stop();
                  }
                }
              }, _callee188);
            })), INITIAL_EVENT_TIMEOUT_MS);

            var universalLinksCb = /*#__PURE__*/function () {
              var _ref41 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee189(eventData) {
                var partialEvent, finalEvent;
                return regeneratorRuntime.wrap(function _callee189$(_context189) {
                  while (1) {
                    switch (_context189.prev = _context189.next) {
                      case 0:
                        // We have an event so we can clear the no event timeout
                        clearTimeout(noEventTimeout);
                        _context189.next = 3;
                        return _getAndRemoveEvent(auth);

                      case 3:
                        partialEvent = _context189.sent;
                        finalEvent = null;

                        if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData['url'])) {
                          finalEvent = _eventFromPartialAndUrl(partialEvent, eventData['url']);
                        } // If finalEvent is never filled, trigger with no event


                        manager.onEvent(finalEvent || generateNoEvent());

                      case 7:
                      case "end":
                        return _context189.stop();
                    }
                  }
                }, _callee189);
              }));

              return function universalLinksCb(_x288) {
                return _ref41.apply(this, arguments);
              };
            }(); // Universal links subscriber doesn't exist for iOS, so we need to check


            if (typeof universalLinks !== 'undefined' && typeof universalLinks.subscribe === 'function') {
              universalLinks.subscribe(null, universalLinksCb);
            } // iOS 7 or 8 custom URL schemes.
            // This is also the current default behavior for iOS 9+.
            // For this to work, cordova-plugin-customurlscheme needs to be installed.
            // https://github.com/EddyVerbruggen/Custom-URL-scheme
            // Do not overwrite the existing developer's URL handler.


            var existingHandleOpenURL = handleOpenURL;
            var packagePrefix = "".concat(BuildInfo.packageName.toLowerCase(), "://");

            _cordovaWindow().handleOpenURL = /*#__PURE__*/function () {
              var _ref42 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee190(url) {
                return regeneratorRuntime.wrap(function _callee190$(_context190) {
                  while (1) {
                    switch (_context190.prev = _context190.next) {
                      case 0:
                        if (url.toLowerCase().startsWith(packagePrefix)) {
                          // We want this intentionally to float
                          // eslint-disable-next-line @typescript-eslint/no-floating-promises
                          universalLinksCb({
                            url: url
                          });
                        } // Call the developer's handler if it is present.


                        if (typeof existingHandleOpenURL === 'function') {
                          try {
                            existingHandleOpenURL(url);
                          } catch (e) {
                            // This is a developer error. Don't stop the flow of the SDK.
                            console.error(e);
                          }
                        }

                      case 2:
                      case "end":
                        return _context190.stop();
                    }
                  }
                }, _callee190);
              }));

              return function (_x289) {
                return _ref42.apply(this, arguments);
              };
            }();
          }
        }]);

        return CordovaPopupRedirectResolver;
      }();
      /**
       * An implementation of {@link PopupRedirectResolver} suitable for Cordova
       * based applications.
       *
       * @public
       */


      var _cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;

      function generateNoEvent() {
        return {
          type: "unknown"
          /* UNKNOWN */
          ,
          eventId: null,
          sessionId: null,
          urlResponse: null,
          postBody: null,
          tenantId: null,
          error: (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.av)("no-auth-event"
          /* NO_AUTH_EVENT */
          )
        };
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      // This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
      // It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it out
      // of autogenerated documentation pages to reduce accidental misuse.


      function _addFrameworkForLogging(auth, framework) {
        (0, _index_91e5512e_js__WEBPACK_IMPORTED_MODULE_0__.aC)(auth)._logFramework(framework);
      } //# sourceMappingURL=internal.js.map

      /***/

    },

    /***/
    5380:
    /*!*************************************************************!*\
      !*** ./node_modules/firebase/compat/auth/dist/index.esm.js ***!
      \*************************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var _firebase_auth_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @firebase/auth-compat */
      28181); //# sourceMappingURL=index.esm.js.map

      /***/

    }
  }]);
})();
//# sourceMappingURL=node_modules_firebase_compat_auth_dist_index_esm_js-es5.js.map